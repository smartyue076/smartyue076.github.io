<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>“开卷”何必“有益”</title>
      <link href="/2025/01/03/%E5%BC%80%E5%8D%B7%E4%BD%95%E5%BF%85%E6%9C%89%E7%9B%8A/"/>
      <url>/2025/01/03/%E5%BC%80%E5%8D%B7%E4%BD%95%E5%BF%85%E6%9C%89%E7%9B%8A/</url>
      
        <content type="html"><![CDATA[<p>记得小学阅读课上，我在读一本悬疑小说并写到了读后感作业中，结果第二天就被老师批评，并以“开卷有益”这个成语来教导我说，你这种书以后少读读。当时，我就觉得老师这种说法一定是错的，但限于那时的表达能力和逻辑能力并不能给出完整的反驳，现写下此文以表述自己的想法。<br>“以后少读读”这句话一直在我脑海中，我不理解曾几何时，书之间也有了贵贱之分，难道读四大名著的就是好学生，读《福尔摩斯》的就是差学生吗？“开卷有益”指的是读书总有好处，并非告诉我们先对于书是否有益有了定性之后再去读。老师说的这些话显然是没有道理的。<br>那她又是出于什么原因这样说呢？说到底，四个字，功利主义。什么书对于学习有帮助那就是有益的，没帮助就是浪费时间。我们中的很多人从小被灌输这样一个观念：只有努力学习才能上好大学，只有上好大学才能找到好工作，才能有幸福的生活。曾经我也认为这句话是对的，为了以后能开心地生活现在必须努力学习。但真的是这样吗？从学校到工作到生话并非完全是后者依赖前者的先序关系，其中某一环节的丢失并不一定能影响到之后的生活。这种观点只是指出人生中几个重要结点，并对每一个结点提出要求。上了好大学能就能仕途一帆风顺，有了好工作真能天天开开心心享受生活？不尽然。<br>    前段时间，“鸡娃”一度成为社会热点问题，家长给孩子报了各种补课班，兴趣班，以求孩子能领先他人一步。我想，他们也许都是上文观点的拥趸，生怕自己孩子因为没补课而落后其他同学。其实，我小时候也是个“鸡娃”，从幼儿园开始补课直到高中毕业，周末只是换了个地方上课。现在看来，报那么多班其实未必有用，现在的我也只是刚从普通大学毕业，过着平淡的生话。每个人学习能力不同，那假设补课班是有用的，能让所有上课的孩子成绩提升，考上好大学，但那之后呢，补课班除了能培养出优秀的做题家外并不会给孩子带来什么。<br>    好大学并不是人生的终点，拥有幸福快乐的人生也不是名校生的特权，否则怎么会有某大学投毒案，某大学弑母案呢？这一切的一切都是功利主义在作祟，他们认为人生只需要为那几个重要结点去准备就行了，达到目的则视为成功，在他们的眼中，世界是线性的，必须要完成一个个小目标，追求利益最大化，否则就是失败。但他们不知道的是人生并不是一蹴而就的，阶段性的成功并不意味着什么。事物之间也在不断变化发展，幸福的人生并不是公式化的结果，在这之中更重要的是我们对为人处世的态度，以及对于个人，社会，以及世界的看法，这会贯穿人的一生，而非学校，工作等短暂的光环。<br>冯友兰先生将人生分为四种境界：自然镜界，功利境界，道德境界和天地境界。你我皆为凡人，虽难以达到“敬天爱人，天人合一”，但也不应在功利境界一直徘徊，为了眼前的利益患得患失。“开卷”何必“有益”，看自己想看的书，做自己想做的事，何必要按照公式走完自己的人生呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理与实现</title>
      <link href="/2025/01/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/01/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池原理与实现"><a href="#线程池原理与实现" class="headerlink" title="线程池原理与实现"></a>线程池原理与实现</h2><blockquote><p>B站讲解视频：<a href="https://www.bilibili.com/video/BV1sk4y1P7UM/?vd_source=c5564ed8491572469d815a8188748293">线程池原理与实现</a></p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h4><p><strong>线程池（Thread Pool）</strong>是一种基于<strong>池化思想</strong>管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p><strong>线程过多会带来额外的开销</strong>，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><span id="more"></span><p><img src="/../../images/thread_pool.png" alt="thread_pool"></p><p>使用线程池可以带来一系列好处：</p><ul><li><strong>降低资源消耗（系统资源）</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高线程的可管理性（系统资源）</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提高响应速度（任务响应）</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提供更多更强大的功能（功能扩展）</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h4 id="线程池解决的问题"><a href="#线程池解决的问题" class="headerlink" title="线程池解决的问题"></a>线程池解决的问题</h4><p>线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p><ul><li><p><strong>频繁申请&#x2F;销毁资源和调度资源</strong>，将带来额外的消耗，可能会非常巨大。</p></li><li><p><strong>对资源无限申请缺少抑制手段</strong>，易引发系统资源耗尽的风险。</p></li><li><p><strong>系统无法合理管理内部的资源分布</strong>，会降低系统的稳定性。</p></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><a href="https://github.com/Pithikos/C-Thread-Pool">C Thread Pool（Github）</a></p><table><thead><tr><th>Function example</th><th>Description</th></tr></thead><tbody><tr><td><em><strong>thpool_init(4)</strong></em></td><td>Will return a new threadpool with <code>4</code> threads.</td></tr><tr><td><em><strong>thpool_add_work(thpool, (void*)function_p, (void*)arg_p)</strong></em></td><td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td></tr><tr><td><em><strong>thpool_wait(thpool)</strong></em></td><td>Will wait for all jobs (both in queue and currently running) to finish.</td></tr><tr><td><em><strong>thpool_destroy(thpool)</strong></em></td><td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td></tr><tr><td><em><strong>thpool_pause(thpool)</strong></em></td><td>All threads in the threadpool will pause no matter if they are idle or executing work.</td></tr><tr><td><em><strong>thpool_resume(thpool)</strong></em></td><td>If the threadpool is paused, then all threads will resume from where they were.</td></tr><tr><td><em><strong>thpool_num_threads_working(thpool)</strong></em></td><td>Will return the number of currently working threads.</td></tr></tbody></table><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><h4 id="thpool-init-int-num-threads"><a href="#thpool-init-int-num-threads" class="headerlink" title="thpool_init(int num_threads)"></a>thpool_init(int num_threads)</h4><ol><li>创建线程池基本结构</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">thread **threads;  <span class="comment">/* pointer to threads        */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;  <span class="comment">/* threads currently alive   */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num_threads_working; <span class="comment">/* threads currently working */</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> thcount_lock;  <span class="comment">/* used for thread count etc */</span></span><br><span class="line"><span class="type">pthread_cond_t</span> threads_all_idle;  <span class="comment">/* signal to thpool_wait     */</span></span><br><span class="line">jobqueue jobqueue;  <span class="comment">/* job queue                 */</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建线程池中的线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread *));</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n=<span class="number">0</span>; n&lt;num_threads; n++)&#123;</span><br><span class="line">thread_init(thpool_p, &amp;thpool_p-&gt;threads[n], n);</span><br></pre></td></tr></table></figure><h5 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h5><ol><li><p>对于<strong>资源申请失败的处理</strong>，防止<strong>异常退出和内存泄漏</strong></p><p>由于malloc申请失败是不报错的，在malloc之后<strong>一定要判断返回的指针值是否为NULL</strong>。如果对于这个空指针不做处理，那之后对于空指针的操作<strong>会引发Segmentation Fault</strong>而程序直接core了。还有就是在异常处理中要对已经申请的资源释放掉，否则会引发<strong>内存泄漏</strong></p></li><li><p>对于<strong>传值和传址</strong>的区分，传值传的是值的拷贝</p></li></ol><p>​如果对于指针理解得比较困难的开发者可以看看<a href="https://space.bilibili.com/519963684">南科大于仕琪老师的C&#x2F;C++教程</a></p><h4 id="int-thpool-add-work-thpool-thpool-p-void-function-p-void-void-arg-p"><a href="#int-thpool-add-work-thpool-thpool-p-void-function-p-void-void-arg-p" class="headerlink" title="int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p)"></a>int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p)</h4><ol><li>创建任务</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newjob = (<span class="keyword">struct</span> job *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure><ol start="2"><li>配置函数和函数参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure><ol start="3"><li>将任务加入队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure><h5 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h5><ol><li><p>对于队列<strong>没有任务时的处理</strong></p><p>不是采用轮询的方式，而是使用条件变量，在有任务时唤醒条件变量</p></li><li><p>对于<strong>函数指针类型转换的处理</strong></p></li></ol><p>​自定义的函数原型可以与api的原型不一致，但需要进行强制类型转换，<code> (void *(*)(void *))</code>里面中间的*表示当前为函数指针，右边的void *表示参数类型，左边的void *表示返回值类型。切记不要让编译器去做这种类型转换，可能会有意想不到的问题。（pthread_create参数里最后的函数指针的参数这样写好像就不必转换类型了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   int pthread_create(pthread_t *restrict thread,</span></span><br><span class="line"><span class="comment">//                   const pthread_attr_t *restrict attr,</span></span><br><span class="line"><span class="comment">//                   void *(*start_routine)(void *),</span></span><br><span class="line"><span class="comment">//                   void *restrict arg);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static void *thread_do(struct thread *thread_p)</span></span><br><span class="line">pthread_create(&amp;(*thread_p)-&gt;pthread, <span class="literal">NULL</span>, (<span class="type">void</span> *(*)(<span class="type">void</span> *))thread_do, (*thread_p));</span><br></pre></td></tr></table></figure><h4 id="void-thpool-destroy-thpool-thpool-p"><a href="#void-thpool-destroy-thpool-thpool-p" class="headerlink" title="void thpool_destroy(thpool_ *thpool_p)"></a>void thpool_destroy(thpool_ *thpool_p)</h4><ol><li>结构体元素的复位</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">time_t</span> start, end;</span><br><span class="line">  <span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过条件变量的唤醒终止线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive)</span><br><span class="line">&#123;</span><br><span class="line">  bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">  time(&amp;end);</span><br><span class="line">  tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive)</span><br><span class="line">&#123;</span><br><span class="line">  bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>任务队列的释放</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure><ol start="4"><li>其余堆上元素的释放</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; threads_total; n++)</span><br><span class="line">&#123;</span><br><span class="line">  thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure><h5 id="关注点-2"><a href="#关注点-2" class="headerlink" title="关注点"></a>关注点</h5><ol><li>对于<strong>线程释放的处理</strong></li></ol><p>​可以<strong>定义一个条件变量来唤醒所有线程</strong>，然后通过一个<strong>表示是否存活的布尔值来作为while循环的终止条件</strong>，达到优雅的释放</p><ol start="2"><li>别漏，别漏，别漏</li></ol><p>​一定要细心检查，不要忘记释放堆上的资源</p><h4 id="static-void-thread-hold-int-sig-id"><a href="#static-void-thread-hold-int-sig-id" class="headerlink" title="static void thread_hold(int sig_id)"></a>static void thread_hold(int sig_id)</h4><ol><li>注册信号量句柄</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function thread_do</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler function</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span></span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>)sig_id;</span><br><span class="line">threads_on_hold = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (threads_on_hold)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过信号量发送暂停信号</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++)</span><br><span class="line">&#123;</span><br><span class="line">  pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-thpool-resume-thpool-thpool-p"><a href="#void-thpool-resume-thpool-thpool-p" class="headerlink" title="void thpool_resume(thpool_ *thpool_p)"></a>void thpool_resume(thpool_ *thpool_p)</h4><p>修改循环条件值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们明白了线程池是什么（What），线程池有什么用（Why）以及接口的具体实现（How）。这个线程池项目中有许多值得学习的地方，比方说对于条件变量的使用，对于资源的申请和释放方法，是很优质的开源项目。另外，项目里也有可以扩充的点，比方说把队列改成比方说把队列改成优先级队列，那这样要考虑的东西就更多了，比方说它任务是可抢占还是不可抢占的，有任务的调度顺序的变化，这可能会牵涉到线程逻辑的大修改，如果大家感兴趣的话可以试试～</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（三）指针</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-C-基础——指针"><a href="#第二章-C-基础——指针" class="headerlink" title="第二章 C++基础——指针"></a>第二章 C++基础——指针</h2><p>指针是一个变量，其存储的是值的地址，而不是值本身</p><p>使用常规变量时，值是指定的量，而地址是派生量，而指针相反</p><p><strong>OOP</strong>强调的是在运行阶段（而不是编译阶段）进行决策，提供了灵活性，对于内存管理也更加高效</p><h3 id="初始化指针"><a href="#初始化指针" class="headerlink" title="初始化指针"></a>初始化指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr_a;</span><br><span class="line"><span class="type">double</span>* ptr_b;</span><br></pre></td></tr></table></figure><p>初始化时必须指定所指元素类型，因为对所有指针来说其都是代表一个初始地址，但从该初始地址读多少字节则由指针类型判断</p><p>指针也是作为变量存储，只不过其内存空间存的是地址。指针p1,p2有各自的地址&amp;p1,&amp;p2。长度为4B（32位）或8B（64位）。p1,p2表示存储的所指向元素的地址。*p1表示指向元素的值。<br><img src="/../../images/1.png" alt="image.png" style="zoom:30%;" /></p><h3 id="指针注意事项"><a href="#指针注意事项" class="headerlink" title="指针注意事项"></a>指针注意事项</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存（指向不确定）。另外，<strong>一定要在对指针提取（*）之前，将指针初始化为一个确定的、适当的地址。</strong></p><p>一个未指向任何对象的指针，其地址值为0。有时称之为<code>null指针</code>。任何指针都可以被初始化或令其值为0。</p><p>指针不是整型，虽然计算机通常把地址当作整数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pt;</span><br><span class="line">pt = <span class="number">0xB80000000</span>; <span class="comment">//invalid, type mismatch</span></span><br><span class="line">pt = (<span class="type">int</span>*)<span class="number">0xB80000000</span>; <span class="comment">//valid, type match</span></span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>可以修改指针的值，但数组名是常量不能修改</p><p>指针变量加1后，其增加的值等于指向的类型占用的字节数</p><p>将一个指针减去另一个指针，获得两个指针的差（必须类型相同，差为地址实际差&#x2F;变量类型长度），仅在都指向同一数组时有意义</p><p>对数组应用sizeof得到的是数组的长度，而对指针应用sizeof得到的是指针的长度</p><h4 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h4><p>  tell和&amp;tell数值相同，但tell指向数组第一个元素，tell+1将地址值加2。&amp;tell指向整个数组，&amp;tell+1将地址值加2*10&#x3D;20</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> tell[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt; tell &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; &amp;tell &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>  数组指针指向整个数组，初始化为</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">short</span> (*pas)[<span class="number">10</span>] = &amp;tell;</span><br></pre></td></tr></table></figure><p>  指针数组为多个指针变量组成的数组，初始化为</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> *pas[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="自由存储空间"><a href="#自由存储空间" class="headerlink" title="自由存储空间"></a>自由存储空间</h3><h4 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeName * pointer_name = new typeName</span></span><br><span class="line"><span class="type">int</span>* pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```typeName*```指声明什么类型的指针，左右两侧的类型必须相同，否则因为读取的块大小不同而访问错误</span><br><span class="line"></span><br><span class="line">**变量存储在栈（stack）的内存区域中，new从堆（heap）或自由存储（free store）的内存区域分配内存**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用delete释放内存</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">int* ps = new int;</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure><p>这将删除<em>ps</em>所指向的内存，但不会删除<em>ps</em>本身，ps还可指向其他内存空间</p><p>需要注意的是：</p><ul><li>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存</li><li>不要使用<code>delete</code>释放同一个内存两次</li><li>对空指针(<em>null pointer</em>)使用<code>delete</code>是安全的</li></ul><h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] psome;</span><br></pre></td></tr></table></figure><p>数组直接通过<code>psome[num]</code>访问</p><p>需要注意的是：</p><ul><li>如果使用<code>new [] </code>为数组分配内存，则需要通过<code>delete []</code>来释放</li><li>如果使用<code>new</code>为一个实体分配内存，则应使用<code>delete</code>来释放</li></ul><h3 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h3><p>对于复杂表达式应从右往左读</p><p><code>int *&amp;r = p</code></p><p>表示r首先是对p的引用，其次r是一个int*型的引用</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p> 定义时必须初始化</p><p>不能改变绑定的指向（内部通过顶层const实现，type * const p）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//(pointer to b) equal to (pointer to a)</span></span><br></pre></td></tr></table></figure><p>引用间不能赋值</p><p>没有引用的引用，没有指针的引用，可以有引用的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;* p; <span class="comment">//illegal</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp; p)</span></span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（二）基本数据类型</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>当一个算术表达式中既有无符号数又有<code>int</code>值时，int会被转换为无符号数</li><li>当从无符号数中减去一个值时，不管这个值是不是无符号数，都必须保证结果不为负（否则为取模后值）</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量声明于定义的关系"><a href="#变量声明于定义的关系" class="headerlink" title="变量声明于定义的关系"></a>变量声明于定义的关系</h4><p>变量<strong>声明（declaration）</strong>定义了变量的类型和名字，<strong>定义（definition）</strong>在声明外还申请存储空间</p><p>如果只想声明，可在变量名前添加关键字<code>extern</code></p><p>变量只能被定义一次，但是可以多次声明</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（四）const限定符</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>const对象一经创建后其值不能再改变，所以const对象必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，const对象仅在文件内有效。若需在不同文件使用同一const对象，则const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>用于声明引用的const都是底层const，引用本身已默认为顶层const（无法改变指向）</p><p>const型变量只能由const型引用（底层const）</p><p>不能把普通引用绑定到字面值上，需用底层const</p><p>非const型变量可以由const型引用，但不可通过引用修改被引用变量值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">1</span>; <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><h3 id="指针和常量"><a href="#指针和常量" class="headerlink" title="指针和常量"></a>指针和常量</h3><p>若变量为const，则它的指针或引用必为const</p><p>要想存放常量对象的地址，只能使用指向常量的指针（底层const）</p><p>指向常量的指针（pointer to const）不能通过指针改变常量值 —— 底层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i; <span class="comment">// eqal to (int const *p =&amp;i;)</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><p>常量指针（const pointer）必须初始化，而且初始化完成后，其指向的地址不能再改变 —— 顶层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;i;</span><br><span class="line">p = &amp;j;<span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><p>指向常量的常量指针（const pointer to const），包含上述两种特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = &amp;i;</span><br></pre></td></tr></table></figure><p>类和const</p><p>函数后加const表示不修改任何成员变量（通过const *this实现 ）</p><p>如果类包含const变量，必须通过初始化列表初始化</p><h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><p>当执行对象的拷贝操作时，顶层const不受影响</p><p>底层const要求拷入和拷出的对象必须具有相同的底层const资格，或者两个对象能相互转换。非常量可以转化为常量（等号右侧表达式），反之不行</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（六）异常处理</title>
      <link href="/2025/01/03/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2025/01/03/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当执行throw时，throw后的语句都不执行，控制权转移到与之对应的catch模块</p><p>退出catch后，catch模块中的局部变量将会销毁</p><p>当异常处理完毕后，异常对象将被销毁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="built_in">catch</span> (exception_a)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="built_in">catch</span> (exception_b)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕捉catch（对于每个catch执行下述步骤）"><a href="#捕捉catch（对于每个catch执行下述步骤）" class="headerlink" title="捕捉catch（对于每个catch执行下述步骤）"></a>捕捉catch（对于每个catch执行下述步骤）</h3><ol><li>判断是否是精确匹配</li><li>派生类向基类转换（仅引用和指针类型）</li><li>（…）匹配所有</li></ol><p>其中一个被捕捉，跳过下面的catch</p><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>一条catch语句通过重新抛出的稻作将异常传递给另一个catch语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>new申请内存失败返回bad_alloc异常，不是返回0</p><p>处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（五）static关键字</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h3><p>static变量只能在当前文件访问，其他文件不能通过extern访问</p><h3 id="static局部变量"><a href="#static局部变量" class="headerlink" title="static局部变量"></a>static局部变量</h3><p>定义时创建，程序结束时销毁，修改了生命周期，作用域不变</p><h3 id="static类"><a href="#static类" class="headerlink" title="static类"></a>static类</h3><p>static对象的构造在main函数前执行，析构在main函数结束后</p><h3 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h3><p>存在于所有对象且保持一致，可在其他文件访问</p><p>不能在初始化列表初始化</p><p>需在类外定义，因为class内语句都是声明</p><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><p>可通过类名::函数调用，只能使用static成员变量，否则报错，没有this指针，不能访问非static成员 变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发面试题整理</title>
      <link href="/2025/01/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2025/01/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题汇总"><a href="#面试题汇总" class="headerlink" title="面试题汇总"></a>面试题汇总</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><strong>C 和 CPP 区别是什么</strong></p><table><thead><tr><th></th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>编程范式</td><td>面向过程</td><td>面向对象</td></tr><tr><td>函数重载</td><td>无</td><td>有</td></tr><tr><td>引用</td><td>无</td><td>有</td></tr></tbody></table><p><strong>C++编译过程</strong></p><p>预处理：展开include和define</p><p>编译：转化为汇编代码</p><p>汇编：转化为二进制机器码</p><p>链接：将目标和其需要的库链接成可执行文件</p><p><strong>指针和引用的区别</strong></p><table><thead><tr><th></th><th>指针</th><th>引用</th></tr></thead><tbody><tr><td>内存空间</td><td>占用</td><td>不占用</td></tr><tr><td>是否可为空</td><td>可以</td><td>不可以，必须只指向存在的变量</td></tr><tr><td>修改指向</td><td>可以</td><td>不可以</td></tr></tbody></table><p>其实<strong>引用在编译时作为const指针处理</strong></p><p><strong>C++ 内存分布</strong></p><img src="/../../images/memoryLayoutC.jpg" width=500px /><p><strong>sizeof数组是多少，指针是多少</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; endl;           <span class="comment">// 0x16fb9b28c</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;            <span class="comment">// 0x16fb9b28c</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;    <span class="comment">// 12 = 3 * 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a[<span class="number">1</span>]) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(&amp;a) &lt;&lt; endl;   <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">test</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组名和指针的区别</strong></p><p>对于数组名和指针是两个概念，但是对于<code>a[3]</code>来说a和&amp;a的地址是一样的，数组名a代表的是整个数组，当dereference如<code>a[1]</code>时，数组名转化为指向首元素的指针，得出的值为<code>*(a+1*sizeof(int))</code>，另外在做右值时a也会转化为指向首元素的指针（<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer">参考</a>）</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p><strong>继承方法</strong></p><p><strong>C++ 重载和重写的区别</strong></p><p>重载（Overloading）：重载是指在同一个作用域内，对一个函数或者运算符进行多次定义，每个定义有不同的参数列表或参数类型。通过重载，我们可以在同一个作用域内使用相同的函数名或运算符符号来执行不同的操作。</p><p>重写（Overriding）：重写是指在派生类中重新定义基类中已经存在的虚函数。重写后的函数与基类中的函数具有相同的函数名和参数列表，但是在派生类中的实现可以不同于基类中的实现。重写允许派生类覆盖基类的实现，以实现多态性。</p><p><strong>多态的概念</strong></p><p>不同的对象对于同一消息作出不同的响应。子类在继承父类后可以设计自己的版本，在运行时动态选择调用哪个版本实现</p><p><strong>静态绑定和动态绑定</strong></p><p>在面向对象编程中，静态绑定和动态绑定是两种不同的函数调用机制。</p><p><strong>静态绑定（Static Binding）</strong>，也称为早期绑定或编译期绑定，是指<strong>在程序编译时就将函数调用与函数实现绑定起来，而不考虑对象的实际类型</strong>。这种绑定是通过函数的名称和参数列表来实现的。在静态绑定中，编译器会<strong>在编译期间确定调用哪个函数</strong>，而不是在运行时确定。静态绑定通常适用于非虚函数的调用，因为非虚函数的调用是在编译期间就可以确定的。</p><p><strong>动态绑定（Dynamic Binding）</strong>，也称为晚期绑定或运行时绑定，是指<strong>在程序运行时根据对象的实际类型来决定调用哪个函数</strong>。这种绑定是通过虚函数来实现的。在动态绑定中，编译器会在运行时确定调用哪个函数，而不是在编译期间确定。动态绑定适用于需要实现多态性的情况，可以<strong>让基类指针或引用调用派生类中的函数实现，实现运行时多态性</strong>。</p><p><strong>虚函数</strong></p><p><strong>作用</strong></p><ul><li><p>实现动态多态性（Runtime Polymorphism）：通过使用虚函数，可以在运行时动态地确定调用的是基类函数还是派生类函数，实现多态性。例如，如果我们有一个指向基类对象的指针，我们可以使用虚函数来调用派生类中的适当函数。</p></li><li><p>支持运行时类型识别（RTTI）：通过使用虚函数和类型信息（type information），可以在运行时确定对象的实际类型，从而实现更加灵活的代码设计。</p></li><li><p>简化代码维护：使用虚函数可以将代码的实现细节从类的使用者中分离出来，使得修改基类的实现对派生类的影响最小。</p></li></ul><p><strong>实现</strong></p><p>类保存指向保存了所有虚函数指针的表（vtable）的指针（vptr），通过基类指针调用虚函数时访问vtable选择特定的函数指针调用</p><p><strong>类中有一个虚函数大小是多少</strong></p><p>为一个指针的大小</p><p><strong>C++ 的友元</strong></p><p>可以访问一个类的非公有成员的函数或类。作用是提高代码封装性，简化了一些实现</p><ul><li>友元函数：该函数可以访问该类的私有成员和保护成员</li><li>友元类：该类可以访问该类的私有成员和保护成员</li><li>友元成员函数：该成员函数的私有成员和保护成员</li></ul><p><strong>空类包括什么成员</strong></p><p>不包含任何成员，只是sizeof时为1，应为C++中每个对象大小必须大于0</p><p><strong>悬空指针所指向的内存被释放了，那么这个指针还存在吗</strong></p><p>存在，只是释放了指向的内容</p><p><strong>浅拷贝和深拷贝有什么区别</strong> </p><p>浅拷贝为字节流的拷贝，对于指针来说，通过浅拷贝会使新对象和旧对象指向同一块内存（类默认的拷贝构造和拷贝赋值）</p><p>深拷贝在复制时为指针分配新的内存，新对象和旧对象有各自独立的空间</p><p><strong>一个类的大小由什么决定</strong></p><p>成员变量的个数，是否继承，是否有虚函数等，有虚函数的话，那么类就会多一个虚表指针，类的大小就会多8字节</p><p><strong>一个子类继承空基类，对子类的大小会有影响吗 (空白基优化)</strong></p><p>不会，基类大小的1优化成0</p><h5 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h5><p><strong>左值和右值引用</strong></p><p>左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong></p><p>使用<code>std::move()</code>可以将左值转化为右值，其在调用右值的拷贝时为浅拷贝，性能较深拷贝强。但作为右值被使用后，这个变量不应该再使用</p><p><strong>悬空指针和野指针的区别</strong></p><p>悬空指针为指针最初指向的内容已经被释放的指针</p><p>野指针是没初始化的指针</p><p><strong>智能指针，循环引用会怎么样</strong></p><p>内存泄漏</p><p>可以这样避免</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;B&gt; p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  weak_ptr&lt;A&gt; p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sharedptr 和weakptr使用场景</strong></p><ul><li><code>unique_ptr</code><br>只允许基础指针的一个所有者</li><li><code>shared_ptr</code><br>采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 <code>shared_ptr</code> 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块</li><li><code>weak_ptr</code><br>结合 <code>shared_ptr</code> 使用的特例智能指针。 <code>weak_ptr</code> 提供对一个或多个 <code>shared_ptr</code> 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 <code>shared_ptr</code> 实例间的循环引用。</li></ul><p><strong>在A函数里用指针申请好空间后，这块空间需要返回给B函数，然后B函数使用后不再使用这块内存，虽然我们可以手动释放，但往往可能忘记释放，请问用什么方式解决？（智能指针解决）</strong></p><p>A为shared pointer，B为A的weak pointer</p><p><strong>智能指针的局限</strong></p><p>智能指针<strong>不能用于指向栈上的对象或静态变量</strong>，因为这些对象的生命周期是<strong>由编译器控制的</strong>，不需要手动管理内存。<br>智能指针可能会<strong>对性能产生一定的开销</strong>，因为它们需要维护引用计数、析构器等信息</p><h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><p><strong>map和set插入删除有啥区别</strong></p><p><strong>说一下迭代器失效的情况，以及解决方法</strong></p><p>在C++ STL中，迭代器是一种指向容器中元素的对象，它提供了访问容器元素的能力，从而使得程序员可以对容器中的元素进行遍历、修改等操作。然而，在某些情况下，迭代器可能会失效，即不能继续使用。以下是一些常见的导致迭代器失效的情况：</p><ol><li>容器大小发生改变</li></ol><p>在使用迭代器遍历容器的过程中，如果容器的大小发生改变（如插入或删除元素），则迭代器可能会失效。此时，继续使用失效的迭代器会导致程序崩溃或产生不可预期的结果。</p><ol start="2"><li>插入元素导致内存重新分配</li></ol><p>对于一些容器（如vector、deque），在容器中插入元素时，可能会导致容器重新分配内存。如果此时使用了失效的迭代器，则可能会指向一个已被释放的内存地址，进而导致程序崩溃或产生不可预期的结果。</p><ol start="3"><li>删除元素导致迭代器失效</li></ol><p>在使用迭代器遍历容器的过程中，如果删除了容器中的元素，则可能导致迭代器失效。例如，对于vector容器，当使用erase()方法删除元素时，该元素之后的所有迭代器都会失效，因为它们指向的元素已经被删除。</p><p>为了避免迭代器失效，可以采取以下方法：</p><ol><li>使用迭代器前先进行检查</li></ol><p>在使用迭代器前，可以先检查容器中的元素是否发生了改变，从而避免使用失效的迭代器。例如，可以在循环遍历容器的时候，在每次循环前检查容器大小是否发生改变。</p><ol start="2"><li>使用智能指针或引用</li></ol><p>智能指针或引用是一种安全的访问容器中元素的方式，因为它们不会失效。在使用迭代器时，可以将它们转换为智能指针或引用，从而避免迭代器失效。</p><ol start="3"><li>使用成员函数返回值</li></ol><p>对于某些容器（如vector、deque），它们的成员函数返回值本身就是迭代器，而且使用这些函数返回的迭代器不会失效。例如，使用vector的begin()和end()方法返回的迭代器可以安全地用于遍历容器，即使在容器中插入或删除元素时也不会失效。</p><p><strong>函数返回引用类型和普通类型有什么区别</strong></p><p>函数返回引用类型和普通类型的最大区别在于，返回引用类型的函数可以返回一个左值，而返回普通类型的函数只能返回一个右值。</p><p>当一个函数返回引用类型时，返回值实际上是对一个对象的引用。如果这个对象是一个变量，那么这个函数返回的就是这个变量的引用，也就是一个左值。在这种情况下，返回值可以被用作左值进行赋值或修改。</p><p><strong>如果设计一个string类，头文件应该怎样设计？写头文件就行了。列举出需要哪些函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_STRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_STRING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_string</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="built_in">my_string</span>();</span><br><span class="line">  <span class="built_in">my_string</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">  <span class="built_in">my_string</span>(<span class="type">const</span> my_string&amp; other);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">my_string</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值运算符</span></span><br><span class="line">  my_string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> my_string&amp; other);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下标运算符</span></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串拼接运算符</span></span><br><span class="line">  my_string <span class="keyword">operator</span>+(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串比较运算符</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="built_in">operator</span>&lt;=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串长度函数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串查找函数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> my_string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串截取函数</span></span><br><span class="line">  <span class="function">my_string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* data_; <span class="comment">// 存储字符串的动态数组</span></span><br><span class="line">  <span class="type">size_t</span> size_; <span class="comment">// 字符串的长度</span></span><br><span class="line">  <span class="type">size_t</span> capacity_; <span class="comment">// 存储字符串的动态数组的容量</span></span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> npos = <span class="number">-1</span>; <span class="comment">// 无效位置的标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_STRING_H</span></span></span><br></pre></td></tr></table></figure><p>可以增加右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">my_string::<span class="built_in">my_string</span>(my_string&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">capacity_</span>(other.capacity_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    <span class="comment">// 将原对象置为空</span></span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">    other.capacity_ = <span class="number">0</span>;</span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_string&amp; my_string::<span class="keyword">operator</span>=(my_string&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前对象的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原对象的资源转移给当前对象</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原对象置为空</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.capacity_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector是什么？vector的底层实现？vector的扩容机制？</strong> </p><p><strong>deque是什么？deque的底层实现？怎么实现O(1)头插？</strong> </p><p><strong>map有几类？底层实现是什么？红黑树是什么？平衡树怎么实现平衡？</strong> </p><p><strong>set和map的区别？</strong></p><p><strong>set和map的理解及使用场景</strong></p><p><strong>map和unordered_map的结构及使用场景</strong></p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p><strong>内核态和用户态区别</strong></p><p>操作系统中内核态和用户态是两种运行模式，区别如下：</p><ol><li><strong>权限不同</strong>：内核态具有更高的权限，可以执行所有的指令，包括访问系统资源、执行特权指令等，而用户态则只能执行受限的指令，不能直接访问系统资源。</li><li><strong>执行环境不同</strong>：内核态运行在操作系统内核的上下文中，而用户态则运行在用户程序的上下文中。</li><li><strong>系统调用</strong>：用户态程序如果需要访问系统资源或执行特权指令，需要通过系统调用的方式切换到内核态，由内核代表用户程序执行相应的操作。</li><li><strong>中断处理</strong>：当硬件设备发生中断时，操作系统会切换到内核态进行中断处理，以保证系统正常运行。</li></ol><p><strong>线程间的同步方式</strong></p><ol><li><strong>互斥锁（Mutex）</strong>：使用互斥锁可以保证同一时间只有一个线程可以访问共享资源。当一个线程获得互斥锁后，其他线程需要等待该线程释放锁后才能再次尝试获取锁。</li><li><strong>信号量（Semaphore）</strong>：信号量是一个计数器，用于控制同时访问某个共享资源的线程数量。当某个线程需要访问共享资源时，它必须先获取信号量。如果当前信号量计数为0，则线程需要等待，直到有其他线程释放信号量。</li><li><strong>条件变量（Condition Variable）</strong>：条件变量用于线程间的通信和同步，当一个线程需要等待某个条件满足时，可以使用条件变量来阻塞自己，等待其他线程发出通知。当条件满足时，其他线程可以发出信号通知等待的线程继续执行。</li><li><strong>屏障（Barrier）</strong>：屏障用于控制多个线程在某个点上同步。当所有线程都到达这个点时，才能继续执行后面的代码。这种同步方式通常用于多个线程执行完某个任务后需要进行汇总的场景。</li><li><strong>读写锁（Read-Write Lock）</strong>：读写锁用于在多线程环境下对共享资源进行读写操作的同步。读写锁分为读锁和写锁两种，多个线程可以同时获得读锁，但只能有一个线程获得写锁。这样可以在保证数据一致性的前提下提高并发性能。</li></ol><p><strong>进程间的通信方式</strong></p><ol><li><strong>管道（Pipe）</strong>：管道是一种半双工的IPC机制，可以在两个进程之间传递数据。管道分为无名管道和命名管道两种，<strong>无名管道只能在具有亲缘关系的进程之间使用，而命名管道可以在不同进程之间使用</strong>。<strong>缺点：在没有读数据前不可以写数据</strong></li><li><strong>消息队列（Message Queue）</strong>：消息队列是一种基于队列的IPC机制，多个进程可以通过发送和接收消息来进行通信。消息队列具有一定的<strong>缓存能力</strong>，可以在进程之间传递不同大小的数据块。<strong>缺点：每个消息大小固定，队列大小受限，并且需要把消息从用户态拷贝到内核态</strong></li><li><strong>共享内存（Shared Memory）</strong>：共享内存是一种快速且高效的IPC机制，多个进程可以访问同一块物理内存，从而实现数据共享。共享内存需要使用信号量等同步机制来保证数据的一致性。</li><li><strong>信号（Signal）</strong>：信号是一种异步通信机制，可以用于向进程发送通知。当一个进程接收到信号时，会执行相应的信号处理函数。常见的<strong>信号包括中断信号和软件信号等</strong>。</li><li><strong>套接字（Socket）</strong>：套接字是一种通用的IPC机制，可以在不同的进程之间传递数据。套接字通常用于网络编程中，可以实现不同计算机之间的进程通信。</li></ol><p><strong>线程安全要加锁，什么情况可以不加锁?</strong></p><p>线程安全是指在多线程环境下，对共享数据的访问操作不会出现冲突或竞争，从而保证程序的正确性和可靠性。为了实现线程安全，通常需要对共享数据的访问加锁。</p><p>然而，并非所有情况都需要对共享数据加锁，以下是一些情况：</p><p>1**.只读访问**：如果一个共享数据只会被读取而不会被修改，那么在多个线程同时访问时就不需要加锁。因为只读操作不会改变数据的值，所以多个线程同时读取同一个数据也不会出现冲突。</p><p>2.<strong>线程本地存储</strong>：有些数据只需要在一个线程内部使用，不需要在多个线程之间共享，那么就不需要对这些数据加锁。例如，每个线程都有一个独立的栈空间，线程内部的栈空间就是线程本地存储，不需要对其加锁。</p><p>3.<strong>不变对象</strong>：如果一个对象在创建后就不再被修改，那么多个线程同时访问它也不需要加锁。因为对象不会被修改，所以多个线程同时访问同一个对象也不会出现冲突。</p><p>需要注意的是，虽然上述情况下不需要加锁，但仍然需要保证数据的可见性。为了保证数据的可见性，可以使用volatile关键字或者synchronized块来同步内存中的数据</p><p><strong>死锁（怎么预防）</strong></p><p>破坏“请求与保持”：一次性申请进程所需的所有资源</p><p>破坏“循环等待”：资源按顺序申请（其实达不到，没法预测程序走的分支）</p><p><strong>死锁避免（拒绝某些资源请求）</strong></p><p>每次申请资源都要判断是否出现死锁的危险，如果有危险就拒绝这次请求</p><p>通过<strong>银行家算法</strong>计算安全序列，充分性算法，<strong>完全避免死锁</strong></p><p>算法优先分配给能满足进程所需最大资源量的进程，一次分配所有所需要的所有资源</p><p><strong>死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）</strong></p><p>检测发生死锁的进程（资源未被使用，进程长时间未调度等），恢复进程并重新分配资源（<strong>改进的银行家算法</strong>）</p><p>改进的银行家算法分配每次进程请求的资源，而不是分配所需的所有资源，因为有事进程对于资源使用后就会释放，这样系统有更多余量</p><p><strong>虚拟内存和物理内存的关系</strong></p><p>虚拟内存将<strong>硬盘上的一部分空间映射到了物理内存中</strong>，通过<strong>地址映射</strong>实现虚拟内存和物理内存的交互。当应用程序需要访问某个地址时，操作系统<strong>先检查该地址是否在物理内存</strong>中，如果不在物理内存中，则从虚拟内存中将该地址所对应的数据读取到物理内存中。当物理内存中的空间不足时，操作系统会将一些较少使用的数据换出到硬盘上，以释放物理内存空间供其他程序使用。</p><p><strong>在4G物理内存机器上申请8G内存</strong></p><p>在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</p><p>在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题（申请只是分配虚拟内存，只有访问时才会调用缺页中断分配物理内存），因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：</p><ul><li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li><li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li></ul><p><strong>函数调用对内存的使用</strong></p><ol><li>所需参数压栈</li><li>返回地址压栈</li><li>被调用函数局部变量压栈</li><li>被调用函数局部变量出栈</li><li>返回地址出栈</li><li>所需参数出栈</li></ol><p>实际1，2不同的编译器和语言有差异，另外参数也可以通过寄存器传</p><p><strong>从磁盘预读的数据可能最后没有用到，有什么改善方法（预读污染）；批量读数据时可能会把热点数据挤出，有什么改善方法（缓存污染）</strong></p><p>传统的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><p>为了避免「预读失效」造成的影响，Linux 和 MySQL 对传统的 LRU 链表做了改进：</p><ul><li>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）</strong>。</li><li>MySQL Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li></ul><p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么<strong>还存在缓存污染的问题</strong>。</p><p>为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：</p><ul><li><p>Linux 操作系统：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</p></li><li><p>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行</p><p>停留在 old 区域的时间判断</p><ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p><strong>五大 IO 模型</strong></p><ol><li>阻塞 I&#x2F;O (Blocking I&#x2F;O)</li></ol><p>在阻塞 I&#x2F;O 中，当用户线程发起一个 I&#x2F;O 操作时，线程会一直阻塞等待，直到内核完成 I&#x2F;O 操作并将结果返回给用户线程。这种模型非常简单易懂，但是效率很低，因为当一个线程阻塞等待 I&#x2F;O 完成时，CPU 时间无法充分利用，这会导致程序的性能受到严重影响。</p><ol start="2"><li>非阻塞 I&#x2F;O (Non-blocking I&#x2F;O)</li></ol><p>在非阻塞 I&#x2F;O 中，用户线程发起一个 I&#x2F;O 操作后并不会阻塞，而是立即返回，然后线程不断地轮询该操作是否完成。这种模型比阻塞 I&#x2F;O 的效率高，但是也会导致 CPU 占用率过高，因为线程需要不断地轮询操作状态，浪费了大量的 CPU 资源。</p><ol start="3"><li>I&#x2F;O 多路复用 (I&#x2F;O Multiplexing)</li></ol><p>I&#x2F;O 多路复用可以监视多个文件描述符（sockets、标准输入输出、套接字等等）的可读可写等状态，当任何一个文件描述符就绪（可读或可写）时，就能够通知相应的线程进行读写操作。这种模型使用 select、poll、epoll 等多路复用技术，可以有效地避免线程阻塞等待 I&#x2F;O 完成的问题，提高程序的并发处理能力。</p><ol start="4"><li>信号驱动 I&#x2F;O (Signal-driven I&#x2F;O)</li></ol><p>信号驱动 I&#x2F;O 使用信号机制通知用户线程 I&#x2F;O 操作已经完成。在这种模型中，当用户线程发起 I&#x2F;O 操作后，内核会立即返回并允许线程继续执行其他任务。当 I&#x2F;O 操作完成后，内核会向用户线程发送一个信号来通知操作已经完成，然后线程可以调用相应的系统调用来读取数据。信号驱动 I&#x2F;O 可以避免线程阻塞等待 I&#x2F;O 完成的问题，但是也会导致一些其他问题，例如信号可能会被其他程序捕获，使得程序难以控制。</p><ol start="5"><li>异步 I&#x2F;O (Asynchronous I&#x2F;O)</li></ol><p>异步 I&#x2F;O 中，用户线程发起 I&#x2F;O 操作后，内核会立即返回并允许线程继续执行其他任务。当 I&#x2F;O 操作完成后，内核会向用户线程发送一个通知来告诉它操作已经完成，然后线程可以调用相应的系统调用来读取数据。异步 I&#x2F;O 模型可以避免线程阻塞等待 I&#x2F;O 完成的问题，并且可以自动处理 I&#x2F;O 缓冲区的数据传输</p><table><thead><tr><th>IO 模型</th><th>第一阶段</th><th>第二阶段</th></tr></thead><tbody><tr><td>阻塞式IO</td><td>阻塞</td><td>阻塞</td></tr><tr><td>非阻塞式IO</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>IO多路复用</td><td>阻塞（Select）</td><td>阻塞</td></tr><tr><td>信号驱动式IO</td><td>异步</td><td>阻塞</td></tr><tr><td>异步IO</td><td>异步</td><td>异步</td></tr></tbody></table><img src="/../../images/io_module.png" width=700px /><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p><strong>TCP 三次握手</strong></p><p>步骤为：</p><ol><li>client传给server自己的SYN c</li><li>server传给client自己的SYN s，对于server SYN的确认ACK c+1表示下个要接收的数据包序号</li><li>client传给server对于server SYN的确认ACK s+1</li></ol><p>为什么不是2次？</p><p><strong>防止历史连接的建立，造成资源浪费，而且无法可靠同步双方序号</strong></p><p>如果有一个历史连接到达server，对于两次连接server会立即分配资源，把ack c+1传给client，但是client比对下不是自己需要建立的连接，会拒绝请求，把RST发给server。相当于server白申请资源</p><p><strong>TCP与UDP区别</strong></p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>建立连接</td><td>有</td><td>无</td></tr><tr><td>流量控制</td><td>有</td><td>无</td></tr><tr><td>拥塞控制</td><td>有</td><td>无</td></tr><tr><td>有序</td><td>有</td><td>无</td></tr></tbody></table><p><strong>Tcp和Udp使用场景</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信</li></ul><p><strong>流量控制和拥塞控制</strong></p><p><strong>Get和Post</strong></p><table><thead><tr><th></th><th>Get</th><th>Post</th></tr></thead><tbody><tr><td>可被缓存</td><td>可以，浏览器或者server可以换讯</td><td>不可以</td></tr><tr><td>参数传递方式</td><td>url里</td><td>body里</td></tr><tr><td>应用场景</td><td>数据的请求，查询，搜索</td><td>提交数据，上传文件</td></tr><tr><td>请求大小</td><td>几KB到几百KB</td><td>理论上没限制</td></tr></tbody></table><p><strong>HTTP和HTTPS</strong></p><table><thead><tr><th></th><th>Http</th><th>Https</th></tr></thead><tbody><tr><td>安全性</td><td>明文传输</td><td>采用SSL&#x2F;TLS协议对数据加密</td></tr><tr><td>传输方式</td><td>TCP</td><td>SSL&#x2F;TLS</td></tr><tr><td>默认段口号</td><td>80</td><td>443</td></tr></tbody></table><p><strong>url解析</strong></p><ol><li>访问缓存，包括浏览器，操作系统缓存，hosts，本地域名服务器</li><li>通过本地域名服务器访问根DNS服务器获得对应顶级DNS服务器的地址</li><li>通过本地域名服务器访问顶级DNS服务器获得对应权威DNS服务器的地址</li><li>通过本地域名服务器访问权威DNS服务器获得ip</li><li>本地域名服务器将ip返回给主机</li></ol><p><strong>http1.1和http2</strong></p><p>HTTP&#x2F;1.1和HTTP&#x2F;2是两个不同的HTTP协议版本，下面是它们之间的一些主要差别：</p><ol><li><strong>多路复用</strong>：HTTP&#x2F;1.1协议使用串行化的方式在一个TCP连接上依次传输多个HTTP请求和响应，这样会产生一些性能瓶颈。而HTTP&#x2F;2协议则使用多路复用的方式，通过<strong>在同一个TCP连接上并行传输多个HTTP请求和响应</strong>，提高了性能和效率。</li><li><strong>头部压缩</strong>：HTTP&#x2F;1.1协议的请求和响应头部信息没有压缩，这样会占用较多的带宽和网络资源。而HTTP&#x2F;2协议引入了头部压缩机制，可以有效地减少网络传输的数据量，提高性能和效率。</li><li><strong>服务器推送</strong>：HTTP&#x2F;1.1协议需要客户端发起每个请求，服务器无法主动推送内容给客户端。而HTTP&#x2F;2协议允许服务器<strong>在客户端请求之前主动推送内容给客户端</strong>，可以减少客户端请求的次数和提高性能。</li><li><strong>流量控制</strong>：HTTP&#x2F;2协议引入了流量控制机制，可以对每个流进行流量控制，避免网络拥塞和资源竞争。而HTTP&#x2F;1.1协议没有流量控制机制，容易导致网络拥塞和性能瓶颈。</li><li><strong>请求优先级</strong>：HTTP&#x2F;2协议允许客户端设置请求的优先级，可以确保高优先级的请求优先得到响应，提高性能和效率。而HTTP&#x2F;1.1协议没有请求优先级机制，容易导致低优先级的请求得不到及时响应。</li></ol><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><strong>什么情况下建立索引</strong></p><ol><li>频繁使用的列：对于经常用于 WHERE 子句或 JOIN 子句中的列，可以考虑创建索引，以便更快地查询这些数据。</li><li>唯一性约束：对于需要唯一性约束的列，例如主键或唯一索引，需要创建索引来确保数据的唯一性。</li><li>外键约束：对于外键约束，也需要在相关的列上创建索引以提高查询性能。</li><li>多表连接：当进行多表连接时，可以在涉及到的列上创建索引，以提高查询性能。</li><li>经常使用的排序列：对于经常用于排序操作的列，可以创建索引，以提高排序的性能</li></ol><p><strong>MySQL 存储引擎有哪些</strong></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><strong>protobuf，它和 JSON 的区别是什么，为什么使用它</strong></p><ol><li>性能：由于 Protobuf 的大小和速度优势，它非常适合在网络上发送大量数据的情况。例如，如果您正在构建一个需要大量数据传输的分布式系统，那么 Protobuf 可能比 JSON 更好。</li><li>类型定义：Protobuf 的类型定义可以强制执行消息格式的正确性，这可以帮助您在发送和接收消息时避免错误。</li><li>兼容性：Protobuf 具有跨平台兼容性，并且提供了各种语言的支持库。因此，如果您正在构建一个需要跨多种编程语言进行通信的系统，那么 Protobuf 可能比 JSON 更好。</li><li>可扩展性：由于 Protobuf 可以定义任意数量的字段和消息类型，因此它非常适合在以后需要添加或更改消息格式的情况下使用。与 JSON 相比，Protobuf 更易于维护和扩展。</li></ol><p><strong>RPC 协议和 HTTP 协议的区别和特点</strong></p><p>RPC（Remote Procedure Call，远程过程调用）协议和 HTTP（Hypertext Transfer Protocol，超文本传输协议）协议是两种不同的网络通信协议，它们的区别和特点如下：</p><ol><li>通信方式</li></ol><p>RPC 协议和 HTTP 协议的通信方式不同。<strong>RPC 协议是基于函数调用的方式进行通信的</strong>，<strong>客户端通过调用远程服务端暴露的 API 接口</strong>，实现远程过程调用。<strong>HTTP 协议则是基于请求-响应的方式进行通信的</strong>，客户端通过向服务器发送 HTTP 请求，并接收服务器返回的 HTTP 响应来进行通信。</p><ol start="2"><li>传输协议</li></ol><p>RPC 协议和 HTTP 协议使用的传输协议也不同。<strong>RPC 协议通常使用二进制协议</strong>进行传输，如 Protobuf、Thrift 等，以提高传输效率和可靠性。而 <strong>HTTP 协议则通常使用文本协议进行传输</strong>，如 JSON、XML 等。在一些特殊情况下，也可以使用二进制协议，如 HTTP&#x2F;2 协议中的二进制帧。</p><ol start="3"><li>请求方式</li></ol><p>RPC 协议和 HTTP 协议的请求方式也不同。<strong>RPC 协议通常使用不同的 RPC 方法来表示不同的请求类型</strong>，如 gRPC 中使用的 RPC 方法名。而 <strong>HTTP 协议则使用不同的 HTTP 方法来表示不同的请求类型</strong>，如 GET、POST、PUT、DELETE 等。</p><ol start="4"><li>性能和效率</li></ol><p>RPC 协议和 HTTP 协议在性能和效率上也有一定的区别。由于 RPC 协议使用二进制协议进行传输，相对于 HTTP 协议使用文本协议进行传输，它<strong>在传输效率和带宽利用率上具有优势</strong>。同时，RPC 协议也<strong>更加灵活和高效</strong>，可以根据不同的应用场景进行优化。然而，HTTP 协议作为一种通用协议，在跨平台、跨语言、跨网络等方面具有优势。</p><ol start="5"><li>应用场景</li></ol><p>RPC 协议和 HTTP 协议适用于不同的应用场景。<strong>RPC 协议通常用于高性能、大规模分布式系统的通信</strong>，如微服务架构、数据中心内部通信等。而 <strong>HTTP 协议则更适用于 Web 应用和客户端-服务器模式的通信</strong>，如浏览器和服务器之间的通信、RESTful API 等。</p><p>总之，RPC 协议和 HTTP 协议都有各自的优点和局限性，在实际应用中需要根据具体的应用场景和需求来选择适合的协议。</p><p><strong>浏览器较少支持grpc对http2原语的较低级别的访问，需要通过grpc-web做代理</strong></p><p><strong>GRPC通信流程</strong></p><p>gRPC 通信流程一般包括以下几个步骤：</p><ol><li>编写 <code>.proto</code> 文件定义服务接口：首先需要使用 Protocol Buffers 定义接口和消息格式，将接口定义保存在 <code>.proto</code> 文件中。</li><li>生成客户端和服务端代码：使用 Protocol Buffers 编译器 <code>protoc</code> 将 <code>.proto</code> 文件编译为客户端和服务端所需要的代码。</li><li>启动服务端：服务端通过监听指定的端口，等待客户端的连接请求。</li><li>客户端发起调用请求：客户端使用生成的 SDK 中提供的 stub 函数调用服务端提供的方法，并将请求参数传递给服务端。</li><li>服务端处理请求并返回响应：服务端接收到客户端的请求后，根据请求参数执行对应的逻辑，并将处理结果封装为响应对象返回给客户端。</li><li>客户端接收响应并处理：客户端接收到服务端的响应后，根据响应参数执行对应的逻辑，完成一次 RPC 调用。</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p><strong>单例模式</strong></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>B树</p><p>DFS</p><p>BFS</p><p>每个stl的初始化方法</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p><strong>线性一致，强一致，最终一致</strong></p><p><strong>强一致性</strong>要求分布式系统中的每个节点都保持同步，任何时刻都能够读取到最新的数据，并且每个节点读取到的数据都是相同的。换句话说，强一致性下，分布式系统中的所有节点都能够看到同样的数据，而且所有节点的数据都是最新的。这种一致性模型是最常见的一种，也是很多应用程序最基本的需求。</p><p><strong>线性一致性</strong>是强一致性的一种特殊形式。它要求系统中的所有节点必须按照相同的顺序读取写入操作，而且这个顺序必须是全局有序的，也就是说，所有操作的顺序都是唯一确定的。这种模型通常用于需要有序的多节点事务，如交易系统等</p><p>假设有一个分布式系统，里面有三个节点：节点A、节点B、节点C。现在有一个操作需要在这三个节点上执行，并且需要保证强一致或线性一致。</p><p>在强一致性模型下，这个操作必须在所有节点上同时执行，并且执行结果必须相同。例如，如果这个操作是将某个数据从0改成1，那么在所有节点上执行结束之后，这个数据必须在所有节点上都是1，否则操作失败。</p><p>在线性一致性模型下，这个操作可以在任意一个节点上执行，只要这个节点的执行结果被所有节点看到的时间都是一样的。例如，如果这个操作是将某个数据从0改成1，那么执行这个操作的节点可以是任意一个节点，只要在所有节点看到的时间上，这个数据从0改成1的时刻是一样的。这样可以保证所有节点最终看到的数据都是1，因此也保证了一致性。</p><p>总之，强一致性要求所有节点同时执行，而线性一致性只要求所有节点看到的结果是一样的，但是并不要求同时执行。</p><p><strong>最终一致性</strong>（eventual consistency）是分布式系统中一种弱一致性模型，它的基本思想是在分布式系统中的数据更新不需要实时同步，而是通过异步的方式在不同的节点之间复制和传播数据，最终达到一致的状态。</p><p>在最终一致性模型中，数据的更新是通过消息传递的方式在不同的节点之间进行的，不同节点之间的消息传递可能存在延迟，也可能存在网络分区（network partition）等问题，这些都可能导致节点之间的数据不一致。但是，最终一致性模型保证在一定时间内，所有节点最终会达到一致的状态。</p><p>举个例子，假设有一个分布式缓存系统，其中有两个节点A和B，它们都缓存了某个数据。当客户端请求获取数据时，它可以从节点A或节点B中获取数据，因为它们都缓存了这个数据。如果在某个时刻，节点A更新了这个数据，那么节点B上缓存的数据就过期了，但是由于节点之间可能存在延迟等问题，客户端有可能在一段时间内还是从节点B获取到了旧数据。但是，随着时间的推移，节点B最终会从节点A获取到最新的数据，然后更新自己的缓存，最终达到一致的状态。</p><p><strong>分布式准则</strong></p><p><strong>数据可靠性（Reliability）</strong></p><ul><li>复制技术（Replication）：将数据复制到多个不同节点</li><li>纠删码技术（Erasure Code）：通过校验数据来保证数据可靠性的技术</li></ul><p><strong>数据一致性（Consistency）</strong></p><p><strong>设备故障和容错（Fault Tolerance）</strong></p><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><p><strong>数据库索引失效</strong></p><p> 6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h3 id="工作项目"><a href="#工作项目" class="headerlink" title="工作项目"></a>工作项目</h3><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><p><strong>流程</strong></p><ol><li>指定发布版本运行回归</li><li>评估指标结果，对于基础指标如是否到达，是否碰撞需一一排查；其他指标优先级不高只做报警处理（因为随机性较大），若所有场景的某一指标都有异常变化则需要排查（震荡幅度，运行时间等）</li><li>记录反馈回归结果，与其他模块测试沟通，通过则发灰度版本；否则联系负责人修复</li></ol><p><strong>场景库</strong></p><p>覆盖基础场景和corner case。按场景细分为不同型号车辆，车道环境，障碍物，自车朝向；根据项目细分为绕障，借道等</p><p>来源手动构造，每周接管，数据挖掘抽取</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p><strong>流程</strong></p><ol><li>通过单帧或多帧运行场景，期间监控相关进程的资源占用</li><li>和历史值对比，查看是否合理，反馈问题或者调整阈值</li></ol><p><strong>监控项</strong></p><p>cpu_times：单位时间内CPU 在执行程序时所花费的时间，包括user，kernal，none</p><p>IO rchar&#x2F;wchar：io吞吐量</p><p>Physical&#x2F;Virtual Memory_peak：物理&#x2F;虚拟内存峰值</p><p>GPU_memory_used，GPU_util：显存占用，gpu使用率</p><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p><strong>流程</strong></p><ol><li>更新的优化点和风险点的理解与讨论</li><li>测试用例集的构建</li><li>评估指标的设计</li><li>具体算法问题追踪</li><li>上线流程的把握</li><li>上线后的更新点持续跟踪</li></ol><h3 id="RAFT项目"><a href="#RAFT项目" class="headerlink" title="RAFT项目"></a>RAFT项目</h3><h4 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h4><p><strong>raft通信流程</strong></p><p><strong>leader election</strong></p><h4 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h4><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h4 id="与Paxos对比"><a href="#与Paxos对比" class="headerlink" title="与Paxos对比"></a>与Paxos对比</h4>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（二）引用</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-面向对象编程（二）"><a href="#第五章-面向对象编程（二）" class="headerlink" title="第五章 面向对象编程（二）"></a>第五章 面向对象编程（二）</h2><h3 id="引用的其他用法"><a href="#引用的其他用法" class="headerlink" title="引用的其他用法"></a>引用的其他用法</h3><p>引用作为成员变量</p><p>函数返回引用，可以将返回值做左值</p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>通过类的其他对象初始化当前对象（有默认拷贝构造方法，成员对成员的拷贝，可能发生对象的嵌套拷贝）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//During call by value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">roster</span><span class="params">(Person)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function">Person <span class="title">child</span><span class="params">(<span class="string">&quot;Ruby&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">roster</span>(child); <span class="comment">// call copy ctors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// During initialization, call copy ctor</span></span><br><span class="line"><span class="function">Person <span class="title">baby_a</span><span class="params">(<span class="string">&quot;Fred&quot;</span>)</span></span>;</span><br><span class="line">Person baby_b = baby_a;</span><br><span class="line"><span class="function">Person <span class="title">baby_c</span><span class="params">(baby_a)</span></span>; <span class="comment">// same as above</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//During function return</span></span><br><span class="line"><span class="function">Person <span class="title">captain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">player</span><span class="params">(<span class="string">&quot;George&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T::T(const T&amp;)</p><p>建议每个类提供默认构造函数，拷贝构造函数，虚函数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>private针对类而非对象，可访问另一对象中的private成员</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>定义：存在于某作用域的一块内存空间，在函数本体内声明的任何变量，其使用的内存都取自于栈。在作用域结束后自动清理</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>定义：操作系统提供的一块全局内存空间，程序可动态分配从中获得若干区块。其生命在做犹豫结束后仍然存在，直到整个程序结束</p><p>包含：</p><ul><li>static local objects</li><li>global objects</li><li>heap objects（new）</li></ul><h4 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h4><p>new先分配内存后调用构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Complex* pc = new Complex(1,2);</span></span><br><span class="line"><span class="comment">//for complier, it transform to follow be like</span></span><br><span class="line">Complex *pc;</span><br><span class="line"><span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Complex));<span class="comment">//call malloc to allocate memory</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex *&gt;(mem); <span class="comment">//cast</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//call ctor</span></span><br></pre></td></tr></table></figure><p>delete先调用析构函数后释放内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//delete pc</span></span><br><span class="line"><span class="comment">//for complier, it transform to follow be like</span></span><br><span class="line">Complex::~<span class="built_in">Complex</span>(pc); <span class="comment">//call dtor</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>; <span class="comment">//call free(pc) to release memory</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（三）模版</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>模版函数（template function）为声明不是定义，在使用时根据输入类型定义</p><p>使用模版时，不会使用隐式类型转换</p><p>类模版里的每个函数都是函数模版，需要在声明前加上<code>template</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  BTnode&lt;elemType&gt; *_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（二）字符串、向量和数组</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="标准库类型String"><a href="#标准库类型String" class="headerlink" title="标准库类型String"></a>标准库类型String</h3><p>读写string对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;   <span class="comment">//from empty to empty</span></span><br><span class="line"><span class="built_in">getline</span>(cin,s); <span class="comment">//one line, stop by ENTER</span></span><br></pre></td></tr></table></figure><p>当把string对象和字符（串）字面值混在一条语句时，必须确保加法运算符（+）两侧的运算对象至少一个是string</p><h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h3><p>vector是模板而非类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line">vector&lt;T&gt; v3 = v1; <span class="comment">//same to above</span></span><br><span class="line">vector&lt;T&gt; v4&#123;a,b,c,...&#125;;</span><br><span class="line">vector&lt;T&gt; v5 = &#123;a,b,c,...&#125;; <span class="comment">//same to above</span></span><br></pre></td></tr></table></figure><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>理解复杂的数组声明（P102-103）</p><p>从变量名开始由内往外看，即变量名-数组-变量类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">//含有10个整型指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*parrary)[<span class="number">10</span>] = &amp;arr; <span class="comment">//指向一个含有10个整数的数组的指针</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrREF)[<span class="number">10</span>] = arr; <span class="comment">//引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//引用一个含有10个整型指针的数组</span></span><br></pre></td></tr></table></figure><p>指向一个数组的指针+1后指向数组尾部的下一个地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">int</span>(*a)[<span class="number">2</span>] = &amp;arr;</span><br><span class="line"><span class="type">int</span> *b = arr;</span><br><span class="line">cout &lt;&lt; arr &lt;&lt; endl; <span class="comment">//0x61fe08</span></span><br><span class="line">cout &lt;&lt; arr + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe0c</span></span><br><span class="line">cout &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe10 = 0x61fe08 + (4*2)D</span></span><br><span class="line">cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe0c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（五）自增的问题</title>
      <link href="/2025/01/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/01/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>后置递增运算符的优先级高于解引用运算符，因此<code>*p++</code>等同于<code>*（p++）</code></p><p>将p+1后返回p的初始值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（一）基础知识</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-面向对象编程"><a href="#第五章-面向对象编程" class="headerlink" title="第五章 面向对象编程"></a>第五章 面向对象编程</h2><p>类不是实体，对象是实体</p><p>成员变量（filed）属于对象</p><p>成员函数（member function）属于类</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>列表初始化（initialize list）</strong>仅对成员变量初始化。</p><p>在构造函数里对成员变量初始化则为先初始化（默认）后赋值，故所有成员变量必须要有默认的初始化方法（成员变量包含其他类但该类没有默认构造函数则会报错）。构造函数无法主动调用。</p><p>尽量使用列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">a</span>(i)&#123;&#125;;  <span class="comment">//initialize list</span></span><br><span class="line">  <span class="comment">// A(int i):&#123;a=i;&#125; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造和拷贝赋值"><a href="#拷贝构造和拷贝赋值" class="headerlink" title="拷贝构造和拷贝赋值"></a>拷贝构造和拷贝赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">ptr</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        ptr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> <span class="type">char</span> *c_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(c_ptr) + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            ptr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test(const char *c_ptr)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;test)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, test.ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test(Test &amp;test)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test) <span class="comment">//1.prevent meaningless copy 2.because will delete later, prevent error test.ptr</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, test.ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call copy operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test; <span class="comment">//initialzation,call Test()</span></span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>; <span class="comment">//initialzation,call Test(const char *c_ptr)</span></span><br><span class="line">    Test test2 = test1; <span class="comment">//initialzation,call Test(Test &amp;test)</span></span><br><span class="line">    <span class="function">Test <span class="title">test3</span><span class="params">(test1)</span></span>; <span class="comment">//initialzation,call Test(Test &amp;test)</span></span><br><span class="line">    test3 = test2; <span class="comment">//assignment,call copy operator=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>访问属性</p><table><thead><tr><th>访问限制符\访问位置</th><th>当前类</th><th>子类</th><th align="center">类外</th></tr></thead><tbody><tr><td>public</td><td>可以</td><td>可以</td><td align="center">可以</td></tr><tr><td>protected</td><td>可以</td><td>可以</td><td align="center">不可以</td></tr><tr><td>private</td><td>可以</td><td>不可以</td><td align="center">不可以</td></tr></tbody></table><p>若子类中含有与父类同名函数（函数名相同，参数列表个数和类型），父类的函数会被隐藏。（仅C++如此）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a):<span class="built_in">i</span>(a)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::print()&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::print(int i)&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> a):<span class="built_in">A</span>(a)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::print()&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">2</span>); <span class="comment">//ERROR, cant found print(int a) in A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般来说，最好在类定义开始货结束前的集中位置声明友元</p><p>友元的声明只指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么就必须在友元声明外再专门对函数进行一次声明</p><p>相同类的对象互为友元</p><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>向上造型（upcasting）指将派生类的引用或指针转化为父类的引用或指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_print</span><span class="params">(Base &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base test;</span><br><span class="line">Derived test2;</span><br><span class="line"><span class="built_in">test_print</span>(test2);  <span class="comment">//Base print</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚函数：使派生类各自定义适合自己版本的函数，当使用基类的引用（或指针）调用一个虚函数时将发生动态绑定（父类加上virtual即生效，但最好子父类都加上virtual）</p><p>静态绑定：编译时确定调用的函数</p><p>动态绑定：运行时确定调用的函数</p><img src="/../../images/vtable.png" style="zoom:30%;" /><p>如果派生类没有覆盖基类的虚函数，则派生类会直接继承基类中的版本</p><p>对象增加vptr，指向当前对象的类的vtable（属于类，保存存储虚函数的地址）</p><p>虚函数运行方式为访问vptr—访问vtable—访问函数指针—访问函数</p><p>如果有一个虚函数，则需将析构函数设为虚函数，以处理新增变量</p><p>C++默认静态绑定</p><p>派生类虚函数的形参类型个数，返回值类型必须和基类一致，否则为重载（除非返回类型时类本身的指针或引用）</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（四）inline函数</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="inline-函数"><a href="#inline-函数" class="headerlink" title="inline 函数"></a>inline 函数</h3><p>将函数声明为inline可以避免函数调用的开销，空间换时间</p><p>调用函数步骤：</p><ol><li>返回地址压栈</li><li>函数参数压栈</li><li>计算返回值</li><li>函数部分所有元素出栈，返回值</li></ol><img src="/../../images/assembly code.png" width=500px /><p>普通函数与inline函数的汇编代码对比</p><img src="/../../images/inline.png" width=500px /><p><strong>inline函数不是定义是声明，应该写在头文件里，保证编译器将其作为inline函数展开</strong></p><p>宏定义与inline函数的区别</p><table><thead><tr><th></th><th>宏定义</th><th>inline函数</th></tr></thead><tbody><tr><td>类型检查</td><td>无</td><td>有</td></tr><tr><td>实现方式</td><td>预处理时展开</td><td>由编译器实现展开，是否将函数作为inline依赖于编译器的判断</td></tr><tr><td>其他</td><td>容易引发运算符优先级的问题，不可调试</td><td>可以调试</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL基础</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/</url>
      
        <content type="html"><![CDATA[<h3 id="六大部件"><a href="#六大部件" class="headerlink" title="六大部件"></a>六大部件</h3><img src="/../../images/stl_items.png" alt="stl_items.png" style="zoom:60%;" /><p>分配器：为容器分配内存</p><p>迭代器：算法只能通过迭代器访问容器</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><img src="/../../images/stl.png" alt="stl.png" style="zoom:60%;" /><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h4><p>_M_instance：指向数组首元素的指针（int a[10]的a）</p><img src="/../../images/array_overview.png" alt="array_overview.png" style="zoom:60%;" /><p><strong>iterator为指针，traits通过指针特化处理</strong></p><img src="/../../images/array.png" alt="array.png" style="zoom:60%;" /><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><p>start（4B）：指向第一个元素的指针</p><p>finish（4B）：指向最后一个元素的下一个指针</p><p>end_of_storage（4B）：容器申请的内存空间的最后一个元素的下一个地址</p><p>若内存空间不够则申请当前空间两倍的空间</p><img src="/../../images/vector_overview.png" alt="vector_overview.png" style="zoom:60%;" /><p><strong>iterator为指针，traits通过指针特化处理</strong></p><img src="/../../images/vector_iterator.png" alt="vector_iterator.png" style="zoom:60%;" /><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>node（4B）：指向头节点的指针</p><img src="/../../images/list_overview.png" alt="list_overview.png" style="zoom:60%;" /><p><strong>iterator里的node为指向当前节点的指针</strong></p><img src="/../../images/list_iterator.png" alt="list_iterator.png" style="zoom:60%;" /><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward List"></a>Forward List</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><img src="/../../images/forward_list.png" alt="forward_list.png" style="zoom:60%;" /><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>queue在内存中每个buffer块离散存储，通过map表记录各buffer块的地址</p><p>start（16B）：指向首元素的iterator</p><p>finish（16B）：指向尾巴元素下一个块的iterator</p><p>map（4B）：指向map首元素的指针</p><p>map_size：map占用内存的大小</p><img src="/../../images/deque_overview.png" alt="deque_overview.png" style="zoom:60%;" /><p>cur：指向当前元素的指针</p><p>first：指向当前buffer块首元素的指针</p><p>last：指向当前buffer块尾元素下一个块的指针</p><p>node：指向map对应元素的指针</p><img src="/../../images/deque_iterator.png" alt="deque_iterator.png" style="zoom:60%;" /><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>不允许遍历也不提供iterator</p><p>可选择list或deque作为底层存储</p><p>不可选择vector作为底层存储</p><img src="/../../images/queue.png" alt="queue.png" style="zoom:60%;" /><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>不允许遍历也不提供iterator</p><p>可选择list或deque或vector作为底层存储</p><img src="/../../images/stack.png" alt="stack.png" style="zoom:60%;" /><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>t：红黑树</p><img src="/../../images/set.png" alt="set.png" style="zoom:60%;" /><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="键值对集合"><a href="#键值对集合" class="headerlink" title="键值对集合"></a>键值对集合</h4><p>t：红黑树</p><img src="/../../images/map.png" alt="map.png" style="zoom:60%;" /><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的</p><h3 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h3><h3 id="Iterator-Traits"><a href="#Iterator-Traits" class="headerlink" title="Iterator Traits"></a>Iterator Traits</h3><p>由于算法需要得到iterator的某些属性，对于非指针iterator的结构包含属性，但对于指针类型无法获取。通过iterator traits对于iterator处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（一）运算符重载</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><p>只能重载存在的运算法</p><p>重载运算符必须保留相同操作数数量和优先级</p><h3 id="成员或全局函数"><a href="#成员或全局函数" class="headerlink" title="成员或全局函数"></a>成员或全局函数</h3><p>单目运算符应该做成成员函数</p><p><code>= （） []</code>只能做成成员函数</p><p>所有其他二元运算符做成非成员函数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>成员函数左操作数（reciver）必须是隶属于同一个class的对象</p><p>加const可以防止返回结果做左值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（一）CPP编译过程、宏以及头文件</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<ol><li><p><code>endl</code>将与设备关联的<strong>缓冲区（buffer）</strong>中的内容刷到设备中。在调试时应保证”一直”刷新流。否则若程序崩溃，输出可能还是缓冲区，导致对于程序崩溃位置的错误推断</p></li><li><p>读取数量不定的输入数据可用<code>while (std::in &gt;&gt; value)</code></p><p>当遇到<strong>文件结束符（end-of-file）</strong>，或遇到一个无效输入时，<em>istream</em>对象状态变为无效，使条件为假</p><p>EOF：在Windows中为<code>Ctrl+Z</code>，UNIX为<code>Ctrl+D</code></p></li></ol><h3 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++编译过程"></a>C++编译过程</h3><ol><li><p>预处理（Preprocessing）</p><p>将所有的#include<strong>头文件以及宏定义替换成其真正的内容</strong>，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是<strong>预处理器cpp来完成的</strong>。（include只做文本插入，在include的位置将头文件展开）</p></li><li><p>编译（Compilation）</p><p>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定<strong>汇编代码（assembly code）</strong>的过程。</p><p>一个cpp文件是一个编译单元。</p></li><li><p>汇编（Assemble）</p><p>汇编过程将上一步的汇编代码转换成<strong>机器码（machine code）</strong>，这一步产生的文件叫做目标文件，是二进制格式。</p><p><strong>这一步会为每一个源文件产生一个目标文件</strong>。</p></li><li><p>链接（Linking）</p><p>链接过程将<strong>多个目标文以及所需的库文件（.so等）链接</strong>成最终的<strong>可执行文件（executable file）</strong></p></li></ol><p><img src="/../../images/compiler.png" alt="compiler"></p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>预处理阶段将宏所写内容替换</p><p>宏没有类型检查</p><p>在宏外加括号防止运算符优先级错误</p><p>在宏后不需要加分号（非C++语句）</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>把函数原型放到头文件中，在需要调用这个函数的源代码文件中include到这个头文件，能让编译器在编译时知道函数的原型，以确保函数类型的统一</p><p>头文件里存放声明（extren变量，函数原型，类或结构体的定义），cpp文件里存放定义</p><img src="/../../images/header and cpp.png" width=500px/><p>头文件的标准格式</p><p>用宏定义防止：</p><ol><li>两个头文件相互include时的循环include</li><li>cpp在include不同头文件时可能产生的重复定义（class不能重复定义）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _MY_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _MY_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/01/03/C++questions/"/>
      <url>/2025/01/03/C++questions/</url>
      
        <content type="html"><![CDATA[<h2 id="C-疑惑点"><a href="#C-疑惑点" class="headerlink" title="C++疑惑点"></a>C++疑惑点</h2><h3 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h3><ol><li>header中防御式声明的目的</li></ol><ul><li>防止两个头文件相互include时的循环include</li><li>防止cpp在include不同头文件时可能产生的重复定义</li></ul><ol start="2"><li>inline</li></ol><p>将函数声明为inline可以避免函数调用的开销，空间换时间</p><p>常规的函数调用需要用到栈，需要返回地址和参数压栈，但通过inline展开后就为普通的顺序执行</p><p><strong>与define的区别</strong>：</p><ul><li>define无类型检查，inline有</li><li>define编写时运算符的优先级较难处理</li><li>define在预处理时展开，inline由编译器实现展开</li></ul><ol start="2"><li>const</li></ol><p>const对象的<strong>值创建后值不能再改变</strong>，所以必须初始化</p><p>对于<strong>const指针</strong>，分为：</p><ul><li>底层const：<code>int* const p = &amp;a</code>无法改变p的指向</li><li>顶层const：<code>const int* p = &amp;a</code>无法通过p改变a的值</li></ul><p>对于<strong>const引用</strong>，其原来就不能改变引用的变量，所以只有底层const<code>const int&amp; a = 1</code></p><p>顶层const<strong>拷贝</strong>不受限制</p><p>底层const拷贝时，右值必须为非常量或者为底层const变量</p><p>对于<strong>const成员函数</strong>，无法改变成员变量的值</p><ol start="2"><li>Static</li></ol><ul><li><p>用于修饰变量：在函数内部，static 修饰的变量具有静态存储期，意味着它们的生命周期与程序的生命周期相同，而不是与函数的调用次数相关。在全局或命名空间作用域中，static 修饰的变量具有内部链接，只能在当前文件或当前命名空间中访问。</p></li><li><p>用于修饰函数：在函数内部，static 修饰的函数具有内部链接，只能在当前文件中调用，不能被其他文件调用。</p></li><li><p>用于修饰类成员变量：在类中，static 修饰的成员变量是类共享的，即所有类对象共享同一份内存。这些变量可以被类的任何成员函数访问，甚至在没有类对象的情况下也可以访问。需要注意的是，静态成员变量必须在类外进行定义和初始化。</p></li><li><p>用于修饰类成员函数：在类中，static 修饰的成员函数是类相关的，而不是对象相关的。这意味着它们不需要通过类对象来调用，可以直接通过类名来调用。</p></li></ul><ol start="2"><li>调用构造函数和析构函数，内存的影响</li><li>内存对齐</li></ol><p>分配内存时，按照一些规则对内存地址调整，不使用一些内存，通过空间换时间，优化访存效率</p><p>对于基础数据类型，按照4，8，16B等对齐</p><p>对于结构体和类，按照最宽基本数据类型为对齐单元</p><p>可以通过<code>sizeof()</code>查看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标签测试文章</title>
      <link href="/2025/01/02/index/"/>
      <url>/2025/01/02/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> Another Tag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/02/hello-world/"/>
      <url>/2025/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
