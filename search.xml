<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统（二）进程管理（进程同步与死锁）</title>
      <link href="/2025/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%89/"/>
      <url>/2025/02/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU调度策略"><a href="#CPU调度策略" class="headerlink" title="CPU调度策略"></a>CPU调度策略</h3><h4 id="任务调度策略的三个基本准则"><a href="#任务调度策略的三个基本准则" class="headerlink" title="任务调度策略的三个基本准则"></a>任务调度策略的三个基本准则</h4><ul><li>任务周转时间：从新建到完成的时间</li><li>任务响应时间：从提交请求到首次响应的时间（前台任务关心）</li><li>系统吞吐量：一段时间内系统能完成的任务数</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ol><li><p>先来先服务</p></li><li><p>最短作业优先调度：不可抢占，平均周转时间短（作业运行时间只能近似给出）</p></li><li><p>最短剩余时间有限：最短作业优先的可抢占版本</p></li><li><p>时间片轮转调度：保证响应时间</p><p><strong>时间片设得太短</strong>会导致过多的进程切换，<strong>降低了CPU效率</strong>；<strong>设得太长</strong>会引起<strong>对短作业的交互请求的响应时间变长</strong></p></li></ol><img src="/../../images/rr.png" align='middle' width=700px/><ol start="5"><li><p>多级反馈队列调度：动态调整任务类型（近期多IO可能为前台任务，无IO时间片结束未完成可能为后台大任务）</p><p>运行流程</p><ol><li>设置<strong>多级就绪队列</strong>，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时<strong>先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。 若用完时间片进程还未结束，则进程<strong>进入下一级队列队尾</strong>。如果此时已经是在最下级的队列，则重新放回最下级队列队尾</li><li>只有第k级队列为空时，才会<strong>为k+1级队头的进程分配时间片</strong></li></ol></li></ol><h4 id="调度算法比较"><a href="#调度算法比较" class="headerlink" title="调度算法比较"></a>调度算法比较</h4><img src="/../../images/process_control.png" align='middle' width=700px/><img src="/../../images/process_control_2.png" align='middle' width=700px/><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol><li>IO占比越大，任务优先级越高</li></ol><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><h5 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h5><p><strong>软件实现</strong></p><p>Peterson算法：访问临界区前判断其他进程是否要用，要用则循环等待；等其他进程使用完后访问临界区</p><p><strong>硬件实现</strong></p><ol><li>开关中断：只适用于单处理机，可以使得一个处理机内任务不中断。如果多处理机要实现互斥需要总线支持</li><li>TestAndSet</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKED 1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Critical</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (TestAndSet(&amp;lock) == <span class="number">1</span>);</span><br><span class="line">     critical section <span class="comment">// only one process can be in this section at a time</span></span><br><span class="line">     lock = <span class="number">0</span> <span class="comment">// release lock when finished with the critical section</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">int</span> TestAndSet(<span class="type">int</span>* lockPtr) &#123;</span><br><span class="line">    <span class="type">int</span> oldValue;</span><br><span class="line">    oldValue = *lockPtr;</span><br><span class="line">    *lockPtr = LOCKED; <span class="comment">//不管原来有没有上锁，先加锁</span></span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">//返回本来是否上锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>记录型信号量支持让权等待（while判断循环的都不是让权等待）</p><p>退出临界区的进程负责唤醒阻塞态进程（区别于while判断循环的自发进入临界区）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> value; <span class="comment">// value of block_process or free resource</span></span><br><span class="line">  PCB *<span class="built_in">queue</span>; <span class="comment">// process queue wait on sem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">  s.value--;</span><br><span class="line">  <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)</span><br><span class="line">  sleep_on(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">  s.value++;</span><br><span class="line">  <span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>) <span class="comment">// release one wake_up one(唤醒阻塞队列的队头任务)</span></span><br><span class="line">  wake_up(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者&#x2F;消费者模型"></a>生产者&#x2F;消费者模型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use semaphore</span></span><br><span class="line">semaphore empty = BUFFER_SIZE; <span class="comment">// count of empty size</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">// count of resource in space</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// prevent change to space</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  P(empty); <span class="comment">//确保有空间</span></span><br><span class="line">  P(mutex);</span><br><span class="line">  buffer[in] = item;</span><br><span class="line">  in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  P(full); <span class="comment">//确保有东西</span></span><br><span class="line">  P(mutex);</span><br><span class="line">  item = buffer[out];</span><br><span class="line">  out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读者-写者模型"><a href="#读者-写者模型" class="headerlink" title="读者&#x2F;写者模型"></a>读者&#x2F;写者模型</h4><h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><img src="/../../images/reader_writer.png" align='middle' width=700px/><h5 id="读写公平"><a href="#读写公平" class="headerlink" title="读写公平"></a>读写公平</h5><img src="/../../images/reader_writer_2.png" align='middle' width=700px/><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>各哲学家互斥得拿筷子，即同一时间至多有一个哲学家拿筷子阻塞</p><img src="/../../images/eat.png" align='middle' width=700px/><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的四个<strong>必要条件</strong></p><ul><li>互斥：资源不能被共享，一个资源每次只能被一个进程使用</li><li>不可剥夺：进程已获得的资源，在未使用完之前，不能强行剥夺</li><li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>循环等待：若干进程之间形成一种头尾相接的循环性资源等待关系</li></ul><h4 id="死锁预防（不会发生死锁）"><a href="#死锁预防（不会发生死锁）" class="headerlink" title="死锁预防（不会发生死锁）"></a>死锁预防（不会发生死锁）</h4><p>破坏“请求与保持”：一次性申请进程所需的所有资源</p><p>破坏“循环等待”：资源按顺序申请（其实达不到，没法预测程序走的分支）</p><p>缺点：</p><ul><li>需要预先计算程序要请求的资源</li><li>可能很久以后才使用的资源早早地预留下来，造成资源的浪费</li></ul><h4 id="死锁避免（拒绝某些资源请求）"><a href="#死锁避免（拒绝某些资源请求）" class="headerlink" title="死锁避免（拒绝某些资源请求）"></a>死锁避免（拒绝某些资源请求）</h4><p>每次申请资源都要判断是否出现死锁的危险，如果有危险就拒绝这次请求</p><p>通过<strong>银行家算法</strong>计算安全序列，充分性算法，<strong>完全避免死锁</strong></p><p>算法优先分配给能满足进程所需最大资源量的进程，一次分配所有所需要的所有资源</p><p>缺点：</p><ul><li>每次资源请求发生就要计算，且时间复杂度不小（时间复杂度O(mn^2)，m为资源种类，n为进程数）</li><li>需要已知进程执行完成所需的资源总数</li></ul><p><strong>银行家算法（‼️）</strong></p><ol><li>判断请求是否小于所需资源</li><li>判断请求是否小于当前系统资源量</li><li>尝试分配，判断能否找出安全序列</li><li>若能找到则分配，若不能找到则不分配</li></ol><p><strong>求安全序列</strong></p><p>最大资源组A，已分配组B，还需资源组C（C&#x3D;A-B）</p><p>系统资源组P</p><ol><li>查看<strong>还需 资源A 小于等于 系统资源P 的进程</strong></li><li>一次分配后，将已分配的资源回收，<strong>更新系统P</strong></li><li>返回1，若所有进程都能分配，则存在安全序列（不唯一）</li></ol><p>备注：</p><ol><li>存在安全序列 -》无死锁进程</li><li>不存在安全序列不一定发生死锁（依赖于请求资源的序列）</li></ol><p><strong>不发生死锁的最小资源量</strong></p><p>每个所需资源都-1后累加，再加一（每个所需资源都-1为请求与保持的最坏情况，+1即可确保分配不发生死锁）</p><img src="/../../images/banker.png" align='middle' width=700px/><h4 id="死锁检测-恢复（排查因资源导致的阻塞进程）"><a href="#死锁检测-恢复（排查因资源导致的阻塞进程）" class="headerlink" title="死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）"></a>死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）</h4><p>检测发生死锁的进程（资源未被使用，进程长时间未调度等），恢复进程并重新分配资源（<strong>改进的银行家算法</strong>）</p><p>改进的银行家算法分配每次进程请求的资源，而不是分配所需的所有资源，因为有事进程对于资源使用后就会释放，这样系统有更多余量</p><p>缺点：</p><ul><li>回滚的处理问题</li></ul><h4 id="死锁忽略（大部分PC机操作系统）"><a href="#死锁忽略（大部分PC机操作系统）" class="headerlink" title="死锁忽略（大部分PC机操作系统）"></a>死锁忽略（大部分PC机操作系统）</h4><p>不进行死锁处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（八）其他</title>
      <link href="/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%85%AB%EF%BC%89%E5%85%B6%E4%BB%96/"/>
      <url>/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%85%AB%EF%BC%89%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h2 id="视图（view）"><a href="#视图（view）" class="headerlink" title="视图（view）"></a>视图（view）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在MySQL中，视图是一种虚拟表，它是由一个或多个基本表的行或列组成的。<strong>视图并不实际存储数据，而是根据定义的 select 语句动态生成结果集</strong>。视图可以简化复杂的查询操作，提高查询效率，同时也可以保护数据的安全性，隐藏敏感数据。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>执行过程类似于 select 语句，流程如下</p><ol><li><strong>视图展开（预处理器）</strong>：将视图名转化为 select 语句</li><li><strong>查询优化（优化器）</strong>：选择使用索引或者连接算法优化查询效率</li><li><strong>执行查询（执行器，存储引擎）</strong>：生成优化后的执行计划后，数据库的 存储引擎会根据这个计划执行查询。执行过程中，MySQL 会从底层表中读取数据，并按需执行连接、过滤、排序等操作，最终返回查询结果</li></ol><h2 id="连接（join）"><a href="#连接（join）" class="headerlink" title="连接（join）"></a>连接（join）</h2><h3 id="简单嵌套循环连接"><a href="#简单嵌套循环连接" class="headerlink" title="简单嵌套循环连接"></a>简单嵌套循环连接</h3><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>对于左表的每一条记录，扫描右表的所有记录，找到匹配的记录</p><img src="/../../images/naive_nested_loop_join.png" style="zoom:40%;" /><h3 id="块嵌套循环连接"><a href="#块嵌套循环连接" class="headerlink" title="块嵌套循环连接"></a>块嵌套循环连接</h3><h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p>将左表和右表分块，每次加载一块数据到内存中，进行连接操作</p><img src="/../../images/block_nested_loop_join.png" style="zoom:40%;" /><h3 id="索引嵌套循环连接"><a href="#索引嵌套循环连接" class="headerlink" title="索引嵌套循环连接"></a>索引嵌套循环连接</h3><h4 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h4><p>对于左表的每一条记录，通过右表的索引快速查找匹配的记录</p><img src="/../../images/index_nested_loop_join.png" style="zoom:40%;" /><h3 id="归并连接"><a href="#归并连接" class="headerlink" title="归并连接"></a>归并连接</h3><h4 id="执行流程-3"><a href="#执行流程-3" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>对两个表按照join key排序</li><li>按序匹配两个表在join key上的值，筛选有效行</li></ol><img src="/../../images/sort_merge_join_1.png" style="zoom:40%;" /><img src="/../../images/sort_merge_join_2.png" style="zoom:40%;" /><h3 id="哈希连接"><a href="#哈希连接" class="headerlink" title="哈希连接"></a>哈希连接</h3><h4 id="执行流程-4"><a href="#执行流程-4" class="headerlink" title="执行流程"></a>执行流程</h4><p><strong>建表阶段（Bulid Phase）</strong></p><p>选择一个表（一般情况下是较小的那个表，以减少建立哈希表的时间和空间），对其中每个元组上的join key采用哈希函数得到哈希值，从而建立一个哈希表。</p><p><strong>探测阶段（Probe Phase）</strong></p><p>对另一个表，扫描它的每一行并计算连接属性的哈希值，与bulid phase建立的哈希表对比，若有落在同一个bucket的则连接成新的表。</p><img src="/../../images/simple_hash_join_algorithm.png" style="zoom:40%;" /><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th align="left"><strong>连接算法</strong></th><th align="left"><strong>实现方式</strong></th><th align="left"><strong>时间复杂度</strong></th><th align="left"><strong>优点</strong></th><th align="left"><strong>缺点</strong></th><th align="left"><strong>应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>简单嵌套连接</strong></td><td align="left">左表每条记录扫描右表所有记录</td><td align="left"><code>O(n * m)</code></td><td align="left">实现简单</td><td align="left">效率低</td><td align="left">小数据集</td></tr><tr><td align="left"><strong>块嵌套连接</strong></td><td align="left">分块加载数据，减少磁盘 I&#x2F;O</td><td align="left"><code>O(n * m)</code></td><td align="left">减少磁盘 I&#x2F;O</td><td align="left">效率较低</td><td align="left">大数据集且内存有限</td></tr><tr><td align="left"><strong>索引嵌套连接</strong></td><td align="left">左表每条记录通过右表索引查找匹配记录</td><td align="left"><code>O(n * log(m))</code></td><td align="left">利用索引快速查找</td><td align="left">依赖索引</td><td align="left">右表有索引的场景</td></tr><tr><td align="left"><strong>归并连接</strong></td><td align="left">对两个已排序的表进行扫描和匹配</td><td align="left"><code>O(n + m)</code></td><td align="left">高效，适合已排序的大数据集</td><td align="left">依赖排序</td><td align="left">已排序的大数据集</td></tr><tr><td align="left"><strong>哈希连接</strong></td><td align="left">构建哈希表，扫描探测表并查找匹配记录</td><td align="left"><code>O(n + m)</code></td><td align="left">效率高，适合大数据集</td><td align="left">需要足够内存</td><td align="left">大数据集的等值连接，内存充足场景</td></tr></tbody></table><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>要求数据库表的<strong>每一列都是不可分割的原子数据项</strong></p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>在1NF的基础上，<strong>非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</strong></p><p>也就是说不能出现候选码中的部分码能退出非主属性的情况</p><p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</p><p>举例说明：</p><img src="/../../images/nf_3.webp" style="zoom:0%;" /><p>在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，</p><p>但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，</p><p>这样就不满足第二范式的要求，调整如下，需分成两个表：</p><img src="/../../images/nf_4.webp" style="zoom:80%;" /><img src="/../../images/nf_5.webp" style="zoom:80%;" /><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>在2NF基础上，<strong>任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</strong></p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关</p><p>举例说明：</p><img src="/../../images/nf_6.webp" style="zoom:80%;" /><p>上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，</p><p>而不是主键“学号”，所以需做如下调整：</p><img src="/../../images/nf_7.webp" style="zoom:80%;" /><img src="/../../images/nf_8.webp" style="zoom:80%;" /><h3 id="BC范式（BCNF）"><a href="#BC范式（BCNF）" class="headerlink" title="BC范式（BCNF）"></a>BC范式（BCNF）</h3><p>在关系模式中<strong>每一个决定因素都包含候选键</strong>，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了<strong>任何属性（不光是非主属性，2NF和3NF所限制的都是非主属性）对候选码的传递依赖与部分依赖</strong>。</p><p>举例说明：</p><p>有一个学生导师表，其中包含字段：学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键</p><table><thead><tr><th>StudentId（P）</th><th>Major（P）</th><th>Advisor</th><th>MajGPA</th></tr></thead><tbody><tr><td>1</td><td>人工智能</td><td>Edward</td><td>4.0</td></tr><tr><td>2</td><td>大数据</td><td>William</td><td>3.8</td></tr><tr><td>1</td><td>大数据</td><td>William</td><td>3.7</td></tr><tr><td>3</td><td>大数据</td><td>Joseph</td><td>4.0</td></tr></tbody></table><p>这个表的设计满足三范式，有主键，不存在主键的部分依赖，不存在非主键的传递依赖。但是这里存在另一个依赖关系，“专业”函数依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。</p><p>所以这个表的部分主键依赖于非主键部分，那么我们可以进行以下的调整，拆分成2个表：</p><p>学生导师表：</p><table><thead><tr><th>StudentId（P）</th><th>Advisor</th><th>MajGPA</th></tr></thead><tbody><tr><td>1</td><td>Edward</td><td>4.0</td></tr><tr><td>2</td><td>William</td><td>3.8</td></tr><tr><td>1</td><td>William</td><td>3.7</td></tr><tr><td>3</td><td>Joseph</td><td>4.0</td></tr></tbody></table><p>导师表：</p><table><thead><tr><th>Advisor（P）</th><th>Major</th></tr></thead><tbody><tr><td>Edward</td><td>人工智能</td></tr><tr><td>William</td><td>大数据</td></tr><tr><td>Joseph</td><td>大数据</td></tr></tbody></table><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="LSM树"><a href="#LSM树" class="headerlink" title="LSM树"></a>LSM树</h3><h4 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM Tree"></a>LSM Tree</h4><p>在内存中维护一个Memtable并排序（AVL，红黑树等），当达到某一阈值后写入到磁盘，写入的结构称为SSTable</p><p>SSTable会定期进行压缩compaction，将重复的key以最新value压缩。由于数据量较大，所以通过数据大小对SStable分层</p><img src="/../../images/LSM_tree.png" style="zoom:40%;" /><p><strong>读：</strong> <strong>先访问内存的Memtable，若不存在则按序访问磁盘的各级SStable读取</strong>，由于SStable有序，可以通过范围判断是否在当前table，然后通过二分查找等方法查找</p><p><strong>写：</strong>直接增加到Memtable</p><p><strong>优化：</strong>布隆过滤器，通过哈希方法计算key是否存在，否表示肯定不存在，是表示可能存在</p><p><strong>优点：</strong>顺序写；写效率高</p><p><strong>缺点：</strong>读效率过低</p><h2 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h2><p>按照数据模型来分类的话，主要分为关系型数据库和非关系型数据库</p><ul><li>关系型数据库：基于关系模型组织数据的数据库，如MySQL、Oracle等。</li><li>非关系型数据库：不使用传统表格形式存储数据的数据库，如MongoDB、Redis（内存数据库）等。</li></ul><p>数据库是用于存储、管理和检索数据的系统，<strong>关系型数据库使用结构化查询语言（SQL）来管理数据，适用于需要保证数据一致性和完整性的场景</strong>；<strong>NoSQL数据库则更加灵活，适用于需要处理大量非结构化数据或需要高可伸缩性的场景</strong></p><h2 id="数据库三级模式结构"><a href="#数据库三级模式结构" class="headerlink" title="数据库三级模式结构"></a>数据库三级模式结构</h2><p>数据库系统的三级模式结构包括：</p><ol><li><strong>外模式（External Schema）</strong>：描述用户或应用程序看到的数据库视图。</li><li><strong>概念模式（Conceptual Schema）</strong>：描述整个数据库的逻辑结构和数据关系。</li><li><strong>内模式（Internal Schema）</strong>：描述数据库的物理存储结构和存储方式。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（七）缓存机制</title>
      <link href="/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%83%EF%BC%89%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%83%EF%BC%89%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要有缓存机制"><a href="#为什么要有缓存机制" class="headerlink" title="为什么要有缓存机制"></a>为什么要有缓存机制</h2><p> <strong>MySQL 的数据是存储在磁盘里的</strong>，但每次访问磁盘开销过大。为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，当数据从磁盘中取出后，缓存到Buffer Pool中，下次查询同样的数据的时候，直接从内存中读取，来提高数据库的读写性能。</p><img src="/../../images/buffer_pool_1.webp" style="zoom:50%;" /><p>除了数据的读取保存在缓存中，对数据的修改也不是立即写入磁盘，而是先写到缓存后择机刷盘。所以 Buffer Pool 中包含脏数据（数据页中）和 undo 页</p><img src="/../../images/buffer_pool_2.webp" style="zoom:50%;" /><h2 id="如何提高缓存命中率"><a href="#如何提高缓存命中率" class="headerlink" title="如何提高缓存命中率"></a>如何提高缓存命中率</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>使用<strong>LRU（Least recently used）算法</strong></p><p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p><p>简单的 LRU 算法的实现思路是这样的：</p><ul><li>当访问的页<strong>在 Buffer Pool 里</strong>，就直接把该页对应的 LRU 链表节点<strong>移动到链表的头部</strong></li><li>当访问的页<strong>不在 Buffer Pool 里</strong>，除了要把页<strong>放入到 LRU 链表的头部</strong>，还要<strong>淘汰 LRU 链表末尾的节点</strong></li></ul><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h4><p>MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO（局部性原理）</p><p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p><p>而且还会<strong>造成原本在LRU中的热点数据被预读后的不访问数据挤出链表，导致下次访问需要访问磁盘</strong></p><img src="/../../images/buffer_pool_3.webp" style="zoom:50%;" /><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong></p><p>MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p><p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域被young区淘汰的页面挤出，这样就不会影响 young 区域中的热点数据</p><img src="/../../images/buffer_pool_4.webp" style="zoom:50%;" /><h4 id="Buffer-Pool-污染"><a href="#Buffer-Pool-污染" class="headerlink" title="Buffer Pool 污染"></a>Buffer Pool 污染</h4><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p><ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li><li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li><li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li><li>如此往复，直到扫描完表中的所有记录。</li></ul><p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p><p>举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）</p><img src="/../../images/buffer_pool_5.webp" style="zoom:50%;" /><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>LRU 链表中 young 区域就是热点数据，只要<strong>提高进入到 young 区域的门槛</strong>，就能有效地保证 young 区域里的热点数据不会被替换掉。</p><p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p><p>在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（六）故障恢复</title>
      <link href="/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
      <url>/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库运行期间会发生哪些故障（问题）"><a href="#数据库运行期间会发生哪些故障（问题）" class="headerlink" title="数据库运行期间会发生哪些故障（问题）"></a>数据库运行期间会发生哪些故障（问题）</h2><h3 id="事务故障"><a href="#事务故障" class="headerlink" title="事务故障"></a>事务故障</h3><p>事务故障指<strong>事务未运行到既定的终点</strong>（没有commit或显式的rollback），例如对于支付系统若付款失败则<strong>需要回滚</strong>支付的操作，确保事务的一致性</p><h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><p>系统故障指<strong>需要即时重启系统而造成的数据库故障</strong>，现象是<strong>修改内存中的修改未写到磁盘，写入磁盘的数据未必是完成的事务</strong></p><h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><p>介质故障指<strong>磁盘损坏造成的故障</strong>，需要<strong>全量迁移数据库数据</strong></p><h2 id="MySQL日志（解决方案）"><a href="#MySQL日志（解决方案）" class="headerlink" title="MySQL日志（解决方案）"></a>MySQL日志（解决方案）</h2><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>undo log</code> 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以<strong>利用 undo log 来进行回滚</strong>。其<strong>记录的是修改前的值</strong></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>undo log确保事务的<strong>一致性</strong>，用以<strong>解决事务故障与系统故障</strong></p><h4 id="记录时机与内容"><a href="#记录时机与内容" class="headerlink" title="记录时机与内容"></a>记录时机与内容</h4><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p>（注：<strong>MySQL每个数据行都有一个隐藏的trx_id项</strong>，用以记录最新修改该行数据的事务id，undo log就是通过数据行获取trx_id的）</p><p>版本链如下图：</p><p>《img》</p><img src="/../../images/undo_log_11.webp" style="zoom:70%;" /><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>undo log 会<strong>先写入 Buffer Pool 中的 Undo 页面</strong>，之后再找合适的时机刷盘</p><h4 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a><strong>MVCC（多版本并发控制）</strong></h4><p>【该部分内容详见<a href="https://smartyue076.github.io/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8B%E5%8A%A1/">数据库事务</a>】</p><p><strong>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</strong>。</p><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><code>redo log</code> 记录的是<strong>数据修改后的值</strong>，用以<strong>在事务提交但数据未刷盘时对于已提交事务的重做</strong>。另外对于<strong>undo log的持久化</strong>也是通过redo log做的</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>redo log确保事务的<strong>持久性</strong>，用以<strong>解决系统故障</strong></p><h4 id="记录时机与内容-1"><a href="#记录时机与内容-1" class="headerlink" title="记录时机与内容"></a>记录时机与内容</h4><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘</p><img src="/../../images/redo_log_11.webp" style="zoom:60%;" /><h4 id="缓存机制-1"><a href="#缓存机制-1" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer。</p><p>redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。</p><img src="/../../images/redo_log_12.webp" style="zoom:30%;" /><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><strong>Binlog</strong>是 MySQL <strong>Server 层</strong>的日志，它记录了 <strong>所有涉及数据库修改的语句（DML 和 DDL）</strong>，但不记录 SELECT 查询</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p><code>bin log</code>确保事务的<strong>一致性和持久性</strong>，用以<strong>解决介质故障，主从复制，增量备份与恢复，数据审计</strong></p><h3 id="系统故障恢复方法"><a href="#系统故障恢复方法" class="headerlink" title="系统故障恢复方法"></a>系统故障恢复方法</h3><h4 id="基本恢复方法"><a href="#基本恢复方法" class="headerlink" title="基本恢复方法"></a>基本恢复方法</h4><p>正向扫描日志，<strong>Undo 故障发生时未完成的事务，Redo 已完成的事务</strong></p><p>系统在重新启动时自动完成，不需要用户干预</p><p>存在问题：搜索整个日志将耗费大量的时间；REDO 重新执行浪费了大量时间，所以引入检查点技术</p><h4 id="检查点技术"><a href="#检查点技术" class="headerlink" title="检查点技术"></a>检查点技术</h4><p>在日志文件中增加检查点记录（checkpoint）</p><ol><li>检查点记录的内容</li><li>建立检查点时刻所有正在执行的事务清单 这些事务最近一个日志记录的地址</li></ol><p>增加重新开始文件</p><ol><li>记录各个检查点记录在日志文件中的地址</li></ol><p>注：当事务 T 在一个检查点之前提交且T 对数据库所做的修改已写入磁盘。那么在进行恢复处理时，没有必要对事务 T 执行 REDO 操作</p><h4 id="利用检查点的恢复步骤"><a href="#利用检查点的恢复步骤" class="headerlink" title="利用检查点的恢复步骤"></a>利用检查点的恢复步骤</h4><ol><li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中<strong>找到最后一个检查点记录</strong></p></li><li><p>由该检查点记录得到<strong>检查点建立时刻所有正在 执行的事务清单 ACTIVE-LIST 建立两个事务队列：UNDO-LIST、REDO-LIST</strong>    把 ACTIVE-LIST <strong>暂时放入 UNDO-LIST 队列，REDO-LIST 队列暂为空</strong></p></li><li><p>从检查点开始正向扫描日志文件，直到日志文件结束    <strong>有新开始的事务 Ti，把 Ti 暂时放入 UNDO-LIST 队列</strong> </p><p><strong>如有提交的事务 Tj，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST 队列</strong></p></li><li><p><strong>对 UNDO-LIST 中的每个事务执行 UNDO 操作, 对 REDO-LIST 中的每个事务执行 REDO 操作</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一）绪论</title>
      <link href="/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="执行select的过程"><a href="#执行select的过程" class="headerlink" title="执行select的过程"></a>执行select的过程</h2><img src="/../../images/mysql查询流程.webp" style="zoom:60%;" /><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>客户端通过<strong>TCP三次握手</strong>与数据库建立连接</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>如果 SQL 是<strong>查询语句（select 语句）</strong>，MySQL 就会先去<strong>查询缓存</strong>（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 <strong>key-value 形式保存在内存中</strong>的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><h3 id="解析SQL"><a href="#解析SQL" class="headerlink" title="解析SQL"></a>解析SQL</h3><p>解析器完成<strong>词法分析</strong>（根据输入的字符串识别出关键字）和<strong>语法分析</strong>（判断语句语法）</p><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><ul><li><p>检查 SQL 查询语句中的表或者字段是否存在</p></li><li><p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列</p></li></ul><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>例如对于联合索引<code>（a,b,c）</code>若查询为<code>where b=1 and a=2</code>时会将<code>a=2</code>提前作为索引查询</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>执行器根据执行计划<strong>执行 SQL 查询语句</strong>，<strong>从存储引擎读取记录，返回给客户端</strong></p><h2 id="MySQL-的存储结构"><a href="#MySQL-的存储结构" class="headerlink" title="MySQL 的存储结构"></a>MySQL 的存储结构</h2><h3 id="数据库文件的存储目录"><a href="#数据库文件的存储目录" class="headerlink" title="数据库文件的存储目录"></a>数据库文件的存储目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]#ls /var/lib/mysql/my_test</span><br><span class="line">db.opt  # 默认字符集和字符校验规则</span><br><span class="line">t_order.frm  # 表结构</span><br><span class="line">t_order.ibd # 表数据</span><br></pre></td></tr></table></figure><h3 id="表空间文件（-ibd）的存储结构"><a href="#表空间文件（-ibd）的存储结构" class="headerlink" title="表空间文件（.ibd）的存储结构"></a>表空间文件（.ibd）的存储结构</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图</p><img src="/../../images/表空间结构.webp" style="zoom:60%;" /><h4 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的</p><h4 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>。<strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页的类型有很多，常见的有<strong>数据页、undo 日志页、溢出页等等</strong>。数据表中的行记录是用「数据页」来管理的</p><h4 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h4><p>InnoDB 存储引擎是用 B+ 树来组织数据的</p><p>B+ 树<strong>中每层都是通过双向链表连接的</strong>，如果是以页为单位来分配存储空间，那么链表中相邻的<strong>两个页之间的物理位置并不是连续的</strong>，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p><p>在表中数据量大的时候，<strong>为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配</strong>。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得<strong>链表中相邻的页的物理位置也相邻</strong>，就能使用顺序 I&#x2F;O 了。</p><h4 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合</li><li>数据段：存放 B + 树的叶子节点的区的集合</li><li>回滚段：存放的是回滚数据的区的集合</li></ul><h3 id="InnoDB-行格式（COMPACT-为例）"><a href="#InnoDB-行格式（COMPACT-为例）" class="headerlink" title="InnoDB 行格式（COMPACT 为例）"></a>InnoDB 行格式（COMPACT 为例）</h3><img src="/../../images/compact.png" style="zoom:60%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2025/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><p>高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖 于抽象（稳定）</p><p>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于 抽象（稳定）</p><h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><p>对扩展开放，对更改封闭</p><p>类模块应该是可扩展的，但是不可修改</p><h2 id="模版方法（Template-Method）"><a href="#模版方法（Template-Method）" class="headerlink" title="模版方法（Template Method）"></a>模版方法（Template Method）</h2><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>一些功能在底层开发模块时不知具体实现，而需要在高层模块实现</p><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作中的算法的骨架（稳定），而将一些步骤延迟 （变化）到子类中。Template Method使得子类可以不改变 （复用）一个算法的结构即可重定义（override 重写）该算法的某些特定步骤</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>由高层模块实现具体方法，其继承自包含该方法的基类。低层模块调用该基类upcast后的函数来执行</p><h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><h3 id="模式动机-1"><a href="#模式动机-1" class="headerlink" title="模式动机"></a>模式动机</h3><p>基于性能和软件正确性方面的考量，某些类只允许创建一次</p><h3 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点</p><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>第一次调用创建新对象，当创建了该对象后再次调用则返回已创建的对象</p><h3 id="具体例子（推荐的实现）"><a href="#具体例子（推荐的实现）" class="headerlink" title="具体例子（推荐的实现）"></a>具体例子（推荐的实现）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>();</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  Singleton*  instance;</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123; <span class="comment">// 双重检查锁定（线程安全）</span></span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><h3 id="模式动机-2"><a href="#模式动机-2" class="headerlink" title="模式动机"></a>模式动机</h3><p>在创建对象的时候不确定其具体类型，无法通过new来创建对象</p><h3 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟（目的：解耦， 手段：虚函数）到子类</p><h3 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h3><p>定义工厂类用于创建对象。创建一个工厂基类，不同的具体工厂类继承该基类。在低层模块创建对象时调用基类指针upcast之后的具体工厂的具体类创建方法。将不稳定隔离在上层，由上层传递具体工厂的对象给下层</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><h4 id="不好的实现"><a href="#不好的实现" class="headerlink" title="不好的实现"></a>不好的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainForm.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">  TextBox* txtFilePath;</span><br><span class="line">  TextBox* txtFileNumber;</span><br><span class="line">  ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    ISplitter * splitter = <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();<span class="comment">//依赖具体类</span></span><br><span class="line">    splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="推荐的实现"><a href="#推荐的实现" class="headerlink" title="推荐的实现"></a>推荐的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainForm.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">  SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ISplitter * splitter = factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new</span></span><br><span class="line">    splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory.cpp</span></span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SplitterFactory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySplitterFactory</span>: <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitterFactory</span>: <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h2><h3 id="模式动机-3"><a href="#模式动机-3" class="headerlink" title="模式动机"></a>模式动机</h3><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应</p><h3 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</p><h3 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h3><p>由订阅者实现具体的通知反应方法，其继承自通知基类。发布者在发送通知时调用该基类upcast后的函数来执行通知流程</p><h3 id="具体例子-1"><a href="#具体例子-1" class="headerlink" title="具体例子"></a>具体例子</h3><p>实现一个文件切分的<strong>进度条通知机制</strong></p><h4 id="不好的实现-1"><a href="#不好的实现-1" class="headerlink" title="不好的实现"></a>不好的实现</h4><p>在本实现中，由切分器实现具体的通知方法。存在的问题是切分器应该是较为稳定的模块，如果跟换了进度通知方法（例如控制台输出等）则<strong>需要修改<code>split</code>方法</strong></p><p>该实现<strong>违反了依赖倒置原则（高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖 于抽象(稳定)）</strong></p><p>由于切分器是较为稳定的模块（稳定），而UI界面才是与进度展示方式相绑定模块（不稳定）。该法<strong>将不稳定的通知实现绑定在了稳定的切分器模块</strong>，所以不是一个好的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileSplitter.cpp（切分器）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span></span><br><span class="line">&#123;</span><br><span class="line">string m_filePath;</span><br><span class="line"><span class="type">int</span> m_fileNumber;</span><br><span class="line">ProgressBar* m_progressBar;   <span class="comment">//!!!违反了依赖倒置原则,具体通知控件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileSplitter</span>(<span class="type">const</span> string&amp; filePath, <span class="type">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class="line"><span class="built_in">m_filePath</span>(filePath), </span><br><span class="line"><span class="built_in">m_fileNumber</span>(fileNumber),</span><br><span class="line"><span class="built_in">m_progressBar</span>(progressBar)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">m_progressBar-&gt;<span class="built_in">setValue</span>(progressValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainForm.cpp（UI界面）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line"><span class="type">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number, progressBar)</span></span>;</span><br><span class="line">splitter.<span class="built_in">split</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="推荐的实现-1"><a href="#推荐的实现-1" class="headerlink" title="推荐的实现"></a>推荐的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileSplitter.cpp（切分器）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IProgress</span>&#123;    <span class="comment">// 抽象的通知机制，由界面自己实现通知展示方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IProgress</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span></span><br><span class="line">&#123;</span><br><span class="line">string m_filePath;</span><br><span class="line"><span class="type">int</span> m_fileNumber;</span><br><span class="line">List&lt;IProgress*&gt;  m_iprogressList; <span class="comment">// 抽象通知机制，支持多个观察者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileSplitter</span>(<span class="type">const</span> string&amp; filePath, <span class="type">int</span> fileNumber) :</span><br><span class="line"><span class="built_in">m_filePath</span>(filePath), </span><br><span class="line"><span class="built_in">m_fileNumber</span>(fileNumber)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line"><span class="built_in">onProgress</span>(progressValue);<span class="comment">//发送通知</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.<span class="built_in">push_back</span>(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.<span class="built_in">remove</span>(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onProgress</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (itor != m_iprogressList.<span class="built_in">end</span>() )</span><br><span class="line">(*itor)-&gt;<span class="built_in">DoProgress</span>(value); <span class="comment">//更新进度条</span></span><br><span class="line">itor++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainForm.cpp（UI界面）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form, <span class="keyword">public</span> IProgress<span class="comment">//继承IProgress 接口</span></span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line"><span class="type">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line">ConsoleNotifier cn;</span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;</span><br><span class="line">splitter.<span class="built_in">addIProgress</span>(<span class="keyword">this</span>); <span class="comment">//订阅通知</span></span><br><span class="line">splitter.<span class="built_in">addIProgress</span>(&amp;cn)； <span class="comment">//订阅通知</span></span><br><span class="line">splitter.<span class="built_in">split</span>();</span><br><span class="line">splitter.<span class="built_in">removeIProgress</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleNotifier</span> : <span class="keyword">public</span> IProgress &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="观察者模式-VS-发布订阅模式（Publish–Subscribe-pattern）"><a href="#观察者模式-VS-发布订阅模式（Publish–Subscribe-pattern）" class="headerlink" title="观察者模式 VS 发布订阅模式（Publish–Subscribe pattern）"></a>观察者模式 VS 发布订阅模式（Publish–Subscribe pattern）</h4><p><strong>发布订阅模式（架构模式）</strong>中，<strong>发布者并不知道订阅者的存在，只是把消息发送给broker</strong>。订阅者通过订阅相关的topic获取消息。如下图所示；而在<strong>观察者模式（设计模式）</strong>中，<strong>发布者会通知订阅者</strong>，只不过具体的通知操作由订阅者自己实现</p><img src="/../../images/publish_subscribe.avif" style="zoom:100%;" /><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>观察者模式</strong></th><th align="left"><strong>发布-订阅模式</strong></th></tr></thead><tbody><tr><td align="left"><strong>耦合度</strong></td><td align="left">被观察者和观察者之间耦合度较高</td><td align="left">发布者和订阅者之间完全解耦</td></tr><tr><td align="left"><strong>通信方式</strong></td><td align="left">直接通信（被观察者调用观察者的方法）</td><td align="left">间接通信（通过消息代理）</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">适合固定的、一对多的依赖关系</td><td align="left">适合动态的、多对多的消息传递</td></tr><tr><td align="left"><strong>复杂性</strong></td><td align="left">实现简单</td><td align="left">实现复杂，需要引入消息代理</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">对象状态变化需要通知其他对象</td><td align="left">需要高度解耦的分布式系统或事件驱动系统</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2025/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2025/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="什么问题适合用动态规划（最优子结构）"><a href="#什么问题适合用动态规划（最优子结构）" class="headerlink" title="什么问题适合用动态规划（最优子结构）"></a>什么问题适合用动态规划（最优子结构）</h2><p>符合<strong>最优子结构</strong>的问题适合用动态规划</p><p><strong>最优子结构</strong> 是指一个问题的<strong>最优解可以通过其子问题的最优解构造出来</strong>。换句话说，问题的最优解依赖于子问题的最优解。</p><p>例如要计算年级的最高分，可通过计算每个班级的最高分之后取最值得到</p><h2 id="动态规划算法框架"><a href="#动态规划算法框架" class="headerlink" title="动态规划算法框架"></a>动态规划算法框架</h2><h3 id="确定状态和选择"><a href="#确定状态和选择" class="headerlink" title="确定状态和选择"></a>确定状态和选择</h3><p>明确当前值需要<strong>通过哪些子结构通过哪些选择得到</strong>，用以<strong>确定dp数组是一维还是二维的</strong></p><p>例如对于斐波那契数列只要知道前2项即可，所以是一维的</p><p>对于零钱兑换问题，如果target&#x3D;10，则粗略估计需要知道0-9的最小值（列），而且要对于不同零钱选择（行）计算最值（也可用一维的做，但二维从语意上更明确）</p><h3 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h3><p>一般定义<code>dp[i][j]</code>为在<code>target=j</code>时做操作i的最优值（对一维来说<code>i</code>即为数组索引）</p><h3 id="初始化dp数组"><a href="#初始化dp数组" class="headerlink" title="初始化dp数组"></a>初始化dp数组</h3><p>通过刚才定义出的dp数组的语意来初始化第一行&#x2F;列</p><p>【技巧】<strong>对于二维dp数组，一般会扩展一行与一列避免边界问题的讨论</strong>，需要注意的是在计算值时，状态应为<code>当前索引-1</code>的值，即<code>i-1</code>与<code>j-1</code></p><h3 id="举例推导dp数组"><a href="#举例推导dp数组" class="headerlink" title="举例推导dp数组"></a>举例推导dp数组</h3><p>试着<strong>手写推导部分值，总结规律</strong>，看哪些<strong>备选项与选择</strong>会出现最值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment">// 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"><span class="comment">// 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>题目为<strong>每件物品只能拿一次</strong>，计算在重量为K的限制下拿取物品的最大价值</p><p><code>dp[i][j]</code>表示在重量限制为<code>j</code>下，可拿物品为<code>0到i-1</code>的最大价值</p><img src="/../../images/dp_1.png" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 不拿（放不下）</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]); <span class="comment">// max（不拿，拿）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>题目为<strong>每件物品拿取次数不限</strong>，计算在重量为K的限制下拿取物品的最大价值</p><p><code>dp[i][j]</code>表示在重量限制为<code>j</code>下，可拿物品为<code>0到i-1</code>的最大价值</p><p>区别于0-1背包问题，完全背包问题的计算极值时要<strong>考虑多次取当前物品的情况</strong>，从代码角度来说就是当拿取当前物品时，<strong>剩余空间的最大价值不在上一行（不拿当前物品）找，而在当前行（拿当前物品）找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 不拿（放不下）</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]); <span class="comment">// max（不拿，拿）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列，子序列不要求连续</p><blockquote><p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “apcke”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 </p></blockquote><p><code>dp[i][j]</code>表示在text1为<code>0到i-1</code>,text2为<code>0到j-1</code>下的最长公共子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text<span class="number">1.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text<span class="number">2.</span><span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">      dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 相同则两边往前看</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);<span class="comment">// 不同则其中一边往前退一个</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h2><p>不可选相邻元素，求子序列求和的最大值</p><blockquote><p>输入：[1,2,3,1]<br>输出：4<br>解释： 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)</p><p>​            偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4</p></blockquote><p><code>dp[i]</code>表示在nums为<code>0到i-i</code>时受限子序列的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i<span class="number">-2</span>&lt;<span class="number">0</span>)</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],nums[i]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],nums[i]+dp[i<span class="number">-2</span>]); <span class="comment">// max（不拿，拿）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="细节策略"><a href="#细节策略" class="headerlink" title="细节策略"></a>细节策略</h2><h3 id="可复选与单选的区别"><a href="#可复选与单选的区别" class="headerlink" title="可复选与单选的区别"></a>可复选与单选的区别</h3><p>单选需要的是不包含当前可选物品时的状态（即上一行的状态）</p><p>复选需要的是包含当前可选物品时的状态（即当前行的状态）</p><p>具体区别见<strong>0-1背包问题和完全背包问题</strong></p><h3 id="消除子问题重复计算的方法（备忘录）"><a href="#消除子问题重复计算的方法（备忘录）" class="headerlink" title="消除子问题重复计算的方法（备忘录）"></a>消除子问题重复计算的方法（备忘录）</h3><p>一般情况下通过dp数组记录中间值来避免子问题的重复计算</p><p>在dp数组不好定义的情况下（例如树形等非线形状态），考虑用哈希表记录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 337. 打家劫舍 III        </span></span><br><span class="line">unordered_map&lt;TreeNode *,<span class="type">int</span>&gt;umap;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 偷父节点</span></span><br><span class="line">  <span class="type">int</span> val1 = root-&gt;val;</span><br><span class="line">  <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">    val1 += <span class="built_in">rob</span>(root-&gt;left-&gt;left) + <span class="built_in">rob</span>(root-&gt;left-&gt;right); <span class="comment">// 跳过root-&gt;left，相当于不考虑左孩子了</span></span><br><span class="line">  <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">    val1 += <span class="built_in">rob</span>(root-&gt;right-&gt;left) + <span class="built_in">rob</span>(root-&gt;right-&gt;right); <span class="comment">// 跳过root-&gt;right，相当于不考虑右孩子了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不偷父节点</span></span><br><span class="line">  <span class="type">int</span> val2 = <span class="built_in">rob</span>(root-&gt;left) + <span class="built_in">rob</span>(root-&gt;right); <span class="comment">// 考虑root的左右孩子</span></span><br><span class="line">  umap[root] = <span class="built_in">max</span>(val1, val2); <span class="comment">// 记录当前状态</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(val1, val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（五）MySQL中的锁</title>
      <link href="/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%94%EF%BC%89MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%94%EF%BC%89MySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="事务并发时遇到的问题"><a href="#事务并发时遇到的问题" class="headerlink" title="事务并发时遇到的问题"></a>事务并发时遇到的问题</h2><h3 id="数据完整性方面（不同事务对同一行的读写-写写操作）"><a href="#数据完整性方面（不同事务对同一行的读写-写写操作）" class="headerlink" title="数据完整性方面（不同事务对同一行的读写&#x2F;写写操作）"></a>数据完整性方面（不同事务对同一行的读写&#x2F;写写操作）</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>不同事务对于同一范围内的数据进行增&#x2F;删&#x2F;改时需要锁确保在事务提交前只有一个事务能操作该数据</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>对于要修改的数据加<strong>锁（lock）</strong></p><h3 id="查询结果方法（幻读现象）"><a href="#查询结果方法（幻读现象）" class="headerlink" title="查询结果方法（幻读现象）"></a>查询结果方法（幻读现象）</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>在当前读（区别于使用MVCC中ReadView的快照读）的场景下，在事务内不同时间对同一查询条件得到的查询结果不同</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>通过<strong>记录锁（record lock），间隙锁（gap lock）或临键锁（Next-Key Lock）</strong>来保护相应数据【具体方法见下文—MySQL如何加行级锁】</p><h2 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p><code>flush tables with read lock</code>执行后，<strong>整个数据库就处于只读状态了</strong></p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>分为<strong>共享锁（S锁）</strong>和<strong>独占锁（X锁）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure><p>当前线程对表A加读锁后，其他线程只能读不能写表A，当前线程可读写表A但不能读写其他表</p><p>当前线程对表A加写锁后，其他线程只能读不能读写表A，当前线程可读写表A但不能读写其他表</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p><strong>意向锁</strong></p><ul><li>对任一结点加基本锁，必须<strong>先</strong>对它的上层所有结点<strong>加意向锁</strong>（例如对于数据行加锁，则需要对表和数据库加锁）</li><li>如果对一个结点加意向锁，则说明该结点的<strong>下层结点</strong>正在被加锁</li><li><strong>意向锁可以提高对某个数据对象加锁时系统的检查效率</strong></li></ul><blockquote><p>例：对任一元组 r 加锁，先对关系 R 加意向锁</p><p>事务 T 要对关系 R 加 X 锁, 系统只要检查根结点数据库和关系 R 是否已加了不相容的锁，不需要搜索和检查 R 中的每一个元组是否加了 X 锁</p></blockquote><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h3 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h3><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）</li></ul><p><strong>其锁定的是当前记录（即 <code>=</code> ）</strong></p><img src="/../../images/record_lock.webp" style="zoom:100%;" /><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p><img src="/../../images/gap_lock.webp" style="zoom:100%;" /><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><p><strong>其锁定的是间隔（即开区间 <code>(a , b)</code> ）</strong></p><h3 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h3><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改和删除 id &#x3D; 5 这条记录。</p><img src="/../../images/next_key_lock.webp" style="zoom:100%;" /><p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。</p><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><p>比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。</p><p><strong>其锁定的是间隔和右边界（即左开右闭区间 <code>(a , b]</code> ）</strong></p><h2 id="为什么要加行级锁"><a href="#为什么要加行级锁" class="headerlink" title="为什么要加行级锁"></a>为什么要加行级锁</h2><p>MySQL 里除了普通查询是快照读（通过MVCC的Read View处理），其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p><p>这很好理解，假设要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p><p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p><p>所以，<strong>加行级锁一是为了确保增删改的正确性，二是为了避免在事务中出现幻读现象</strong></p><h2 id="MySQL如何加行级锁"><a href="#MySQL如何加行级锁" class="headerlink" title="MySQL如何加行级锁"></a>MySQL如何加行级锁</h2><h3 id="行级锁锁的是索引，不是数据行"><a href="#行级锁锁的是索引，不是数据行" class="headerlink" title="行级锁锁的是索引，不是数据行"></a>行级锁锁的是索引，不是数据行</h3><h3 id="加锁方法"><a href="#加锁方法" class="headerlink" title="加锁方法"></a>加锁方法</h3><p><strong>确保在事务内多次查询结果一致，即需要对于所有查询可能查到的结果范围加锁</strong></p><p>对于加锁方法不要特意去记，只需<strong>关注哪些范围的修改操作会影响查询的结果</strong></p><p>然后使用工具：record lock（锁当前），gap lock（锁两边），next-key lock（锁两边和一个边界）达到锁等级和最小即可（从左到右锁等级依此增加）</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><p>对于唯一索引等值查询，如果<strong>查询结果存在</strong>，则只需通过<strong>record lock锁住当前记录（因为唯一索引对应的行只有当前行）</strong></p><p>对于<code>select * from user where id = 1 for update</code></p><img src="/../../images/mysql_lock_1.webp" style="zoom:70%;" /><p>如果<strong>查询结果不存在</strong>，则需要对该查询条件的<strong>左右值间加gap lock（以确保当前值不会新插入）</strong>。</p><p>虽然会影响其他值的修改，但只能这么锁，否则需要维护一个列表记录哪些条件不能插入，对性能影响较大</p><p>对于<code>select * from user where id = 2 for update</code></p><img src="/../../images/mysql_lock_2.webp" style="zoom:50%;" /><h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><p>对于唯一索引范围查询，对于查询结果存在的情况需要<strong>加 record lock，gap lock 和 next-key lock（可能只有其一或二）</strong></p><p>用 next-key lock 来对不同范围且满足条件的边界加锁</p><p>对于<code>select * from user where id &gt; 15 for update</code></p><img src="/../../images/mysql_lock_3.webp" style="zoom:50%;" /><p>对于<code>select * from user where id &gt;= 15 for update</code></p><img src="/../../images/mysql_lock_4.webp" style="zoom:50%;" /><p>对于查询结果不存在的情况需要<strong>加gap lock和next-key lock（可能只有其一）</strong></p><p>对于<code>select * from user where id &lt; 6 for update</code></p><img src="/../../images/mysql_lock_5.webp" style="zoom:50%;" /><h4 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h4><p>在非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以<strong>在加锁时，同时会对这两个索引都加锁</strong>，对二级索引加的锁类似于上文对唯一索引的加锁方式，对主键索引的加锁体现在gap lock和next-key lock中。</p><p>回忆<strong>二级索引的存储方式</strong>，其<strong>先按照二级索引值进行排序，当二级索引值相同时按照唯一索引值排序</strong></p><p>对于非唯一索引等值查询，如果<strong>查询结果存在</strong>，只<strong>对该行加record lock是不够的</strong>，因为其不唯一，左右仍可以加入新值。所以需<strong>要next-key lock锁当前和左边范围，gap lock锁右边范围</strong></p><p>对于<code>select * from user where age = 22 for update</code></p><img src="/../../images/mysql_lock_6.webp" style="zoom:90%;" /><p>注：</p><ol><li>对于<code>age=21 &amp;&amp; id&lt;5</code>的值是可以插入的，因为在<strong>二级索引锁是对二级索引记录加锁而不是对二级索引值加锁</strong>，所以不会完全影响一级索引的边界插入。但对于<code>age=21 &amp;&amp; id&gt;=5</code>的值是不可修改的，因为其在 next-key lock 中</li><li><strong>非唯一索引不用 record lock 是因为二级索引值不具有唯一性</strong>，必须把当前和所有都锁住才能避免二级索引同值的修改</li></ol><p>如果查询结果不存在，则需要<strong>加gap lock锁住可能影响的范围</strong></p><p>对于<code>select * from user where age = 25 for update</code></p><img src="/../../images/mysql_lock_8.webp" style="zoom:80%;" /><h4 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h4><p>对于非唯一索引范围查询，需要<strong>用next-key锁锁住可能影响的范围</strong></p><p>对于<code>select * from user where age &gt;= 22  for update</code></p><img src="/../../images/mysql_lock_7.webp" style="zoom:60%;" /><h4 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h4><p>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致<strong>扫描是全表扫描</strong>。那么，<strong>每一条记录的索引上都会加 next-key 锁</strong>，这样就<strong>相当于锁住的全表</strong>，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><p>所以，<strong>update如果没加索引会锁全表</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>MySQL在 加行级锁时还会<strong>对表加意向锁</strong></li><li>即使<strong>不通过显式事务执行 <code>SELECT ... FOR UPDATE</code><strong>，MySQL 也会</strong>开启隐式事务来管理锁</strong>。锁的释放依赖于事务的提交或回滚。可以<strong>通过显式提交（<code>COMMIT</code>）或回滚（<code>ROLLBACK</code>）来手动释放锁</strong>，也可以<strong>通过结束会话自动释放锁</strong>。</li></ol><h2 id="Insert语句会加哪些锁"><a href="#Insert语句会加哪些锁" class="headerlink" title="Insert语句会加哪些锁"></a>Insert语句会加哪些锁</h2><p>首先会<strong>对表加意向写锁（IX）</strong>。对于<strong>行级锁Insert 语句在正常执行时是不会生成锁结构</strong>的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</p><p>隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里列举两个场景。</p><ul><li>如果<strong>记录之间加有间隙锁</strong>，为了避免幻读，此时是不能插入记录的；</li><li>如果 <strong>Insert 的记录和已有记录存在唯一键冲突</strong>，此时也不能插入记录</li></ul><h3 id="记录之间加有间隙锁"><a href="#记录之间加有间隙锁" class="headerlink" title="记录之间加有间隙锁"></a>记录之间加有间隙锁</h3><p>每插入一条新记录，都<strong>需要看是否位于间隙锁区间</strong>，如果已加间隙锁，此时会<strong>生成一个插入意向锁</strong>，然后<strong>锁的状态设置为等待状态（阻塞态）</strong>，<strong>直到持有间隙锁的所有事务提交后才能插入</strong></p><p>MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</p><h3 id="遇到唯一键冲突"><a href="#遇到唯一键冲突" class="headerlink" title="遇到唯一键冲突"></a>遇到唯一键冲突</h3><p>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。</p><ul><li>如果<strong>主键索引重复</strong>，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li></ul><p>​（目的是<strong>保证数据一致性</strong>，防止其他事务在期间删除该主键但本事务无法插入该记录的情况）</p><ul><li><p>如果<strong>唯一二级索引重复</strong>，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</p><p>（个人觉得这种情况下加record锁即可，因为是唯一索引）</p></li></ul><h3 id="两个事务执行过程中，执行了相同的-insert-语句的场景"><a href="#两个事务执行过程中，执行了相同的-insert-语句的场景" class="headerlink" title="两个事务执行过程中，执行了相同的 insert 语句的场景"></a>两个事务执行过程中，执行了相同的 insert 语句的场景</h3><p>order_no为唯一二级索引。在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时<strong>事务 B 的 Insert 语句会发生阻塞</strong>。</p><img src="/../../images/insert_lock_1.webp" style="zoom:60%;" /><p>两个事务的加锁过程：</p><ul><li>事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；</li><li>接着，事务 B 也插入 order_no 为 1006 的记录，由于事务 A 已经插入 order_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交，<strong>事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态</strong>。</li></ul><img src="/../../images/insert_lock_2.webp" style="zoom:80%;" /><p>从这个实验可以得知，并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。</p><p>但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会<strong>被阻塞</strong>，<strong>因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的</strong>，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。</p><p>如果 <strong>order_no 不是唯一二级索引</strong>，那么两个事务，前后执行相同的 Insert 语句，是<strong>不会发生阻塞</strong>的，就如前面的这个例子。</p><img src="/../../images/insert_lock_3.webp" style="zoom:60%;" /><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h3><p>举一个例子，表数据如下图所示</p><img src="/../../images/lock_example_1.webp" style="zoom:60%;" /><p>加锁流程如下：</p><p>Time1：事务A加（20，30）的gap lock</p><p>Time2：事务B加（20，30）的gap lock</p><p>Time3：事务A加id&#x3D;25的插入意向锁（由于事务B持有gap lock，所以阻塞等待）【插入意向锁与间隙锁互斥，间隙锁与间隙锁相容】</p><p>Time4：事务B加id&#x3D;26的插入意向锁（由于事务A持有gap lock，所以阻塞等待）</p><p>（死锁）</p><img src="/../../images/lock_example_2.webp" style="zoom:60%;" /><h3 id="发生死锁的条件"><a href="#发生死锁的条件" class="headerlink" title="发生死锁的条件"></a>发生死锁的条件</h3><p>死锁的四个必要条件：<strong>互斥、请求并保持、不可抢占、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立</p><h3 id="死锁的处理办法"><a href="#死锁的处理办法" class="headerlink" title="死锁的处理办法"></a>死锁的处理办法</h3><p>在数据库层面，有两种策略通过<strong>「打破循环等待条件」</strong>来解除死锁状态：</p><ul><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的<strong>等待时间超过该值后，就对这个事务进行回滚</strong>，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p></li><li><p><strong>开启主动死锁检测</strong>。<strong>主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p></li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="对B-树（索引）加锁时的注意事项"><a href="#对B-树（索引）加锁时的注意事项" class="headerlink" title="对B+树（索引）加锁时的注意事项"></a>对B+树（索引）加锁时的注意事项</h3><ol><li><strong>尽量使用细粒度的锁（如record lock）</strong>，以提高并发性能</li><li>确保查询或修改<strong>走的是索引</strong>，否则会锁全表</li><li>避<strong>免死锁和长时间持有锁</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（三）事务</title>
      <link href="/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8B%E5%8A%A1/"/>
      <url>/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库需要解决的问题（背景）"><a href="#数据库需要解决的问题（背景）" class="headerlink" title="数据库需要解决的问题（背景）"></a>数据库需要解决的问题（背景）</h2><p>在转账场景中，A向B转账100元。转账过程需要保证的是要么转账成功，要么转账失败恢复到原始值<strong>（原子性 Atomicity）</strong>；转账前后A与B账号的存款总数不变<strong>（一致性 Consistency）</strong>；转账过程中A与B的其他转账操作不影响当前转账<strong>（隔离性 Isolation）</strong>；转账成功则不可撤回<strong>（持久性 Durability）</strong>。所以引入<strong>事务（Transaction）</strong>的概念</p><h2 id="事务（解决方案）"><a href="#事务（解决方案）" class="headerlink" title="事务（解决方案）"></a>事务（解决方案）</h2><h3 id="特性（ACID）"><a href="#特性（ACID）" class="headerlink" title="特性（ACID）"></a>特性（ACID）</h3><ol><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</li></ol><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h3 id="并行事务的问题与解决方案（读的隔离性）"><a href="#并行事务的问题与解决方案（读的隔离性）" class="headerlink" title="并行事务的问题与解决方案（读的隔离性）"></a>并行事务的问题与解决方案（读的隔离性）</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><strong>脏读</strong>：如果一个事务「读到」了另一个<strong>「未提交事务修改过的数据」</strong>，就意味着发生了「脏读」现象</li></ol><img src="/../../images/dirty_read.webp" style="zoom:50%;" /><ol start="2"><li><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，如果出现<strong>前后两次读到的数据不一样的情况</strong>，就意味着发生了「不可重复读」现象</li></ol><img src="/../../images/read_twice_different.webp" style="zoom:50%;" /><ol start="3"><li><strong>幻读</strong>：在一个事务内<strong>多次查询</strong>某个符合查询条件的「记录数量」，如果出现<strong>前后两次查询到的记录数量不一样</strong>的情况，就意味着发生了「幻读」现象。（个人觉得幻读是不可重复读的一种，“不可重复读”侧重于快照读，“幻读”侧重于当前读）</li></ol><img src="/../../images/phantom_read.webp" style="zoom:55%;" /><h4 id="可用方案（不同隔离级别）"><a href="#可用方案（不同隔离级别）" class="headerlink" title="可用方案（不同隔离级别）"></a>可用方案（不同隔离级别）</h4><ol><li><p><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</p></li><li><p><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</p></li><li><p><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</p></li><li><p><strong>串行化（serializable ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</p></li></ol><img src="/../../images/isolation_level.webp" style="zoom:55%;" /><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><ol><li><p>对于<strong>「读未提交」</strong>隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以<strong>直接读取最新的数据</strong>就好了；</p></li><li><p>对于<strong>「串行化」</strong>隔离级别的事务来说，通<strong>过加读写锁</strong>的方式来避免并行访问；</p></li><li><p>对于<strong>「读提交」和「可重复读」</strong>隔离级别的事务来说，它们是通过 <strong>Read View <strong>来实现的，它们的区别在于</strong>创建 Read View 的时机不同</strong>，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。<strong>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></p></li></ol><h5 id="「读提交」和「可重复读」的实现方法"><a href="#「读提交」和「可重复读」的实现方法" class="headerlink" title="「读提交」和「可重复读」的实现方法"></a>「读提交」和「可重复读」的实现方法</h5><p><strong>Undo log</strong></p><p>每个Undo Log记录包含以下信息：</p><ul><li>事务ID（TrxID）：修改数据的事务ID。</li><li>回滚指针（Roll Pointer）：指向该行的上一个版本。</li><li>旧值：被修改前的数据值。</li><li>操作类型：插入（INSERT）、更新（UPDATE）或删除（DELETE）</li></ul><img src="/../../images/undo_log_1.webp" style="zoom:55%;" /><p><strong>Read View</strong></p><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><img src="/../../images/readview结构.webp" style="zoom:55%;" /><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li><p>如果<strong>记录（undo log）的</strong> <strong>trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值</strong>，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p></li><li><p>如果<strong>记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值</strong>，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p></li><li><p>如果<strong>记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间</strong>，需要判断 trx_id 是否在 m_ids 列表中：</p><ul><li>如果<strong>记录的 trx_id 在 <code>m_ids</code> 列表中</strong>，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果<strong>记录的 trx_id 不在 <code>m_ids</code>列表中</strong>，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><h6 id="可重复读的工作流程"><a href="#可重复读的工作流程" class="headerlink" title="可重复读的工作流程"></a><strong>可重复读的工作流程</strong></h6><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><img src="/../../images/repeated_read_1.webp" style="zoom:55%;" /><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li><li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>接下来，跟大家具体分析下。</p><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><img src="/../../images/repeated_read_2.webp" style="zoom:55%;" /><p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id &#x3D; 51）。</p><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p><p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p><h6 id="读提交的工作流程"><a href="#读提交的工作流程" class="headerlink" title="读提交的工作流程"></a><strong>读提交的工作流程</strong></h6><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p><ul><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li></ul><p>那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：</p><img src="/../../images/read_commited_1.webp" style="zoom:55%;" /><p>我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？</p><p>事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明<strong>这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录</strong>。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？</p><p>在事务 A 提交后，<strong>由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View</strong>，此时事务 B 第三次读取数据时创建的 Read View 如下：</p><img src="/../../images/read_commited_2.webp" style="zoom:55%;" /><p>事务 B 在找到小林这条记录时，<strong>会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的</strong>。</p><p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果不在事务内，普通的 <code>SELECT</code> 语句会使用 <strong>快照读</strong>（Read View实现），读取当前时刻的数据快照，不加锁</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（四）锁理论</title>
      <link href="/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%81%E7%90%86%E8%AE%BA/"/>
      <url>/2025/02/11/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%9B%9B%EF%BC%89%E9%94%81%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="事务并发带来的问题"><a href="#事务并发带来的问题" class="headerlink" title="事务并发带来的问题"></a>事务并发带来的问题</h2><ul><li><strong>丢失修改（lost update）</strong>：<strong>事务 1 与事务 2 从数据库中读入同一数据并修改</strong>，事务 2 的提交结果破坏了事务 1 提交的结果， 导致事务 1 的修改被丢失。(W-W)</li><li><strong>读 “脏” 数据（dirty read）</strong>：<strong>事务 1 修改某一数据</strong>，并将其写回磁盘，<strong>事务 2 读取同一数据后，事务 1 由于某种原因被撤消</strong>，这时事务 1 已修改过的数据恢复原值，<strong>事务 2 读到的数据就与数据库中的数据不一致</strong>，是不正确的数据，又称为 “脏” 数据。（W-R）</li><li><strong>不可重复读（non-repeatable read）</strong>：<strong>事务 1 读取数据后，事务 2 执行更新操作</strong>，使事务 1 无法再现前一次读取结果。(R-W)</li></ul><h2 id="并发不一致性的解决办法（封锁协议）"><a href="#并发不一致性的解决办法（封锁协议）" class="headerlink" title="并发不一致性的解决办法（封锁协议）"></a>并发不一致性的解决办法（封锁协议）</h2><ul><li><p><strong>一级封锁协议</strong></p><p>事务 T 在修改数据 W 之前必须先对其加 X 锁，直到<strong>事务结束</strong>才释放（读不加锁）</p><p><strong>一级封锁协议可防止 丢失修改</strong></p></li><li><p><strong>二级封锁协议</strong></p><p><strong>一级封锁协议基础上</strong>，事务 T 在读取数据 R 之前必须先对其加 S 锁，<strong>读完后</strong>即可释放 S 锁</p><p>**二级封锁协议可以防止 丢失修改 和 读 “脏” 数据 **</p></li><li><p><strong>三级封锁协议</strong></p><p><strong>一级封锁协议基础上</strong>，事务 T 在读取数据 R 之前必须先对其加 S 锁，直到<strong>事务结束</strong>才释放</p><p><strong>三级封锁协议可防止 丢失修改、读脏数据和不可重复读</strong></p></li></ul><h2 id="并行事务正确性的唯一准则（可串行化调度）"><a href="#并行事务正确性的唯一准则（可串行化调度）" class="headerlink" title="并行事务正确性的唯一准则（可串行化调度）"></a>并行事务正确性的唯一准则（可串行化调度）</h2><h3 id="可串行性的定义"><a href="#可串行性的定义" class="headerlink" title="可串行性的定义"></a><strong>可串行性的定义</strong></h3><p>几个事务的并行执行是正确的，<strong>当且仅当其结果与按某一次序串行地执行它们时的结果相同</strong>。 这种并行调度策略称为可串行化（Serializable） 的调度</p><p><strong>可串行性是并行事务正确性的唯一准则</strong></p><h3 id="什么是冲突操作"><a href="#什么是冲突操作" class="headerlink" title="什么是冲突操作"></a><strong>什么是冲突操作</strong></h3><p>冲突操作是指<strong>读写操作</strong>和<strong>写写操作</strong></p><h3 id="什么是冲突可串行化调度"><a href="#什么是冲突可串行化调度" class="headerlink" title="什么是冲突可串行化调度"></a><strong>什么是冲突可串行化调度</strong></h3><p>一个调度 Sc 在保证冲突操作的次序不变地情况下，通过交换两个事务不冲突操作的次序得到另一 个调度 Sc’ , 如果 Sc’是串行的，则称调度 Sc 为<strong>冲突可串行化的调度</strong></p><p>一个调度是冲突可串行化的，则一定是可串行化的调度。 （充分条件）</p><h3 id="可串行化的方法（两段锁协议）"><a href="#可串行化的方法（两段锁协议）" class="headerlink" title="可串行化的方法（两段锁协议）"></a>可串行化的方法（两段锁协议）</h3><h3 id="两段锁协议的内容"><a href="#两段锁协议的内容" class="headerlink" title="两段锁协议的内容"></a><strong>两段锁协议的内容</strong></h3><ul><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，<strong>事务</strong>不再获得任何其他封锁</li></ul><p><strong>所有遵守两段锁协议的事务，其并行执行的结果一定是正确的</strong></p><p>事务遵守两段锁协议是可串行化调度的<strong>充分条件</strong>，而不是必要条件。可串行化的调度中，不一定所有事务都必须符合两段锁协议。</p><p>两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此<strong>遵守两段锁协议的事务可能发生死锁</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（一）封装、继承和多态</title>
      <link href="/2025/02/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/02/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>类不是实体，对象是实体</p><p>成员变量（filed）属于对象</p><p>成员函数（member function）属于类</p><h3 id="Big-Three（构造函数，拷贝构造，拷贝赋值）"><a href="#Big-Three（构造函数，拷贝构造，拷贝赋值）" class="headerlink" title="Big Three（构造函数，拷贝构造，拷贝赋值）"></a>Big Three（构造函数，拷贝构造，拷贝赋值）</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p><strong>列表初始化（initialize list）</strong>仅对成员变量初始化。</p><p>在构造函数里对成员变量初始化则为先初始化（默认）后赋值，故所有成员变量必须要有默认的初始化方法（成员变量包含其他类但该类没有默认构造函数则会报错）。构造函数无法主动调用。</p><p>尽量使用列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">a</span>(i)&#123;&#125;;  <span class="comment">//initialize list</span></span><br><span class="line">  <span class="comment">// A(int i):&#123;a=i;&#125; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造和拷贝赋值"><a href="#拷贝构造和拷贝赋值" class="headerlink" title="拷贝构造和拷贝赋值"></a>拷贝构造和拷贝赋值</h4><p><strong>浅拷贝和深拷贝有什么区别</strong></p><p>浅拷贝为字节流的拷贝，对于指针来说，通过浅拷贝会使新对象和旧对象指向同一块内存（类默认的拷贝构造和拷贝赋值）</p><p>深拷贝在复制时为指针分配新的内存，新对象和旧对象有各自独立的空间。</p><p><strong>对于成员变量含有指针的类，尽量自己实现拷贝构造和拷贝赋值，防止不同对象的成员变量的指针指向同一块内存</strong></p><h5 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">ptr</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        ptr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> <span class="type">char</span> *c_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(c_ptr) + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            ptr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test(const char *c_ptr)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;test)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, test.ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test(Test &amp;test)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test) <span class="comment">//1.防止无意义拷贝 2.防止在拷贝自身前清空ptr内容</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, test.ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call copy operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test; <span class="comment">//构造函数，call Test()</span></span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>; <span class="comment">//拷贝构造,call Test(const char *c_ptr)</span></span><br><span class="line">    Test test2 = test1; <span class="comment">//拷贝赋值,call Test(Test &amp;test)</span></span><br><span class="line">    <span class="function">Test <span class="title">test3</span><span class="params">(test1)</span></span>; <span class="comment">//拷贝赋值,call Test(Test &amp;test)</span></span><br><span class="line">    test3 = test2; <span class="comment">//赋值,call copy operator=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，<strong>是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体</strong>。</p><p>数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。</p><p>其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p>使用封装有 4 大好处：</p><ul><li>1、良好的封装能够减少耦合。</li><li>2、类内部的结构可以自由修改。</li><li>3、可以对成员进行更精确的控制。</li><li>4、隐藏信息，实现细节。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="为什么需要继承？"><a href="#为什么需要继承？" class="headerlink" title="为什么需要继承？"></a>为什么需要继承？</h4><p>如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。</p><p>这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样<strong>使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见</strong></p><h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><table><thead><tr><th>访问限制符\访问位置</th><th>当前类</th><th>子类</th><th align="center">类外</th></tr></thead><tbody><tr><td>public</td><td>可以</td><td>可以</td><td align="center">可以</td></tr><tr><td>protected</td><td>可以</td><td>可以</td><td align="center">不可以</td></tr><tr><td>private</td><td>可以</td><td>不可以</td><td align="center">不可以</td></tr></tbody></table><h3 id="重载、重写和覆盖"><a href="#重载、重写和覆盖" class="headerlink" title="重载、重写和覆盖"></a>重载、重写和覆盖</h3><h4 id="重载（overloading）"><a href="#重载（overloading）" class="headerlink" title="重载（overloading）"></a>重载（overloading）</h4><p>在同一个作用域中，<strong>函数名相同</strong>，但<strong>参数列表（包括参数的类型、个数或顺序）不同</strong>，形成的多个函数称为<strong>函数重载</strong>。</p><h4 id="重写（overriding）"><a href="#重写（overriding）" class="headerlink" title="重写（overriding）"></a>重写（overriding）</h4><p>在<strong>派生类中</strong>，定义了一个与<strong>基类中同名且参数列表完全相同</strong>的函数，并通过 virtual 声明基类函数实现动态多态。（<strong>虚函数</strong>实现）</p><h4 id="覆盖（Hiding）"><a href="#覆盖（Hiding）" class="headerlink" title="覆盖（Hiding）"></a>覆盖（Hiding）</h4><p>在<strong>派生类中</strong>，定义了一个与<strong>基类同名但参数列表不同</strong>的函数时，基类的函数被隐藏（覆盖）。函数覆盖不是动态多态的一部分，与重写不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a):<span class="built_in">i</span>(a)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::print()&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::print(int i)&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> a):<span class="built_in">A</span>(a)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::print()&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">2</span>); <span class="comment">//ERROR, cant found print(int a) in A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>不同的对象对于同一消息作出不同的响应</strong>。子类在继承父类后可以设计自己的版本，在运行时动态选择调用哪个版本实现</p><h4 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a><strong>静态绑定和动态绑定</strong></h4><p>在面向对象编程中，静态绑定和动态绑定是两种不同的函数调用机制。</p><p><strong>静态绑定（Static Binding）</strong>，也称为早期绑定或编译期绑定，是指<strong>在程序编译时就将函数调用与函数实现绑定起来，而不考虑对象的实际类型</strong>。这种绑定是通过函数的名称和参数列表来实现的。在静态绑定中，编译器会<strong>在编译期间确定调用哪个函数</strong>，而不是在运行时确定。静态绑定通常适用于非虚函数的调用，因为非虚函数的调用是在编译期间就可以确定的。</p><p><strong>动态绑定（Dynamic Binding）</strong>，也称为晚期绑定或运行时绑定，是指<strong>在程序运行时根据对象的实际类型来决定调用哪个函数</strong>。这种绑定是通过虚函数来实现的。在动态绑定中，编译器会在运行时确定调用哪个函数，而不是在编译期间确定。动态绑定适用于需要实现多态性的情况，可以<strong>让基类指针或引用调用派生类中的函数实现，实现运行时多态性</strong>。</p><h4 id="函数重载或函数模版（编译时多态）"><a href="#函数重载或函数模版（编译时多态）" class="headerlink" title="函数重载或函数模版（编译时多态）"></a>函数重载或函数模版（编译时多态）</h4><h4 id="虚函数（运行时多态）"><a href="#虚函数（运行时多态）" class="headerlink" title="虚函数（运行时多态）"></a>虚函数（运行时多态）</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>实现动态多态性（Runtime Polymorphism）：通过使用虚函数，可以在运行时动态地确定调用的是基类函数还是派生类函数，实现多态性。例如，如果我们有一个指向基类对象的指针，我们可以使用虚函数来调用派生类中的适当函数。</li><li>支持运行时类型识别（RTTI）：通过使用虚函数和类型信息（type information），可以在运行时确定对象的实际类型，从而实现更加灵活的代码设计。</li><li>简化代码维护：使用虚函数可以将代码的实现细节从类的使用者中分离出来，使得修改基类的实现对派生类的影响最小。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>对于有虚函数的类，其对象会包含指向vtable的vptr指针（vtable中为所有虚函数的地址）。在运行时确定对象类型，来选取相应的vptr，进而找到vptr指向的vtable的虚函数的具体函数地址</p><img src="/../../images/vtable.png" style="zoom:30%;" /><img src="/../../images/vtable_2.png" style="zoom:50%;" /><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><ol><li>新建子类对象</li><li>通过父类指针指向该对象</li><li>用虚函数定义目标函数</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *test = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">//向上造型（upcasting）指将派生类的引用或指针转化为父类的引用或指针</span></span><br><span class="line">test-&gt;<span class="built_in">print</span>();  <span class="comment">//Derived print</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>如果派生类<strong>没有覆盖基类的虚函数</strong>，则派生类会直接<strong>继承基类中的版本</strong></p><p>如果<strong>类存在虚函数</strong>，则需<strong>将析构函数设为虚函数</strong>，否则在基类指针调用析构时只能运行基类的析构</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般来说，最好在类定义开始货结束前的集中位置声明友元</p><p>友元的声明只指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么就必须在友元声明外再专门对函数进行一次声明</p><p>相同类的对象互为友元</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（二）索引</title>
      <link href="/2025/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B4%A2%E5%BC%95/"/>
      <url>/2025/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>使用<strong>B+树</strong>作为存储结构，<strong>非叶子结点存放索引</strong>，<strong>叶子节点才会存放实际数据（索引+记录）</strong></p><img src="/../../images/db_index_1.webp" style="zoom:70%;" /><h3 id="为什么使用B-树"><a href="#为什么使用B-树" class="headerlink" title="为什么使用B+树"></a>为什么使用B+树</h3><p>B+树与B树的对比如下</p><ul><li>B+ 树的非叶子节点<strong>不存放实际的记录数据，仅存放索引</strong>，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，<strong>B+树的非叶子节点可以存放更多的索引</strong>，因此 B+ 树可以比 B 树更「矮胖」，<strong>查询底层节点的磁盘 I&#x2F;O次数会更少</strong></li><li>B+ 树<strong>有大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 <strong>B+ 树在插入、删除的效率都更高</strong>，比如删除根节点的时候，<strong>不会像 B 树那样会发生复杂的树的变化</strong></li><li><strong>B+ 树叶子节点之间用链表连接了起来，有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="使用索引时的查询流程"><a href="#使用索引时的查询流程" class="headerlink" title="使用索引时的查询流程"></a>使用索引时的查询流程</h2><h3 id="叶子节点存放的是实际数据时（聚簇索引）"><a href="#叶子节点存放的是实际数据时（聚簇索引）" class="headerlink" title="叶子节点存放的是实际数据时（聚簇索引）"></a>叶子节点存放的是实际数据时（聚簇索引）</h3><p>当通过主键指定条件时，<strong>通过主键索引遍历到叶子结点</strong>，<strong>获得主键值和其对应的数据</strong></p><img src="/../../images\db_index_1.webp" style="zoom:70%;" /><h3 id="叶子节点存放的是主键值时（二级索引）"><a href="#叶子节点存放的是主键值时（二级索引）" class="headerlink" title="叶子节点存放的是主键值时（二级索引）"></a>叶子节点存放的是主键值时（二级索引）</h3><p>当建立了非主键字段的索引而且是通过该字段指定条件时，<strong>通过二级索引可查到该条件下对应的主键值</strong>。如果查询的字段除了主键外还有其他值，则需要进行<strong>回表操作</strong>（即通过主键值搜索聚簇索引到叶子结点取值）</p><p>所以为了提升效率，<strong>一是在查询时尽量只查索引项包含的字段</strong>，<strong>二是对于常用字段建立二级索引时考虑将会用到的字段一同建立联合索引，避免回表（即减少IO操作）</strong></p><img src="/../../images\db_index_2.webp" style="zoom:70%;" /><h2 id="什么时候需要-不需要创建索引"><a href="#什么时候需要-不需要创建索引" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引"></a>什么时候需要 &#x2F; 不需要创建索引</h2><h3 id="索引的优点和代价"><a href="#索引的优点和代价" class="headerlink" title="索引的优点和代价"></a>索引的优点和代价</h3><p>索引最大的好处是<strong>提高查询速度</strong>，但是索引也是有缺点的，比如：</p><ul><li>需要<strong>占用物理空间</strong>，数量越大，占用空间越大；</li><li><strong>会降低表的增删改的效率</strong>，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul><li><p><strong>经常用于 <code>WHERE</code> 查询条件的字段</strong>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</p></li><li><p><strong>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段</strong>，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了<strong>建立索引之后在 B+Tree 中的记录都是排序好的</strong>。</p></li></ul><h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul><li><strong><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li><strong>字段中存在大量重复数据</strong>，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li><strong>表数据太少的时候</strong>，不需要创建索引；</li><li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>索引失效的情况</p><ul><li><strong>使用左或者左右模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li><strong>联合索引要能正确使用需要遵循最左匹配原则</strong>，也就是按照<strong>最左优先</strong>的方式进行索引的匹配，否则就会导致索引失效。（原因是<strong>建立联合索引是按照字段顺序排序的</strong>，即先按照第一个字段排序，第一个字段相同时按第二个字段排序。所以当<strong>前几个字段没有指定时后面的字段是无序的</strong>）</li><li><strong>在查询条件中对索引列使用函数</strong>，就会导致索引失效。</li><li><strong>在查询条件中对索引列进行表达式计算</strong>，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会<strong>发生隐式类型转换</strong>，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>在 WHERE 子句中，<strong>如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。</li></ul><h2 id="优化索引方法"><a href="#优化索引方法" class="headerlink" title="优化索引方法"></a>优化索引方法</h2><h3 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h3><p><strong>使用某个字段中字符串的前几个字符建立索引</strong>。使用前缀索引是<strong>为了减小索引字段大小</strong>，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>在 MySQL 中，创建前缀索引时，<strong>指定索引的前缀长度</strong>。例如，如果有一个 name 字段，并且只对前 10 个字符建立索引，可以这样定义前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_prefix <span class="keyword">ON</span> users (name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，<strong>在索引 B+Tree 的叶子节点上都能找得到的那些索引</strong>，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以<strong>避免回表</strong>的操作</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以<strong>建立一个联合索引</strong>，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就<strong>减少了大量的 I&#x2F;O 操作</strong>。</p><h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p><strong>当因为查询条件写法问题，或者存储引擎认为该字段区分度不高时就会索引失效</strong>，转而进行全表扫描</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础（一）基础方法与概念（线性回归为例）</title>
      <link href="/2025/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-选择合适的模型"><a href="#1-选择合适的模型" class="headerlink" title="1. 选择合适的模型"></a>1. 选择合适的模型</h2><p>对于回归或分类问题使用合适的模型，在本文中对于回归问题使用<strong>线形回归</strong>模型，对于分类问题使用<strong>Logistic回归</strong>模型</p><h2 id="2-如何判定当前模型及参数是符合现实要求的（Cost-Function）"><a href="#2-如何判定当前模型及参数是符合现实要求的（Cost-Function）" class="headerlink" title="2. 如何判定当前模型及参数是符合现实要求的（Cost Function）"></a>2. 如何判定当前模型及参数是符合现实要求的（Cost Function）</h2><p>$$<br>J(w,b) &#x3D; \frac{1}{2m} \sum\limits_{i &#x3D; 0}^{m-1} (f_{w,b}(x^{(i)}) - y^{(i)})^2<br>$$</p><p>$$<br>f_{w,b}(x^{(i)}) &#x3D; wx^{(i)} + b \tag{2}<br>$$</p><p>计算预测值与现实值的均方误差后取平均（除以2是为了在求导时与平方的2约去）</p><h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3. 数据预处理"></a>3. 数据预处理</h2><h4 id="特征缩放（Feature-Scaling）"><a href="#特征缩放（Feature-Scaling）" class="headerlink" title="特征缩放（Feature Scaling）"></a>特征缩放（Feature Scaling）</h4><p>如果不同属性的取值返回相差过大则会导致模型收敛得很慢，所以要对属性值做映射。</p><p>常用缩放方法：<br><strong>均值标准化</strong><br>$$<br>x_i :&#x3D; \dfrac{x_i - \mu_i}{max - min}\tag{Mean normalization}<br>$$</p><p><strong>z-score标准化（正态分布）</strong><br>$$<br>x^{(i)}_j &#x3D; \dfrac{x^{(i)}_j - \mu_j}{\sigma_j} \tag{z-score normalization}<br>$$</p><h2 id="4-如何调整模型参数"><a href="#4-如何调整模型参数" class="headerlink" title="4. 如何调整模型参数"></a>4. 如何调整模型参数</h2><h3 id="学习方法（梯度下降学习法（Gradient-Descent））"><a href="#学习方法（梯度下降学习法（Gradient-Descent））" class="headerlink" title="学习方法（梯度下降学习法（Gradient Descent））"></a>学习方法（梯度下降学习法（Gradient Descent））</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>梯度下降是一种优化算法，用于<strong>最小化目标函数（如损失函数）并找到函数的最优参数</strong>。它是机器学习和深度学习中训练模型的核心方法。将<strong>参数更新为原值 ➖偏移量【学习率Learning Rate✖️损失函数对该参数的偏导数】</strong>，直到偏导数为0</p><img src="/../../images/gradient_algo_1.png"  style="zoom:25%;" /><h4 id="直观表示"><a href="#直观表示" class="headerlink" title="直观表示"></a>直观表示</h4><p><strong>目标是使代价函数J(w)最小，即图中函数的最低点</strong>。偏导数在几何上<strong>为在平面上点的切线</strong></p><img src="/../../images/gradient_algo_2.png"  style="zoom:25%;" /><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><img src="/../../images/gradient_algo_3.png"  style="zoom:25%;" /><h4 id="如何设置合适的学习率（Learning-Rate）"><a href="#如何设置合适的学习率（Learning-Rate）" class="headerlink" title="如何设置合适的学习率（Learning Rate）"></a>如何设置合适的学习率（Learning Rate）</h4><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率过小，则达到收敛（converge）所需的迭代次数会非常高；如果学习率过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。可尝试（0.01,0.03,0.1,0.3,1,3,10）</p><h2 id="5-什么时候算训练完成"><a href="#5-什么时候算训练完成" class="headerlink" title="5. 什么时候算训练完成"></a>5. 什么时候算训练完成</h2><p><strong>通过训练集训练参数</strong>（随着训练轮数的增加，模型在训练集上的表现总是越来越好直至收敛的），训练<strong>指定轮数后在验证集里测效果</strong>。当模型<strong>在验证集准确率到达最大值时终止训练</strong>（从趋势上看，验证集准确率会逐步上升【期间欠拟合】，到达最高点后下降【此后过拟合】）</p><p><strong>“偏差-方差分解”（bias-variance decomposition）</strong>是解释学习算法泛化性能的一种重要工具。</p><p>泛化误差可分解为偏差、方差与噪声之和：</p><ul><li><strong>偏差</strong>：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了<strong>学习算法本身的拟合能力</strong>；</li><li><strong>方差</strong>：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了<strong>数据扰动所造成的影响</strong>；</li><li><strong>噪声</strong>：表达了在当前任务上任何学习算法所能够达到的期望泛化误差的下界，即刻画了<strong>学习问题本身的难度</strong>。</li></ul><p>偏差-方差分解说明，<strong>泛化性能</strong>是由<strong>学习算法的能力</strong>、<strong>数据的充分性</strong>以及<strong>学习任务本身的难度</strong>所共同决定的。给定学习任务，为了取得好的泛化性能，则需要使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。</p><p>在<strong>欠拟合（underfitting）</strong>的情况下，出现<strong>高偏差（high bias）</strong>的情况，即不能很好地对数据进行分类。</p><p>当模型设置的太复杂时，训练集中的一些噪声没有被排除，使得模型出现<strong>过拟合（overfitting）</strong>的情况，在验证集上出现<strong>高方差（high variance）</strong>的现象。</p><p>‼️当训练出一个模型以后，如果：</p><table><thead><tr><th><strong>训练集错误率</strong></th><th><strong>验证集错误率</strong></th><th><strong>现象分析</strong></th><th><strong>可能的问题</strong></th><th><strong>解决办法</strong></th></tr></thead><tbody><tr><td>较小</td><td>较大</td><td>方差较大</td><td>可能出现了过拟合</td><td>增加数据、使用正则化（如L1、L2正则化、Dropout）、减少模型复杂度</td></tr><tr><td>较大</td><td>较大（且相当）</td><td>偏差较大</td><td>可能出现了欠拟合</td><td>增加模型复杂度（如增加参数或层数）、尝试不同模型架构、减小正则化力度</td></tr><tr><td>较大</td><td>远大于训练集</td><td>方差和偏差都较大</td><td>模型表现很差</td><td>重新设计模型、增加数据量、适当正则化或调整模型训练超参数</td></tr><tr><td>较小</td><td>较小（且相差小）</td><td>方差和偏差都较小，模型效果好</td><td>模型性能较好，适合应用场景</td><td>持续优化但避免过度调整，以保持模型的良好泛化能力</td></tr></tbody></table><h2 id="6-在学习过程中如何减少欠拟合或过拟合"><a href="#6-在学习过程中如何减少欠拟合或过拟合" class="headerlink" title="6. 在学习过程中如何减少欠拟合或过拟合"></a>6. 在学习过程中如何减少欠拟合或过拟合</h2><h3 id="欠拟合（Underfitting）"><a href="#欠拟合（Underfitting）" class="headerlink" title="欠拟合（Underfitting）"></a>欠拟合（Underfitting）</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a><strong>现象</strong></h4><p>模型无法很好地学习训练数据，表现为训练集和测试集的误差都较高。通常是因为模型复杂度不足或训练不足导致</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul><li><p><strong>增加模型复杂度</strong>：选择更复杂的模型（例如，增加深度神经网络的层数或神经元数量）；使用更强的算法（如从线性回归换成多项式回归）</p></li><li><p><strong>增加特征数量</strong>：提取更多相关的特征，或者进行特征组合</p></li><li><p><strong>降低正则化力度</strong>：减小正则化参数（如L1&#x2F;L2正则化的系数）</p></li></ul><h3 id="过拟合（Overfitting）"><a href="#过拟合（Overfitting）" class="headerlink" title="过拟合（Overfitting）"></a><strong>过拟合（Overfitting）</strong></h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a><strong>现象</strong></h4><p>模型对训练数据学习过度，对测试数据表现较差。通常是因为模型复杂度过高或训练数据不足导致。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><ul><li><strong>增加训练数据</strong>：通过数据增强（Data Augmentation）生成更多样本；从外部来源获取更多数据</li><li><strong>减少模型复杂度</strong>：减少模型的层数或神经元数量；使用简单的算法（如减少决策树的深度）</li><li><strong>正则化</strong>：增加L1或L2正则化（权重惩罚）；使用 Dropout 随机丢弃神经元</li><li><strong>交叉验证</strong>：使用交叉验证选择最合适的模型和超参数</li><li><strong>早停法（Early Stopping）</strong>：在验证集性能不再提升时停止训练</li><li><strong>降低特征数量</strong>：通过特征选择或降维（如PCA）降低特征数量</li></ul><h4 id="正则化（Regularization）"><a href="#正则化（Regularization）" class="headerlink" title="正则化（Regularization）"></a>正则化（Regularization）</h4><p>为了减少因模型过于复杂而导致的过拟合，那就需要减少模型的复杂程度。一种直观的想法是舍弃一些不重要的属性，但这往往很难达到，因为这依赖于人的经验，相当于引入了不可控因素。而比较好的方法是<strong>在cost function中加入对模型复杂度的考虑</strong>，当模型过于复杂（即参数过大时）给予较大惩罚</p><h5 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a><strong>线性回归</strong></h5><img src="/../../images/C1_W3_LinearCostRegularized.png"  style="zoom:70%;" /><img src="/../../images/C1_W3_LinearGradientRegularized.png"  style="zoom:70%;" /><h5 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h5><img src="/../../images/C1_W3_LogisticCostRegularized.png"  style="zoom:70%;" /><img src="/../../images/C1_W3_LogisticGradientRegularized.png"  style="zoom:70%;" /><h2 id="0-数据划分（训练集-验证集-测试集）"><a href="#0-数据划分（训练集-验证集-测试集）" class="headerlink" title="0. 数据划分（训练集&#x2F;验证集&#x2F;测试集）"></a>0. 数据划分（训练集&#x2F;验证集&#x2F;测试集）</h2><p>应用深度学习是一个典型的迭代过程</p><p>对于一个需要解决的问题的样本数据，在建立模型的过程中，数据会被划分为以下几个部分：</p><ul><li>训练集（train set）：用训练集对算法或模型进行<strong>训练</strong>过程；</li><li>验证集（development set）：利用验证集（又称为简单交叉验证集，hold-out cross validation set）进行<strong>交叉验证</strong>，<strong>选择出最好的模型</strong>；</li><li>测试集（test set）：最后利用测试集对模型进行测试，<strong>获取模型运行的无偏估计</strong>（对学习方法进行评估）。</li></ul><p>在<strong>小数据量</strong>的时代，如 100、1000、10000 的数据量大小，可以将数据集按照以下比例进行划分：</p><ul><li>无验证集的情况：70% &#x2F; 30%；</li><li>有验证集的情况：60% &#x2F; 20% &#x2F; 20%；</li></ul><p>而在如今的<strong>大数据时代</strong>，对于一个问题，我们拥有的数据集的规模可能是百万级别的，所以验证集和测试集所占的比重会趋向于变得更小。</p><p>验证集的目的是为了验证不同的算法哪种更加有效，所以验证集只要足够大到能够验证大约 2-10 种算法哪种更好，而不需要使用 20% 的数据作为验证集。如百万数据中抽取 1 万的数据作为验证集就可以了。</p><p>测试集的主要目的是评估模型的效果，如在单个分类器中，往往在百万级别的数据中，我们选择其中 1000 条数据足以评估单个模型的效果。</p><ul><li>100 万数据量：98% &#x2F; 1% &#x2F; 1%；</li><li>超百万数据量：99.5% &#x2F; 0.25% &#x2F; 0.25%（或者99.5% &#x2F; 0.4% &#x2F; 0.1%）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图算法（DFS与BFS）</title>
      <link href="/2025/01/21/%E5%9B%BE%E7%AE%97%E6%B3%95%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/"/>
      <url>/2025/01/21/%E5%9B%BE%E7%AE%97%E6%B3%95%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="图的建立"><a href="#图的建立" class="headerlink" title="图的建立"></a>图的建立</h2><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">build_tree_with_table</span>(<span class="type">int</span> node_count,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; prerequisites)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(node_count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;prerequisites.<span class="built_in">size</span>();i++)</span><br><span class="line">        graph[prerequisites[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">build_tree_with_martix</span>(<span class="type">int</span> node_count,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; prerequisites)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(node_count,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(node_count,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;prerequisites.<span class="built_in">size</span>();i++)</span><br><span class="line">        graph[prerequisites[i][<span class="number">0</span>]][prerequisites[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历（获取所有路径）"><a href="#图的遍历（获取所有路径）" class="headerlink" title="图的遍历（获取所有路径）"></a>图的遍历（获取所有路径）</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>使用<code>on_path</code><strong>判断当前访问的结点是否在当前访问列表中</strong>，如果在则表示<strong>有环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path_lists;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; on_path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse_dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph,<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (src &lt; <span class="number">0</span> || src &gt;= graph.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (on_path[start] == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(start);</span><br><span class="line">    on_path[start] = <span class="literal">true</span>;</span><br><span class="line">    path_lists.<span class="built_in">push_back</span>(path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[start].<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">traverse_dfs</span>(graph, graph[start][i]);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    on_path[start] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断图是否有环"><a href="#判断图是否有环" class="headerlink" title="判断图是否有环"></a>判断图是否有环</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><p>使用图的遍历DFS算法，<code>if (on_path[start] == true)</code>时给<code>has_circle</code>赋True</p><p>另外，使用了<strong>is_visited_list</strong>。假设现在以节点 <code>2</code> 为起点遍历所有可达的路径，最终发现没有环。</p><p>假设另一个节点 <code>5</code> 有一条指向 <code>2</code> 的边，你在以 <code>5</code> 为起点遍历所有可达的路径时，肯定还会走到 <code>2</code>，此时是否还需要继续遍历 <code>2</code> 的所有可达路径呢？答案是不需要了，因为<strong>第一次没找到环，那么这次也不可能找到环</strong></p><p>所以，<strong>如果发现一个节点之前被遍历过，就可以直接跳过，不用再重复遍历了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> has_circle;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; is_visited_list;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; on_path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || start &gt;= graph.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (has_circle)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// on_path的判断与is_visited_list的判断不能颠倒</span></span><br><span class="line">    <span class="comment">// 因为组成环的结点一定是之前访问过的，即is_visited_list中的结点，所以会直接返回而不判断是否成环</span></span><br><span class="line">    <span class="keyword">if</span> (on_path[start] == <span class="literal">true</span>) &#123;</span><br><span class="line">        has_circle = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_visited_list[start] == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    on_path[start] = <span class="literal">true</span>;</span><br><span class="line">    is_visited_list[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[start].<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">traverse</span>(graph, graph[start][i]);</span><br><span class="line">    on_path[start] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    is_visited_list.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">    on_path.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">    has_circle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph =</span><br><span class="line">        <span class="built_in">build_tree_with_table</span>(numCourses, prerequisites);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">    <span class="keyword">return</span> !has_circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>使用<strong>拓扑排序</strong>，遍历序列即为<strong>拓扑排序序列</strong>。如果完成遍历后<strong>还有结点没有被遍历则存在环</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = <span class="built_in">build_tree_with_table</span>(numCourses,prerequisites);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_visited_list</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// get indegree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            indegree[graph[i][j]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indegree.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> traverse_node_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">        is_visited_list[top] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        traverse_node_count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[top].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            indegree[graph[top][i]]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[graph[top][i]] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(graph[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (traverse_node_count != graph.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> !<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h3><p><strong>拓扑排序序列为DFS后序遍历序列取倒置</strong>。可以这样理解，后序遍历为左-&gt;右-&gt;根。遍历完左右子树之后才会执行后序遍历位置的代码。换句话说，当左右子树的节点都被装到结果列表里面了，根节点才会被装进去。</p><p><strong>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行</strong>。</p><img src="/../../images/topu.jpeg"  style="zoom:40%;" /><p>倒置后即为拓扑排序序列，使用<code>reverse(path.begin(),path.end())</code>函数实现</p><img src="/../../images/topu_2.jpeg"  style="zoom:40%;" /><p>由于为图的后序遍历，所以在邻居结点都被访问后才把当前结点加入遍历序列。这里的<code>is_visited_list</code>防止结点被重复访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> has_circle;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; is_visited_list;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; on_path;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || start &gt;= graph.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (has_circle)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// on_path的判断与is_visited_list的判断不能颠倒</span></span><br><span class="line">    <span class="comment">// 因为组成环的结点一定是之前访问过的，即is_visited_list中的结点，所以会直接返回而不判断是否成环</span></span><br><span class="line">    <span class="keyword">if</span> (on_path[start] == <span class="literal">true</span>) &#123;</span><br><span class="line">        has_circle = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_visited_list[start] == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    on_path[start] = <span class="literal">true</span>;</span><br><span class="line">    is_visited_list[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[start].<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">traverse</span>(graph, graph[start][i]);</span><br><span class="line">    on_path[start] = <span class="literal">false</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">            is_visited_list.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">    on_path.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">    has_circle = <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph =</span><br><span class="line">        <span class="built_in">build_tree_with_table</span>(numCourses, prerequisites);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">    <span class="keyword">if</span> (has_circle)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; null_vec = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> null_vec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(),path.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><p><strong>同判断图是否有环的BFS实现</strong>，修改下返回值为<code>path</code>遍历序列即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础（二）神经网络</title>
      <link href="/2025/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2025/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>竖向堆叠起来的输入特征被称作神经网络的<strong>输入层（the input layer）</strong>。</p><p>神经网络的<strong>隐藏层（a hidden layer）</strong>。“隐藏”的含义是<strong>在训练集中</strong>，这些中间节点的真正数值是无法看到的。</p><p><strong>输出层（the output layer）</strong>负责输出预测值。</p><img src="/../../images/single_hidden_layer_neural_network.png"  style="zoom:70%;" /><h3 id="正向传播（推理）"><a href="#正向传播（推理）" class="headerlink" title="正向传播（推理）"></a>正向传播（推理）</h3><p><strong>概念</strong></p><p>通过线性回归对不同的输入x计算，之后通过激活函数（Activation Function）映射后输出到下一层</p><img src="/../../images/neural_network_like_logistic.png"  style="zoom:70%;" /><p><strong>激活函数</strong></p><ol><li><p>Sigmoid函数【图1】</p><p>将取值映射到0与1之间</p></li></ol><p>$$<br>g(z) &#x3D; \frac{1}{1+e^{-z}}<br>$$</p><ol start="2"><li>ReLU 函数（the rectified linear unit，修正线性单元）【图3】</li></ol><p>$$<br>a&#x3D;max(0,z)<br>$$</p><p>当 z &gt; 0 时，梯度始终为 1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于 sigmoid 和 tanh。然而当 z &lt; 0 时，梯度一直为 0，但是实际的运用中，该缺陷的影响不是很大。</p><img src="/../../images/The_activation_function.png"  style="zoom:70%;" /><h2 id="反向传播（参数更新）"><a href="#反向传播（参数更新）" class="headerlink" title="反向传播（参数更新）"></a>反向传播（参数更新）</h2><p>采用<strong>梯度下降</strong>方法，对损失函数的不同参数求偏导以调整参数的值。因为涉及到多层且损失函数是隐函数的形式故可采用<strong>链式求导法则</strong>计算偏导，即<strong>反向传播</strong></p><img src="/../../images/bp.png"  style="zoom:35%;" /><h2 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="梯度消失与梯度爆炸"><a href="#梯度消失与梯度爆炸" class="headerlink" title="梯度消失与梯度爆炸"></a>梯度消失与梯度爆炸</h3><table><thead><tr><th><strong>问题</strong></th><th><strong>定义</strong></th><th><strong>原因</strong></th><th><strong>影响</strong></th><th><strong>解决方法</strong></th></tr></thead><tbody><tr><td><strong>梯度消失</strong></td><td>在反向传播中，梯度逐层传递时变得越来越小，最终接近于 0，导致模型无法有效更新权重。</td><td>激活函数（如 sigmoid、tanh）在其输入绝对值较大时梯度趋于 0；深层网络导致链式求导中多次相乘使梯度衰减。</td><td>模型训练停滞，尤其是深层网络，导致学习能力下降，权重无法更新。</td><td>使用 ReLU 激活函数；参数初始化方法（如 Xavier 或 He 初始化）；使用残差网络（ResNet）；梯度裁剪。</td></tr><tr><td><strong>梯度爆炸</strong></td><td>在反向传播中，梯度逐层传递时变得越来越大，导致梯度发散，参数更新不稳定。</td><td>网络权重初始化过大；深层网络导致链式求导中多次相乘使梯度指数增长；优化器学习率过大。</td><td>参数变为 NaN 或无穷大；损失函数发散，模型无法收敛。</td><td>使用梯度裁剪；参数初始化方法（如 Xavier 或 He 初始化）；使用适当的学习率；归一化输入数据；使用更稳定的优化器。</td></tr></tbody></table><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="降低过拟合"><a href="#降低过拟合" class="headerlink" title="降低过拟合"></a>降低过拟合</h3><h4 id="dropout正则化"><a href="#dropout正则化" class="headerlink" title="dropout正则化"></a>dropout正则化</h4><p><strong>dropout（随机失活）</strong>是在神经网络的隐藏层为每个神经元结点设置一个随机消除的概率，保留下来的神经元形成一个结点较少、规模较小的网络用于训练。dropout 正则化较多地被使用在<strong>计算机视觉（Computer Vision）</strong>领域</p><p>在<strong>正向传播</strong>过程中按照keep_prob概率随机使用部分神经元，再通过缩放因子<br>$$<br>\frac{1}{1-p}<br>$$<br>用来保证在丢弃后，激活值的期望与不使用 Dropout 时保持一致</p><p>在<strong>反向传播</strong>过程中，使用相同的神经元进行参数的更新</p><p>所以，通过dropout方法，使得<strong>模型不过度依赖任何一个神经元</strong>，以此<strong>实现网络更加鲁棒，避免过拟合，提升模型的泛化能力</strong></p><h3 id="加快收敛速度"><a href="#加快收敛速度" class="headerlink" title="加快收敛速度"></a>加快收敛速度</h3><h4 id="mini-batch-梯度下降法"><a href="#mini-batch-梯度下降法" class="headerlink" title="mini-batch 梯度下降法"></a>mini-batch 梯度下降法</h4><p>mini-Batch 梯度下降法（小批量梯度下降法）：对于batch_1，使用传统的梯度下降法得到模型M1；使用M1对batch_2使用传统的梯度下降法，依此类推。一直遍历每个batch直到模型收敛</p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>batch_size &#x3D; 1（SGD）</strong></th><th><strong>batch_size &#x3D; 任意值（Mini-batch）</strong></th><th><strong>batch_size &#x3D; 训练集大小（全批量梯度下降）</strong></th></tr></thead><tbody><tr><td><strong>梯度估计</strong></td><td>基于单个样本计算梯度，梯度噪声大，不稳定。</td><td>基于一个批量样本计算梯度，噪声较小，梯度稳定性较高。</td><td>基于整个训练集计算梯度，梯度无噪声，最稳定。</td></tr><tr><td><strong>计算效率</strong></td><td>每次更新都很快，但无法利用并行计算，整体效率低。</td><td>利用并行计算，提高计算效率，但 batch 越大，时间越长。</td><td>计算效率最低，需要遍历整个训练集。</td></tr><tr><td><strong>内存需求</strong></td><td>内存需求最低，仅需存储单个样本的计算图。</td><td>内存需求随 batch_size 增加而增加，受硬件限制。</td><td>内存需求最高，可能超出内存容量。</td></tr><tr><td><strong>收敛速度</strong></td><td>更新频率高，但震荡明显，可能需要更多迭代才能收敛。</td><td>更新频率适中，收敛平稳，较快接近最优解。</td><td>更新频率低，但每次更新准确，收敛稳定但速度慢。</td></tr><tr><td><strong>噪声控制</strong></td><td>噪声较大，可能导致模型困于局部最优解或震荡。</td><td>有一定噪声，适度提升泛化能力，平衡计算效率和噪声。</td><td>噪声最小，更新方向最准确，但可能导致过拟合。</td></tr><tr><td><strong>泛化能力</strong></td><td>噪声大有助于跳出局部最优，泛化能力稍强。</td><td>噪声适中，泛化能力良好。</td><td>无噪声，可能过拟合训练集，泛化能力稍弱。</td></tr><tr><td><strong>适用场景</strong></td><td>数据量大、硬件限制较多时适用，或需要探索模型时使用。</td><td>常用训练方式，适合平衡硬件资源和训练效率的场景。</td><td>精度要求高、硬件资源充足时适用，如小型数据集。</td></tr></tbody></table><h1 id="CNN（卷积神经网络）"><a href="#CNN（卷积神经网络）" class="headerlink" title="CNN（卷积神经网络）"></a>CNN（卷积神经网络）</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>应用计算机视觉时要面临的一个挑战是数据的输入可能会非常大。例如一张 1000x1000x3 的图片，神经网络输入层的维度将高达三百万，使得网络权重 W 非常庞大。这样会造成两个后果：</p><ol><li>神经网络结构复杂，数据量相对较少，容易出现过拟合；</li><li>所需内存和计算量巨大。</li></ol><p>因此，一般的神经网络很难处理蕴含着大量数据的图像。解决这一问题的方法就是使用<strong>卷积神经网络（Convolutional Neural Network, CNN）</strong>。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>卷积运算</strong></p><p>通过每个小矩阵与卷积核做点乘得到特征图（feature map）。其作用主要为</p><ol><li><strong>特征提取</strong></li></ol><ul><li>卷积运算通过卷积核（filter 或 kernel）与输入数据进行滑动计算，提取局部区域的特征（如边缘、纹理等）</li><li>每个卷积核可以学习不同的特征，多个卷积核共同构成了丰富的特征表达能力</li></ul><ol start="2"><li><strong>降维或特征压缩</strong></li></ol><ul><li>通过卷积核的步幅（stride）和无填充（valid padding）操作，卷积结果的空间维度可以减小，从而达到特征压缩的效果。</li></ul><img src="https://raw.githubusercontent.com/bighuang624/Andrew-Ng-Deep-Learning-notes/master/docs/Convolutional_Neural_Networks/Convolutional-operation.jpg" data-origin="https://raw.githubusercontent.com/bighuang624/Andrew-Ng-Deep-Learning-notes/master/docs/Convolutional_Neural_Networks/Convolutional-operation.jpg" alt="Convolutional-operation"><img src="/../../images/One-Layer-of-a-Convolutional-Network.jpg"  style="zoom:100%;" /><p><strong>池化运算</strong></p><p>对于卷积运算后的结果进行特征提取，常用的池化方法为最大池化。其作用主要为</p><ol><li><strong>特征提取</strong></li><li><strong>防止过拟合</strong>：通过采样只提取关键特征，提高泛化能力</li></ol><img src="/../../images/Max-Pooling.png"  style="zoom:70%;" /><p><strong>全连接层</strong></p><p>将上一层矩阵输出为一维向量后通过当前层的n个神经元训练，训练方式同基础的神经网络，包含线性方程计算后经过激活函数映射后输出</p><h3 id="例子（LeNet-5）"><a href="#例子（LeNet-5）" class="headerlink" title="例子（LeNet-5）"></a>例子（LeNet-5）</h3><p>输入层——卷积层1——池化层_1——卷积层2——池化层2——全连接层3——全连接层4——输出层</p><img src="/../../images/CNN.png"  style="zoom:30%;" /><h3 id="使用卷积的原因"><a href="#使用卷积的原因" class="headerlink" title="使用卷积的原因"></a>使用卷积的原因</h3><p>相比标准神经网络，对于大量的输入数据，卷积过程有效地减少了 CNN 的参数数量，原因有以下两点：</p><ul><li><strong>参数共享（Parameter sharing）</strong>：特征检测如果适用于图片的某个区域，那么它也可能适用于图片的其他区域。即在卷积过程中，不管输入有多大，一个特征探测器（滤波器）就能对整个输入的某一特征进行探测。</li><li><strong>稀疏连接（Sparsity of connections）</strong>：在每一层中，由于滤波器的尺寸限制，输入和输出之间的连接是稀疏的，每个输出值只取决于输入在局部的一小部分值。</li></ul><p>池化过程则在卷积后很好地聚合了特征，通过降维来减少运算量。</p><p>由于 CNN 参数数量较小，所需的训练样本就相对较少，因此在一定程度上不容易发生过拟合现象。并且 CNN 比较擅长捕捉区域位置偏移。即进行物体检测时，不太受物体在图片中位置的影响，增加检测的准确性和系统的健壮性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Neural_Networks_and_Deep_Learning">某个大佬的吴恩达课程笔记整理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树算法（回溯，动态规划，迭代）</title>
      <link href="/2025/01/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%BF%AD%E4%BB%A3%EF%BC%89/"/>
      <url>/2025/01/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%BF%AD%E4%BB%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>二叉树题型的算法主要分为<strong>回溯，动态规划，迭代</strong>三类。从本质上三者都是在遍历算法基础上的修改。<strong>回溯</strong>关心的是在<strong>每个结点的访问过程中如何更新结果</strong>；动态规划关心的是<strong>如何拆解出子问题，不具体分析每个结点的状态，而是通过划分子问题让其通过基本问题递归解决</strong>；迭代主要是指<strong>BFS层序遍历</strong>，适用于与深度（或高度）相关的问题求解</p><h2 id="二叉树基本结构"><a href="#二叉树基本结构" class="headerlink" title="二叉树基本结构"></a>二叉树基本结构</h2><ol><li>二叉树</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>多叉树</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TreeNode *&gt; children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ol><li>递归遍历</li></ol><p>前序位置：刚进入当前子树根结点的时候（已知根结点信息）</p><p>中序位置：访问完左子树后，准备访问右子树的时候（已知根，左孩子结点信息）</p><p>后序位置：访问完左右子树后的，回溯到当前子树根结点的时候（已知根，左孩子，右孩子结点信息）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>层序遍历</li></ol><p>通过对每层访问后完后栈内元素个数的统计可以实现层数的更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树题型解法"><a href="#二叉树题型解法" class="headerlink" title="二叉树题型解法"></a>二叉树题型解法</h2><h3 id="回溯（DFS）"><a href="#回溯（DFS）" class="headerlink" title="回溯（DFS）"></a>回溯（DFS）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><strong>回溯</strong>关心的是在<strong>每个结点的访问过程中如何更新结果</strong>，着眼点在<strong>结点间移动的过程</strong></p><p>在求解过程中<strong>假定当前处理的为其中一颗子树</strong>，考虑两个问题：</p><ol><li>前&#x2F;中序位置：<strong>进入当前层后要做的事</strong></li><li>后序位置：<strong>回溯到父结点前要做的事</strong></li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h5><p>在结点访问时更新depth，如果为根结点则表示为可能的当前子树深度最大值，更新全局最大深度<strong>（进入时）</strong>。当返回到父结点前，表示当前子树已经遍历完成，父结点的depth应为当前depth-1<strong>（回溯前）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        max_depth=<span class="built_in">max</span>(max_depth,depth);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(root);</span><br><span class="line">    <span class="keyword">return</span> max_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划（分解子问题）"><a href="#动态规划（分解子问题）" class="headerlink" title="动态规划（分解子问题）"></a>动态规划（分解子问题）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>动态规划关心的是<strong>如何拆解出子问题，不具体分析每个结点的状态，而是通过划分子问题让其通过基本问题递归解决</strong>，着眼点在<strong>结构相同的子问题</strong></p><p>在求解过程中需要考虑三个问题</p><ol><li><strong>确定问题</strong>：给当前的计算过程一种解释</li><li><strong>解决基准问题</strong>：思考当输入值为基础值时，其返回的结果是什么。该步用于<strong>确定递归终止条件</strong></li><li><strong>拆解问题</strong>：考虑在当前的普通输入时，应该如何解决问题</li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><h5 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h5><ol><li><strong>确定问题</strong>：计算以root为根结点的二叉树的最大深度并返回最大深度</li><li><strong>解决基准问题</strong>：当root为空指针时，表示该树空，返回0</li><li><strong>拆解问题</strong>：当前结点的最大深度即为左右子树中的最大深度+1，所以只需要获取左右子树的最大深度后+1即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_max_depth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right_max_depth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_max_depth,right_max_depth)<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代（BFS）"><a href="#迭代（BFS）" class="headerlink" title="迭代（BFS）"></a>迭代（BFS）</h3><p>同上二叉树层序遍历</p><h2 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h2><h3 id="已知完全二叉树数组"><a href="#已知完全二叉树数组" class="headerlink" title="已知完全二叉树数组"></a>已知完全二叉树数组</h3><p>可以看作<strong>动态规划</strong>的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归构造二叉树，处理空节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build_tree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 越界或遇到空节点值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= arr.<span class="built_in">size</span>() || arr[index] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建当前节点</span></span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(arr[index]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构造左、右子树</span></span><br><span class="line">    node-&gt;left = <span class="built_in">build_tree</span>(arr, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">build_tree</span>(arr, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知前序序列和中序序列"><a href="#已知前序序列和中序序列" class="headerlink" title="已知前序序列和中序序列"></a>已知前序序列和中序序列</h3><p>主要任务是分隔出左右子树的区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造以root为根结点的二叉树，返回root</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build_tree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> p_start, <span class="type">int</span> p_end, <span class="type">int</span> i_start, <span class="type">int</span> i_end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_start &lt; <span class="number">0</span> || p_end &gt;= preorder.<span class="built_in">size</span>() || i_start &lt; <span class="number">0</span> ||</span><br><span class="line">        i_end &gt;= inorder.<span class="built_in">size</span>() || p_start &gt; p_end || i_start &gt; i_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[p_start]);</span><br><span class="line">    <span class="type">int</span> root_val_idx_in_inorder = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i_start; j &lt;= i_end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[j] == preorder[p_start]) &#123;</span><br><span class="line">            root_val_idx_in_inorder = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left_node_count = <span class="built_in">max</span>(<span class="number">0</span>,root_val_idx_in_inorder - i_start);</span><br><span class="line">    <span class="type">int</span> node_count = i_end - i_start + <span class="number">1</span>; <span class="comment">// include root</span></span><br><span class="line">    <span class="type">int</span> right_node_count = node_count - left_node_count - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    root-&gt;left =</span><br><span class="line">        <span class="built_in">build_tree</span>(preorder, inorder, p_start<span class="number">+1</span>, p_start+left_node_count,</span><br><span class="line">                   i_start, root_val_idx_in_inorder - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right =</span><br><span class="line">        <span class="built_in">build_tree</span>(preorder, inorder, p_start + left_node_count + <span class="number">1</span>, p_end,</span><br><span class="line">                   root_val_idx_in_inorder<span class="number">+1</span>, i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    root = <span class="built_in">build_tree</span>(preorder, inorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已知前序序列构建二叉搜索树"><a href="#已知前序序列构建二叉搜索树" class="headerlink" title="已知前序序列构建二叉搜索树"></a>已知前序序列构建二叉搜索树</h3><p>主要任务是分隔出左右子树的区间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">build_tree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> p_start,<span class="type">int</span> p_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_start&lt;<span class="number">0</span>||p_end&gt;=preorder.<span class="built_in">size</span>()||p_start&gt;p_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[p_start]);</span><br><span class="line">    <span class="type">int</span> right_tree_start_idx = p_end<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=p_start;i&lt;=p_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder[i] &gt; preorder[p_start])</span><br><span class="line">        &#123;</span><br><span class="line">            right_tree_start_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = <span class="built_in">build_tree</span>(preorder,p_start<span class="number">+1</span>,right_tree_start_idx<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">build_tree</span>(preorder,right_tree_start_idx,p_end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    root = <span class="built_in">build_tree</span>(preorder, <span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2025/01/18/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2025/01/18/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯框架"><a href="#回溯框架" class="headerlink" title="回溯框架"></a>回溯框架</h2><h3 id="回溯算法求解时要考虑三个问题"><a href="#回溯算法求解时要考虑三个问题" class="headerlink" title="回溯算法求解时要考虑三个问题"></a>回溯算法求解时要考虑三个问题</h3><ol><li><strong>路径</strong>：已经做出的选择</li><li><strong>选择列表</strong>：当前可以做的选择，即<strong>孩子结点的情况</strong>（<strong>剪枝</strong>做的就是精简孩子结点，避免重复讨论，反映到代码里就是<strong>对于某些情况直接continue调过</strong>）</li><li><strong>结束条件</strong>：何时到达决策树的底层，返回结果</li></ol><p><strong>求解的关键在于画出决策树，并运用合理的剪枝条件。不要跳出此框架自己去想新写法，很容易漏解或者多解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="排列问题（元素不重复不可复选）"><a href="#排列问题（元素不重复不可复选）" class="headerlink" title="排列问题（元素不重复不可复选）"></a>排列问题（元素不重复不可复选）</h3><p><strong>选择列表</strong>：避免选当前路径上已经选择过的数字</p><p><strong>解决方法</strong>：引入used数组，记录从根结点到当前结点的路径信息，判断数字是否被使用</p><img src="/../../images/P.png"  style="zoom:40%;" /><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case，到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (track.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 收集叶子节点上的值</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(track.<span class="built_in">begin</span>(), track.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 已经存在 track 中的元素，不能重复选择</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层回溯树</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合问题（元素不重复不可复选）"><a href="#组合问题（元素不重复不可复选）" class="headerlink" title="组合问题（元素不重复不可复选）"></a>组合问题（元素不重复不可复选）</h3><p><strong>选择列表</strong>：避免选只是顺序不同的相同元素序列</p><p><strong>解决方案</strong>：通过保证元素之间的相对顺序不变来防止出现重复的子集</p><img src="/../../images/C.png"  style="zoom:40%;" /><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C(n,k)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (k == track.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 遍历到了第 k 层，收集当前节点的值</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(track.<span class="built_in">begin</span>(), track.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 选择</span></span><br><span class="line">        track.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 通过 start 参数控制树枝的遍历，避免产生重复的子集</span></span><br><span class="line">        <span class="built_in">backtrack</span>(i + <span class="number">1</span>, n, k);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><ol><li><strong>子集问题与组合问题</strong>：子集问题与组合问题一样，<strong>只是结束条件不同</strong>，子集不需要<code>if (k == track.size()) </code>，每次都要收集中间结果</li><li><strong>排列问题与组合问题</strong>；排列问题要求路径上没有重复元素；组合问题除了排列的要求外，<strong>还要求元素间的相对位置不同时只取其中一种情况</strong></li></ol><h3 id="排列（元素可重不可复选）"><a href="#排列（元素可重不可复选）" class="headerlink" title="排列（元素可重不可复选）"></a>排列（元素可重不可复选）</h3><p><strong>选择列表</strong>：与基础的排列问题相同，也需要used数组来记录路径上的值。不同的是要将同值元素由于相对位置不同而造成的多余情况要排除掉</p><p><strong>解决方法</strong>：通过确保同值元素的相对位置不变来剪枝。首先对数组<strong>排序</strong>，对于同值元素，若其之前的同值元素未选取则不选择该元素</p><img src="/../../images/P_mul.png"  style="zoom:40%;" /><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合（元素可重不可复选）"><a href="#组合（元素可重不可复选）" class="headerlink" title="组合（元素可重不可复选）"></a>组合（元素可重不可复选）</h3><p><strong>选择列表</strong>：与基础的组合问题相同，也需要规定元素的相对位置不变。不同的是要将同一层出现同值元素而造成的多余情况要排除掉</p><p><strong>解决方法</strong>：通过确保同值元素在每层只处理一次来剪枝。首先对数组<strong>排序</strong>，对于同值元素，若其不是同值的第一个则不处理</p><img src="/../../images/C_mul.png"  style="zoom:40%;" /><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 剪枝逻辑，值相同的相邻树枝，只遍历第一条</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="排列（元素不重复不可复选）"><a href="#排列（元素不重复不可复选）" class="headerlink" title="排列（元素不重复不可复选）"></a>排列（元素不重复不可复选）</h3><p><strong>选择列表</strong>：无限制</p><h3 id="组合（元素不重复不可复选）"><a href="#组合（元素不重复不可复选）" class="headerlink" title="组合（元素不重复不可复选）"></a>组合（元素不重复不可复选）</h3><p><strong>选择列表</strong>：增加可选当前元素的选择</p><p><strong>解决方法</strong>：下一次递归的<code>start</code>从当前元素起</p><img src="/../../images/C_more_choice.png"  style="zoom:40%;" /><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 选择 nums[i]</span></span><br><span class="line">    trackSum += nums[i];</span><br><span class="line">    track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="comment">// 递归遍历下一层回溯树</span></span><br><span class="line">    <span class="comment">// 同一元素可重复使用，注意参数</span></span><br><span class="line">    <span class="built_in">backtrack</span>(nums, i, target);</span><br><span class="line">    <span class="comment">// 撤销选择 nums[i]</span></span><br><span class="line">    trackSum -= nums[i];</span><br><span class="line">    track.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h4 id="计算岛屿的数量"><a href="#计算岛屿的数量" class="headerlink" title="计算岛屿的数量"></a>计算岛屿的数量</h4><p>题目会输入一个二维数组 <code>grid</code>，其中只包含 <code>0</code> 或者 <code>1</code>，<code>0</code> 代表海水，<code>1</code> 代表陆地，且假设该矩阵四周都是被海水包围着的。</p><img src="/../../images/island_problem.png"  style="zoom:50%;" /><p><strong>选择列表</strong>：上下左右四个方向</p><p><strong>代码实现</strong>：遍历后对已访问的元素直接置0（海水），以免维护visited数组。对四个方向递归，对于超出边界或值为0（已经访问或为海水的）直接返回。</p><p><strong>Tips</strong>：<strong>对于DFS倾向于把剪枝操作写在最前面，对于回溯倾向于把剪枝操作写在做选择前</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 遍历 grid</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 每发现一个岛屿，岛屿数量加一</span></span><br><span class="line">                res++;</span><br><span class="line">                <span class="comment">// 然后使用 DFS 将岛屿淹了</span></span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 (i, j) 开始，将与之相邻的陆地都变成海水</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n) &#123;</span><br><span class="line">        <span class="comment">// 超出索引边界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经是海水了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 (i, j) 变成海水</span></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 淹没上下左右的陆地</span></span><br><span class="line">    <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><h3 id="递归树画法"><a href="#递归树画法" class="headerlink" title="递归树画法"></a>递归树画法</h3><p><strong>先判断路径的顺序是否是不同的结果</strong>，如果不同则为排列树，否则为组合树。以此为基础再讨论后续的条件</p><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><img src="/../../images/P.png"  style="zoom:40%;" /><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><img src="/../../images/C.png"  style="zoom:40%;" /><h4 id="字串大小（组合树，131-分割回文串）"><a href="#字串大小（组合树，131-分割回文串）" class="headerlink" title="字串大小（组合树，131.分割回文串）"></a>字串大小（组合树，131.分割回文串）</h4><p>以字串作为路径</p><img src="/../../images/sub_string.png"  style="zoom:20%;" /><h3 id="剪枝方法"><a href="#剪枝方法" class="headerlink" title="剪枝方法"></a>剪枝方法</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p><strong>visited数组</strong>：判断路径上的值是否有被使用过（纵向）</p><p><strong>start索引</strong>：通过规定<strong>当前层的路径</strong>访问顺序来确保值<strong>只被使用一次</strong>（横向）</p><p><strong>path数组大小是否为0</strong>：有些情况下确保第二层路径访问不受影响</p><h4 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h4><h5 id="排列问题与组合问题"><a href="#排列问题与组合问题" class="headerlink" title="排列问题与组合问题"></a>排列问题与组合问题</h5><p><strong>排列</strong>：visited数组</p><p><strong>组合</strong>：start索引</p><h5 id="同层出现相同元素"><a href="#同层出现相同元素" class="headerlink" title="同层出现相同元素"></a>同层出现相同元素</h5><p>若<strong>可先排序</strong>，</p><p>​<strong>排列</strong>：visited数组</p><p>​<strong>组合</strong>：start索引</p><p><strong>不可先排序</strong></p><p>​<strong>使用集合去重</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; used;</span><br></pre></td></tr></table></figure><h2 id="回溯与DFS的区别"><a href="#回溯与DFS的区别" class="headerlink" title="回溯与DFS的区别"></a>回溯与DFS的区别</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>从代码角度看</strong>，<strong>回溯</strong>把做选择与撤销选择<strong>放在了遍历逻辑（for循环）里</strong>，而<strong>DFS</strong>把其<strong>放在了遍历逻辑外</strong></p><p><strong>从语意角度看</strong>，<strong>回溯更关心路径的信息；DFS更关心结点的信息</strong></p><p>❗️<strong>区分何时用回溯，何时用DFS的关键是看根结点是否有含义</strong>，有则用DFS，否则用回溯</p><h3 id="全排列问题为例"><a href="#全排列问题为例" class="headerlink" title="全排列问题为例"></a>全排列问题为例</h3><p>对于<strong>全排列问题</strong>，<strong>从递归树角度看其根结点是没有含义的</strong>。如果使用<strong>DFS</strong>，即把选择列表看作是结点，则其如下图所示</p><p>如果把其看作<strong>回溯</strong>，则如下图所示</p><img src="/../../images/P.png"  style="zoom:30%;" /><p>可见根结点是没有定义的。其只是串联第一层选择列表的作用。</p><p>此外，<strong>从代码角度看</strong>，使用<strong>DFS</strong>则对于<strong>第二层结点需要放到递归外用迭代的方式讨论（原因在于根结点无含义）</strong>，而且<strong>达到终止条件时的回溯需要额外讨论</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; is_used_list ,<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (is_used_list[cur] == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">    is_used_list[cur]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        results.<span class="built_in">push_back</span>(path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        is_used_list[cur]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">traverse</span>(nums, is_used_list,i);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    is_used_list[cur]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_used_list</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">traverse</span>(nums, is_used_list,i);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<strong>回溯</strong>算法，由于其<strong>结点表示的是当前路径的结果</strong>，选择列表里是路径的信息，所以其不会用到根结点，这样就<strong>避免了根结点无含义带来的额外处理</strong>（对比DFS时对第二层结点的处理）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (track.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(track.<span class="built_in">begin</span>(), track.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line">        track.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿问题为例"><a href="#岛屿问题为例" class="headerlink" title="岛屿问题为例"></a>岛屿问题为例</h3><p>对于<strong>岛屿问题</strong>，若使用<strong>回溯</strong>，则需要<strong>额外处理第1层的路径</strong>，递归处理的是第2到n层的路径。两者语意上是不同的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            is_visited[i][j] =<span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(word[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">backtrack</span>(board, word,<span class="number">0</span>,i,j);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            is_visited[i][j] =<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_found)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string &amp;word,<span class="type">int</span> start,<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 上</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(word[start]);</span><br><span class="line">      is_visited[i<span class="number">-1</span>][j] =<span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">backtrack</span>(board,word,start<span class="number">+1</span>,i<span class="number">-1</span>,j);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">      is_visited[i<span class="number">-1</span>][j] =<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(word[start]);</span><br><span class="line">      is_visited[i<span class="number">+1</span>][j] =<span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">backtrack</span>(board,word,start<span class="number">+1</span>,i<span class="number">+1</span>,j);</span><br><span class="line">      path.<span class="built_in">pop_back</span>();</span><br><span class="line">      is_visited[i<span class="number">+1</span>][j] =<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于<strong>DFS</strong>，则<strong>不需要对根结点做额外讨论</strong>，因为根结点本身就是有含义的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>])</span><br><span class="line">          <span class="built_in">backtrack</span>(board, word,<span class="number">0</span>,i,j);</span><br><span class="line">      <span class="keyword">if</span> (is_found)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string &amp;word,<span class="type">int</span> start,<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//...</span></span><br><span class="line">        is_visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(board, word,start<span class="number">+1</span>,i<span class="number">-1</span>,j);</span><br><span class="line">        <span class="built_in">backtrack</span>(board, word,start<span class="number">+1</span>,i<span class="number">+1</span>,j);</span><br><span class="line">        <span class="built_in">backtrack</span>(board, word,start<span class="number">+1</span>,i,j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(board, word,start<span class="number">+1</span>,i,j<span class="number">+1</span>);</span><br><span class="line">        is_visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（七）文件管理（系统调用与文件存储）</title>
      <link href="/2025/01/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/01/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h4><h5 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h5><p>在文件系统和应用程序间有一层抽象层，称为虚拟文件系统（VFS）</p><ul><li>VFS作为抽象层向应用层提供了统一的文件接口（read，write等）</li><li>VFS实现了一些公共的功能，如Directory Cache和Page Cache等</li><li>规范了接口</li></ul><p>VFS向应用层提供统一接口，具体实现不同文件系统有不同实现，VFS将函数指针指向对应函数</p><img src="/../../images/fs_architecture.png" width=500px /><h5 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h5><p><strong>文件系统的注册</strong></p><p>在Linux中，具体文件系统通常是一个内核模块，在内核模块被加载时完成文件系统的注册</p><p><strong>磁盘挂载</strong></p><p>将dentry修改为挂载点，增加上级目录inode项</p><p><strong>打开文件</strong></p><p>用户层面：传入路径，打开模式；返回文件句柄fd</p><p>系统层面：PCB创建fd，指向打开文件表（open file table）中对应内容</p><p>具体实现：</p><ol><li>应用程序调用 <strong>open 系统调用</strong>，该调用需要提供文件名和打开模式等参数。</li><li>操作系统<strong>查找保存在内存的打开文件表（open file table）</strong>中是否有该文件，如果该文件表项已经存在（例如已经打开），则检查打开模式<strong>是否允许重复打开（例如 O_EXCL）</strong>，如果不允许则直接返回该文件表项，否则返回错误信息。</li><li>如果文件表项不存在，则<strong>分配一个新的文件表项（file）加入打开文件表</strong>，并将其与相应的 vnode 或 inode 相关联。</li><li>如果打开模式<strong>允许创建新文件（例如 O_CREAT），且文件不存在，则创建一个新的 vnode 或 inode</strong>，并将其与新的文件表项相关联。</li><li>操作系统将文件表项的状态设置为打开状态，并返回该文件表项的文件描述符（file descriptor）给应用程序。</li><li>应用程序可以使用返回的文件描述符对文件进行读写等操作。</li><li>当应用程序不再需要该文件时，可以使用 close 系统调用关闭文件，操作系统会释放相应的文件表项和 vnode 或 inode。</li></ol><p><strong>读取文件</strong></p><p>用户层面：传入fd，buffer，size；返回实际读取到的字节数，buffer得到数据</p><p>系统层面：先访问pagecache，如果包含则从pagecache中读取，否则通过inode访问数据块，拷贝到pagecache然后拷贝到用户态buffer</p><p>读文件的流程如下（考虑缓存）：</p><ol><li>应用程序发起读取文件的系统调用（read()）。</li><li>如果该文件已经被打开并且缓存在 Page cache 中，则直接从 Page cache 中读取文件数据，并返回给应用程序。如果 Page cache 中没有该文件的缓存，则进入下一步操作。</li><li>内核会在虚拟内存空间中分配一个缓冲区（buffer），用于存储文件数据。然后通过文件系统的 readpage() 回调函数，从磁盘上读取文件的一页数据，存储到缓冲区中。</li><li>如果读取成功，则将读取的数据存储到 Page cache 中，并返回读取的数据给应用程序。</li><li>如果读取失败，则返回错误码给应用程序。</li><li>应用程序继续读取下一页数据，直到读取完整个文件或者出现错误为止。</li></ol><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><h5 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h5><p>将近期访问文件的inode缓存道内存中，空间满后通过<strong>LRU或LFU</strong>替换</p><h5 id="预读算法"><a href="#预读算法" class="headerlink" title="预读算法"></a>预读算法</h5><p>会比请求的数据块多读一些数据。触发条件是：</p><ul><li>当有多个地址连续的读请求时</li><li>当访问到有预读标记的缓存时</li></ul><h5 id="快照与克隆技术"><a href="#快照与克隆技术" class="headerlink" title="快照与克隆技术"></a>快照与克隆技术</h5><p><strong>快照</strong>实现文件的可读备份，有两种方法，一种是写时拷贝（COW），在做完快照后第一次对文件写会拷贝文件内容</p><p>另一种是写时重定位（ROW），原始文件写数据时不在原有位置，而是分配一个新位置，更新逻辑地址和实际位置对应关系</p><p><strong>克隆</strong>实现文件的可写备份，多用ROW实现，和快照区别是可写，数据隔离</p><p><strong>Page Cache</strong></p><p>Page cache 是 Linux 系统中的一种缓存机制，用于缓存文件系统中的数据和元数据。Page cache 以物理页的形式保存在内存中，每个物理页通常大小为 4KB 或 8KB，对应一个虚拟页（VMA）。</p><p>Page cache 包含以下内容：</p><ol><li>文件数据：Page cache 用于缓存文件系统中的数据，例如读取的文件内容。文件数据通常保存在匿名页（anonymous page）中，即没有对应的文件，只保存数据。当读取文件时，内核会将文件数据从磁盘读入匿名页中，并将该匿名页添加到 Page cache 中。</li><li>文件元数据：Page cache 还用于缓存文件系统中的元数据，例如文件属性、索引节点等。文件元数据通常保存在映射页（mapped page）中，即与文件系统中的文件或目录关联。当访问文件元数据时，内核会将该映射页从磁盘读入 Page cache 中。</li><li>Page 缓存清单：Page cache 中保存了所有 Page 缓存页的清单，每个页都有一个 struct page 结构体来描述。该结构体包含了页框地址、引用计数、状态等信息，同时还保存了与该页相关联的 vnode 或 inode 等信息。</li></ol><p>Page cache 通常存储在操作系统内核的地址空间中，通过 page struct 结构体来表示。Page cache 通过页面映射（page mapping）和内存管理单元（MMU）机制，将虚拟页映射到物理页，实现了高效的文件系统访问。同时，Page cache 的引入也避免了频繁的磁盘访问，提高了文件系统的性能</p><p><strong>日志型存储</strong></p><p>日志型存储（Log-Structured Storage）是一种文件系统存储方式，其特点是将所有文件数据写入到一个连续的、循环的、预先分配好的日志区域（Log）中，而非传统的随机分散的数据块中。</p><p>日志区域中的每个写操作都会被记录到一个日志（Log）中，这个日志记录了文件系统的所有操作，包括创建、删除、修改文件等操作。当文件系统崩溃或重启时，文件系统会依据日志中记录的操作，恢复文件系统的状态。</p><p>日志型存储的优点是：</p><ol><li><strong>写性能较高</strong>：由于所有的写操作都是顺序写入到一个连续的日志区域中，因此写性能比传统的文件系统更高。</li><li><strong>可靠性高</strong>：由于所有的写操作都是顺序写入到一个连续的日志区域中，并且每个写操作都被记录到一个日志中，因此即使文件系统发生故障，也可以通过日志来恢复文件系统的状态，数据不容易丢失。</li><li><strong>压缩效果好</strong>：由于所有文件数据都是顺序写入到一个连续的日志区域中，因此可以采用更高效的压缩算法来减少磁盘空间的使用。</li></ol><p>但是，日志型存储也有其缺点，主要包括：</p><ol><li><strong>读性能相对较低</strong>：由于文件数据是顺序存储的，因此随机读取数据的性能相对较低。</li><li><strong>文件删除和空间回收不容易</strong>：由于文件数据是顺序存储的，因此删除一个文件时，需要从日志中找到该文件的所有数据块，并标记为已删除，这个过程比较繁琐。而空间回收也需要扫描整个日志，找到所有已删除的数据块，并将其标记为可用空间。</li></ol><p>日志型存储主要应用于需要较高写性能和可靠性的场景，例如数据库存储、分布式存储等。常见的日志型文件系统包括Log-structured File System（LFS）、WAFL、Ext3cow等。</p><p><strong>EXT文件系统</strong></p><p>ext3相比ext2增加日志技术</p><p>ext4相比ext3增加extents技术，对于大文件通过保存起始位置和块数，减少大文件需要保存的元数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）文件管理</title>
      <link href="/2025/01/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="磁盘的工作原理"><a href="#磁盘的工作原理" class="headerlink" title="磁盘的工作原理"></a>磁盘的工作原理</h4><h5 id="磁盘读写的过程"><a href="#磁盘读写的过程" class="headerlink" title="磁盘读写的过程"></a>磁盘读写的过程</h5><ol><li>磁盘移动，找到要读的<strong>柱面</strong>（cylinder，简称C）</li><li>从柱面选择具体读哪个<strong>磁道</strong>（magnetic head，简称H），选择对应的磁头上电（每次只能有一个磁头上电）</li><li>旋转磁盘，将对应磁道中要读写的那个<strong>扇区</strong>（sector，简称S）转到磁头下方</li><li>开始读写，将扇区中的内容读到内存缓存区中，或者将内存缓存区中的内容写到该扇区中</li></ol><img src="/../../images/physical_disk.png" width=400px /><h4 id="生磁盘的使用"><a href="#生磁盘的使用" class="headerlink" title="生磁盘的使用"></a>生磁盘的使用</h4><h5 id="第一层抽象：从扇区到磁盘块请求（抽象读写请求）"><a href="#第一层抽象：从扇区到磁盘块请求（抽象读写请求）" class="headerlink" title="第一层抽象：从扇区到磁盘块请求（抽象读写请求）"></a>第一层抽象：从扇区到磁盘块请求（抽象读写请求）</h5><p>正常寻址需要通过<strong>CHS</strong>三维向量，但是可以通过一位扇区编号编址</p><p>磁盘读写时间 &#x3D; 寻道时间（选择柱面）+旋转时间（选择+读取扇区）+传输时间（磁生电活电生磁）</p><p>其中寻道时间占主导，故每次只读&#x2F;写一个扇区是对于时间的浪费，故一次读&#x2F;写多个扇区，称为<strong>块</strong></p><h5 id="第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）"><a href="#第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）" class="headerlink" title="第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）"></a>第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）</h5><p><strong>电梯调度算法</strong>（CSCAN），磁头向一个方向运动，运动到提交访问的边界后复位，循环往复（复位防止内&#x2F;外部块容易回复请求）</p><img src="/../../images/CSCAN.png" width=400px /><h5 id="第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）"><a href="#第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）" class="headerlink" title="第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）"></a>第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）</h5><p><strong>读缓冲</strong>：由于<strong>局部性原理</strong>，用户可能要在短时间内连续请求磁盘块中的相邻内容，所以操作系统一次读取一个&#x2F;多个磁盘块到<strong>磁盘高速缓存</strong></p><p>通过盘块号查看是否在磁盘高速缓存中，在则直接返回，不在则访问磁盘</p><img src="/../../images/disk_cache.png" width=400px /><p><strong>写缓冲</strong>：通过延迟写入节省IO次数</p><p><strong>如果需要立即写会防止写入前系统崩溃可以使用fsync系统调用，除了文件调用外如果目录也是新创建的，需要目录也调用（目录也是文件）</strong></p><h4 id="基于文件的磁盘使用"><a href="#基于文件的磁盘使用" class="headerlink" title="基于文件的磁盘使用"></a>基于文件的磁盘使用</h4><h5 id="第四层抽象：引出文件（用户的文件视图）"><a href="#第四层抽象：引出文件（用户的文件视图）" class="headerlink" title="第四层抽象：引出文件（用户的文件视图）"></a>第四层抽象：引出文件（用户的文件视图）</h5><p>存储结构</p><ol><li><p>顺序存储：不便于动态增长</p></li><li><p>链式存储：无法随机访问</p><p>隐式链接存储</p><p>缺点：稳定性较差，系统在运行过程中由于软件或者硬件错误<strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。</strong></p><p>显式链接存储</p><p>它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张，每个表项中存放链接指针，指向下一个数据块号。内存中的这样一个表格称为<strong>文件分配表（File Allocation Table，FAT）</strong>。</p><img src="/../../images/FAT.png" width=400px /></li><li><p>索引存储：通过索引块记录文件包含的所有块，可以随机访问</p><img src="/../../images/file_index.png" width=500px /></li></ol><p><strong>Unix系统中的文件存储（多级索引）</strong></p><img src="/../../images/inode_multi_index.png" width=500px /><p>它是根据文件的大小，存放的方式会有所变化：</p><ul><li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li><li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li><li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li><li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li></ul><p>那么，文件头（<em>Inode</em>）就需要包含 13 个指针：</p><ul><li>10 个指向数据块的指针；</li><li>第 11 个指向索引块的指针；</li><li>第 12 个指向二级索引块的指针；</li><li>第 13 个指向三级索引块的指针；</li></ul><p>所以，这种方式能很灵活地支持小文件和大文件的存放：</p><ul><li>对于小文件使用直接查找的方式可减少索引数据块的开销；</li><li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询</li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h5 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接"></a>硬链接与软链接</h5><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<strong>硬链接（Hard Link）</strong> 和<strong>软链接（Symbolic Link）</strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p><img src="/../../images/hard_link.png" width=500px /><p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p><img src="/../../images/symbolic_link.png" width=500px /><h4 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><img src="/../../images/block_group.png" width=500px /><p>最前面的第一个块是<strong>引导块</strong>，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p><ul><li><strong>超级块</strong>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li><li><strong>块组描述符</strong>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li><li><strong>数据位图和 inode 位图</strong>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li><li><strong>inode 列表</strong>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li><li><strong>数据块</strong>，包含文件的有用数据。<strong>基本文件类型inode指向的数据块存储的是文件内容，目录类型inode指向的数据块存储的是该目录下文件和目录的inode</strong>。</li></ul><h5 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h5><p><strong>一个inode唯一对应一个文件或目录</strong></p><p>inode包含所有关于文件的信息，包括</p><ul><li><p>i_number：inode的id</p></li><li><p>文件类型（常规文件，目录等）</p></li><li><p>分配给它的块数</p></li><li><p>保护信息（谁拥有该文件以及谁可以访问它）</p></li><li><p>时间信息（创建，修改，上次访问的时间）</p></li><li><p>所有对应数据块的位置信息（混合索引）</p></li></ul><h4 id="文件操作的实现"><a href="#文件操作的实现" class="headerlink" title="文件操作的实现"></a>文件操作的实现</h4><h5 id="打开文件表"><a href="#打开文件表" class="headerlink" title="打开文件表"></a>打开文件表</h5><p><strong>系统打开文件表</strong>：</p><ul><li><p>全局的文件表，管理所有正在打开的文件，信息被所有进程共享</p></li><li><p>包含文件状态（包含inode）、位置指针和引用计数</p></li></ul><p><strong>进程打开文件表</strong>：</p><ul><li><p>每个进程的本地文件表，独立于其他进程</p></li><li><p>包含文件描述符和该进程的访问模式，维护进程独立的文件状态和偏移量</p></li></ul><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>当进程请求打开一个文件时，操作系统首先<strong>检查系统打开文件表</strong>，确定该文件是否已经打开。</p><ul><li>如果该文件已在系统打开文件表中存在，操作系统会<strong>增加该文件的引用计数</strong>，并为该进程在其<strong>进程打开文件表中添加一个条目</strong>，指向系统打开文件表中对应的条目。</li><li>如果该文件尚未打开，操作系统会<strong>创建一个新的条目</strong>，<strong>增加到系统打开文件表</strong>中，同时也在<strong>进程的打开文件表中添加一个条目</strong>。</li></ul><p>注意：</p><p>​<strong>不同进程独立打开同一文件</strong>：它们的文件描述符是不同的。</p><p>​<strong>通过</strong> fork() <strong>共享文件描述符</strong>：父进程和子进程共享相同的文件描述符。</p><p><strong>关闭文件</strong></p><ol><li><p>当进程关闭文件时，操作系统会<strong>更新进程打开文件表</strong>，移除相应的条目。</p></li><li><p>操作系统<strong>减少系统打开文件表中该文件的引用计数</strong>。<strong>如果引用计数变为零</strong>，则意味着没有进程再使用该文件，操作系统会<strong>释放系统打开文件表中的该条目</strong>。</p></li></ol><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><p>如果文件未被创建</p><ol><li>查询数据块位图查找空闲块，设置inode</li><li>读取inode位图，查找空闲位图块</li><li>写入inode位图</li><li>写入inode</li><li>创建当前目录inode和数据块，查找上级目录数据块更新当前目录inode</li></ol><p>如果已被创建</p><ol><li>读取数据位图，查询空闲块</li><li>写入数据位图</li><li>更新当前文件的inode</li></ol><h5 id="目录的读取"><a href="#目录的读取" class="headerlink" title="目录的读取"></a>目录的读取</h5><p>例如访问&#x2F;usr&#x2F;test.c</p><ol><li>找到根目录的inode，<strong>在类UNIX系统中根目录的i_number为2</strong></li><li><strong>读取i_number为2的inode</strong>，访问指向的数据块，<strong>获取下级目录的inode</strong></li><li><strong>根据inode访问对应数据块</strong></li></ol><img src="/../../images/dentry.png" width=500px /><h5 id="读取文件（了解）"><a href="#读取文件（了解）" class="headerlink" title="读取文件（了解）"></a>读取文件（了解）</h5><ol><li>应用程序发起读取文件的系统调用（read()）。</li><li>如果该文件已经被打开并且缓存在 Page cache 中，则直接从 Page cache 中读取文件数据，并返回给应用程序。如果 Page cache 中没有该文件的缓存，则进入下一步操作。</li><li>内核会在虚拟内存空间中分配一个缓冲区（buffer），用于存储文件数据。然后通过文件系统的 readpage() 回调函数，从磁盘上读取文件的一页数据，存储到缓冲区中。</li><li>如果读取成功，则将读取的数据存储到 Page cache 中，并返回读取的数据给应用程序。</li><li>如果读取失败，则返回错误码给应用程序。</li><li>应用程序继续读取下一页数据，直到读取完整个文件或者出现错误为止。</li></ol><h4 id="对象存储、块存储和文件存储"><a href="#对象存储、块存储和文件存储" class="headerlink" title="对象存储、块存储和文件存储"></a><strong>对象存储、块存储和文件存储</strong></h4><p>对象存储、块存储和文件存储是三种不同的数据存储方式。它们各有特点和适用场景，下面分别介绍它们的定义和区别：</p><ol><li>对象存储</li></ol><p>对象存储是一种存储数据的方式，<strong>它将数据分为对象，每个对象有一个唯一的标识符（ID）</strong>。对象存储系统通常是由多个分布式存储节点构成，每个节点都能够存储和访问对象。对象存储通常用于存储大规模的非结构化数据，如图片、视频、音频、日志等。相比于传统的文件存储方式，对象存储更适合于分布式环境下的数据存储和管理，具有高可扩展性、高可靠性和高可用性等特点。</p><ol start="2"><li>块存储</li></ol><p>块存储是一种以块为单位的存储方式，将数据分为固定大小的块，并按块来读取和写入数据。块存储通常用于存储结构化数据，如数据库中的数据。块存储系统通常由存储设备（如硬盘、固态硬盘等）和控制器组成，存储设备负责存储数据块，控制器负责管理块的分配和释放。相比于对象存储和文件存储方式，块存储具有更快的数据读写速度和更高的并发性能，但它需要应用程序自己管理数据的组织方式和存储位置等。<strong>文件系统在客户端</strong></p><ol start="3"><li>文件存储</li></ol><p>文件存储是一种将数据组织成文件的存储方式，每个文件有一个唯一的文件名，并以文件为单位进行读写。文件存储通常用于存储应用程序的配置文件、日志文件、文本文件等，它具有简单易用、易于管理的特点。相比于对象存储和块存储，文件存储方式更适合于存储小型的结构化和非结构化数据，但它对文件数量的管理和文件系统的维护可能需要更多的人力和资源。<strong>文件系统在存储端，便于共享，如NAS</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（十一）IO</title>
      <link href="/2025/01/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89IO/"/>
      <url>/2025/01/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89IO/</url>
      
        <content type="html"><![CDATA[<h4 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h4><h5 id="传统IO过程"><a href="#传统IO过程" class="headerlink" title="传统IO过程"></a>传统IO过程</h5><ol><li>CPU发起IO请求，每次只能请求一个字</li><li>磁盘数据写入缓冲区后，通过IO中断通知CPU</li><li>CPU将缓冲区数据通过寄存器写入内核缓冲区（内存中）</li><li>CPU将内核缓冲区（内存中）的数据拷贝到用户缓冲区（内存中）</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>CPU效率低下：CPU需要频繁得处理IO请求</li><li>传输效率低下：数据先从磁盘缓冲区拷贝到寄存器后才到拷贝到内存</li></ol><img src="/../../images/no_dma.png" alt="image.png" style="zoom:100%;" /><h4 id="引入DMA后的IO"><a href="#引入DMA后的IO" class="headerlink" title="引入DMA后的IO"></a>引入DMA后的IO</h4><p>将数据搬运的工作全部交给DMA控制器，CPU不需要参与</p><h5 id="引入DMA后的IO过程"><a href="#引入DMA后的IO过程" class="headerlink" title="引入DMA后的IO过程"></a>引入DMA后的IO过程</h5><ol><li>CPU发送IO请求到DMA</li><li>DMA拷贝磁盘数据到内核缓冲区</li><li>DMA拷贝完后向CPU发送IO中断请求</li><li>CPU将内核缓冲区的数据拷贝到用户缓冲区</li></ol><img src="/../../images/dma.png" alt="image.png" style="zoom:100%;" /><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h5 id="传统的文件传输方式"><a href="#传统的文件传输方式" class="headerlink" title="传统的文件传输方式"></a>传统的文件传输方式</h5><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>该过程需要<strong>4次内核&#x2F;用户态的切换（上下文切换），4次拷贝</strong></p><p><strong>优化目标：减少系统调用次数，减少拷贝次数</strong></p><img src="/../../images/socket_send_file.png" style="zoom:60%;" /><h5 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h5><p> <code>mmap</code>系统调用函数会直接把内核缓冲区里的数据映射到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><strong>通过mmap替代read减少了一次数据拷贝</strong>，但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次</p><img src="/../../images/mmap.png" style="zoom:60%;" /><h5 id="sendfile（零拷贝）"><a href="#sendfile（零拷贝）" class="headerlink" title="sendfile（零拷贝）"></a>sendfile（零拷贝）</h5><p><strong>流程</strong></p><ol><li><p>通过 DMA 将磁盘上的数据拷贝到内核缓冲区里</p></li><li><p>缓冲区描述符和数据长度传到 socket 缓冲区，这样<strong>网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区</strong>里，此过程<strong>不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区</strong>中，这样就减少了一次数据拷贝</p></li></ol><p><strong>该技术已运用在Kafka和Nginx中</strong></p><img src="/../../images/sendfile.png" style="zoom:60%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（十）中断</title>
      <link href="/2025/01/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89%E4%B8%AD%E6%96%AD/"/>
      <url>/2025/01/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章-中断"><a href="#第七章-中断" class="headerlink" title="第七章 中断"></a>第七章 中断</h2><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><img src="/../../images/interrupt_1.png" alt="image.png" style="zoom:35%;" /><h3 id="中断执行过程"><a href="#中断执行过程" class="headerlink" title="中断执行过程"></a>中断执行过程</h3><img src="/../../images/interrupt_2.png" alt="image.png" style="zoom:35%;" /><h3 id="当通过键盘给当前进程输入参数时的流程（IO中断）"><a href="#当通过键盘给当前进程输入参数时的流程（IO中断）" class="headerlink" title="当通过键盘给当前进程输入参数时的流程（IO中断）"></a>当通过键盘给当前进程输入参数时的流程（IO中断）</h3><p>中断流程</p><ol><li>用户键盘输入</li><li>键盘控制器生成扫描码并触发中断 (IRQ1)</li><li>CPU 暂停当前进程，响应中断</li><li>CPU执行中断处理程序，获取键盘输入</li><li>恢复被中断的任务</li><li>用户进程读取缓冲区输入（系统调用，使用“陷阱”内中断）</li></ol><h3 id="用户如何使用系统其他资源（系统调用）"><a href="#用户如何使用系统其他资源（系统调用）" class="headerlink" title="用户如何使用系统其他资源（系统调用）"></a>用户如何使用系统其他资源（系统调用）</h3><p>用户态的程序只能使用内存中用户段，不能使用内核段。内核态可以访问任何内存数据。</p><p><strong>中断是用户态进入内核态的唯一方法</strong></p><p>系统调用的核心：</p><ol><li>用户程序中包含<code>int 0x80</code>指令（中断）的代码</li><li>操作系统写中断处理，获取想调程序的编号(系统调用号)</li><li>操作系统根据编号执行相应代码</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（九）操作系统安全</title>
      <link href="/2025/01/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
      <url>/2025/01/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-操作系统安全"><a href="#第六章-操作系统安全" class="headerlink" title="第六章 操作系统安全"></a>第六章 操作系统安全</h2><h3 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>缓冲区溢出通常发生在程序使用固定大小的内存缓冲区来存储用户输入时，<strong>没有对输入数据的长度进行适当检查</strong>。攻击者利用这一点，<strong>将过大的输入数据注入缓冲区</strong>，导致：</p><ul><li><p><strong>覆盖关键数据</strong>：覆盖函数的返回地址、指针或其他重要变量。</p></li><li><p><strong>注入恶意代码</strong>：将攻击代码注入溢出的内存区域，并操纵程序跳转到攻击代码执行。</p></li><li><p><strong>控制程序执行流</strong>：通过覆盖返回地址或函数指针，改变程序的正常执行逻辑。</p></li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li><p><strong>栈随机化</strong></p></li><li><p><strong>栈破坏检测</strong></p></li><li><p><strong>限制可执行代码区域</strong></p></li></ul><img src="/../../images/buffer_overflow_attack.png" alt="image.png" style="zoom:20%;" /><h3 id="操作系统安全算法"><a href="#操作系统安全算法" class="headerlink" title="操作系统安全算法"></a>操作系统安全算法</h3><p><strong>1. 用户身份验证：散列算法</strong></p><p><strong>算法：SHA-256（Secure Hash Algorithm 256-bit）</strong></p><p><strong>应用场景</strong>：</p><p>用户登录时，操作系统会使用散列算法对密码进行加密存储。</p><p>登录时，用户输入的密码经过相同的散列计算，与存储的散列值比较以验证身份。</p><p><strong>工作原理</strong>：</p><ol><li>用户密码通过 SHA-256 生成一个固定长度（256 位）的散列值。</li><li>系统仅存储散列值，不保存明文密码。</li><li>具有抗碰撞性，难以通过逆向推算原始密码。</li></ol><p><strong>2. 访问控制：基于访问矩阵的权限管理</strong></p><p><strong>算法：访问控制矩阵</strong></p><p><strong>应用场景</strong>：</p><p>管理操作系统中的资源访问权限，如文件和设备的读写权限。</p><p><strong>工作原理</strong>：</p><ol><li>访问矩阵的行表示用户或进程，列表示资源（如文件、设备等）。</li><li>矩阵中的每个单元表示用户对资源的权限（读、写、执行等）。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（八）指令系统结构</title>
      <link href="/2025/01/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2025/01/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-指令系统结构"><a href="#第五章-指令系统结构" class="headerlink" title="第五章 指令系统结构"></a>第五章 指令系统结构</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>取指阶段：以PC作为第一个字节的地址，从内存中读出10个字节</li><li>译码阶段：指令字段译码，将操作数的值写到ALU读取的寄存器位置</li><li>执行阶段：ALU根据操作数和操作码计算值</li><li>访存阶段：读写内存位置</li><li>写回阶段：将结果值写入寄存器</li><li>更新PC：更新PC指向下一条指令的地址</li></ol><img src="/../../images/organize_program_into_process.png" alt="image.png" style="zoom:20%;" /><h4 id="指令示例"><a href="#指令示例" class="headerlink" title="指令示例"></a>指令示例</h4><p><strong>irmovq</strong></p><p>将一个 64 位的立即数（常数）加载到目标寄存器中</p><img src="/../../images/irmovq.png" alt="image.png" style="zoom:20%;" /><p><strong>pushq</strong></p><p>将一个 64 位的值从寄存器存储到栈上，并更新栈指针（%rsp）</p><img src="/../../images/pushq.png" alt="image.png" style="zoom:20%;" /><p><strong>rmmovq</strong></p><p>将一个寄存器的值存储到内存的某个地址中，该地址由一个基地址和一个偏移量计算得到</p><img src="/../../images/rmmovq.png" alt="image.png" style="zoom:20%;" /><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>通过将多个指令分解为一系列子任务，并将这些子任务分阶段并行执行来实现指令并行处理</p><img src="/../../images/pipeline.png" alt="image.png" style="zoom:20%;" /><h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>指令乱序执行时，可能会发生读取数据与写入数据之间的时序与空间的相关性，成为数据冒险。如果不加以处理，可能会导致竞态条件，即读的不是想要的值或写的不是正确位置</p><img src="/../../images/data_hazard_1.png" alt="image.png" style="zoom:20%;" /><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul><li><strong>延迟执行</strong>：硬件上阻止指令执行，增加流水线气泡</li></ul><img src="/../../images/data_hazard_2.png" alt="image.png" style="zoom:20%;" /><ul><li><strong>插入无关指令</strong>：软件上插入无关指令</li></ul><img src="/../../images/data_hazard_3.png" alt="image.png" style="zoom:35%;" /><ul><li><strong>数据旁路</strong>：使用最新计算结果，不等待寄存器写回结果</li></ul><img src="/../../images/data_hazard_4.png" alt="image.png" style="zoom:35%;" /><h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><p>处理器遇到分支指令，不能在流水开始阶段就判断出分支结果</p><h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><ul><li><p><strong>延迟执行</strong>：增加流水线气泡</p></li><li><p><strong>分支预测</strong>：使用分支预测，然后投机执行。如果分支预测失败，则要有能力恢复到分支指令执行完毕时刻的寄存器状态，进入正确的分支继续执行</p></li></ul><img src="/../../images/control_hazard.png" alt="image.png" style="zoom:20%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）绪论</title>
      <link href="/2025/01/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/01/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><img src="/../../images/computer_architecture.png" alt="image.png" style="zoom:20%;" /><h3 id="计算机启动后发生了什么"><a href="#计算机启动后发生了什么" class="headerlink" title="计算机启动后发生了什么"></a>计算机启动后发生了什么</h3><img src="/../../images/boot.png" alt="image.png" style="zoom:130%;" /><ol><li><p><strong>上电自检</strong></p><p>主板的固件（BIOS 或 UEFI）执行<strong>硬件检测</strong>，检查 CPU、内存、显卡、键盘等设备是否正常</p></li><li><p><strong>加载 BIOS 或 UEFI</strong></p><ol><li><p>CPU 开始执行 <code>0xFFFFFFF0</code> 地址处的指令，该地址处是一条 <code>JUMP</code> 指令，这条指令清空了基址寄存器的值，并让指令跳回到 BIOS 开始处（物理地址为 <code>0xF0000</code>，参考上图 <code>0xF0000</code> 处的标识）以执行 BIOS</p></li><li><p>BIOS 或 UEFI 固件初始化计算机硬件，完成底层配置。</p></li><li><p>确认引导顺序（启动顺序），如硬盘、USB 设备或网络启动。</p></li><li><p>加载引导程序（Bootloader）的第一部分，通常位于启动设备的引导扇区。</p></li></ol></li><li><p><strong>主引导记录（Master Boot Record, MBR）</strong></p><p>BIOS 从指定的启动设备中读取主引导记录</p></li><li><p><strong>启动加载器（Bootloader）</strong></p><p>启动加载器是一个小型程序，负责加载操作系统内核（常用：<strong>GRUB</strong>多操作系统支持，配置灵活；<strong>Windows Boot Manager</strong>用于加载 Windows 操作系统）</p></li><li><p><strong>内核初始化</strong></p><p>操作系统内核接管硬件的控制。执行真正的根文件系统中的 <code>/sbin/init</code> 进程，即系统的 1 号进程。此后，系统的控制权就全权交给 <code>/sbin/init</code> 进程了</p></li><li><p><strong>系统初始化</strong></p><p><code>/sbin/init</code> 进程是系统其它所有进程的父进程，当它接管了系统控制权后，它会根据 <code>/etc/inittab</code> 文件来执行相应的脚本，从而完成一系列的系统初始化操作</p></li><li><p><strong>用户登陆</strong></p></li></ol><h3 id="程序是如何运行的"><a href="#程序是如何运行的" class="headerlink" title="程序是如何运行的"></a>程序是如何运行的</h3><p>准备阶段：</p><ol><li>通过shell获取可执行程序地址，参数和环境变量</li><li>通过<strong>fork创建子进程</strong></li><li>通过<strong>execve替换当前进程的地址空间，使用加载器将程序加载到内存中</strong></li><li>shell调用wait 或 waitpid 系统调用等待子进程执行结束</li></ol><p>运行阶段：</p><ol><li>读取二进制程序ELF header中的元数据</li><li><strong>从_start段开始运行</strong></li><li>初始化运行时环境（如设置全局变量、构造全局对象）</li><li>准备参数并<strong>调用 main 函数</strong></li></ol><p>结束阶段：</p><ol><li>程序调用exit系统调用退出或异常终止</li></ol><h3 id="用户如何使用系统其他资源（系统调用）"><a href="#用户如何使用系统其他资源（系统调用）" class="headerlink" title="用户如何使用系统其他资源（系统调用）"></a>用户如何使用系统其他资源（系统调用）</h3><p>用户态的程序只能使用内存中用户段，不能使用内核段。内核态可以访问任何内存数据。</p><p>中断是用户态进入内核态的唯一方法</p><p>系统调用的核心：</p><ol><li>用户程序中包含<code>int 0x80</code>指令（中断）的代码</li><li>操作系统写中断处理，获取想调程序的编号(系统调用号)</li><li>操作系统根据编号执行相应代码</li></ol><h3 id="函数库的不同加载方式（静态链接和动态链接）"><a href="#函数库的不同加载方式（静态链接和动态链接）" class="headerlink" title="函数库的不同加载方式（静态链接和动态链接）"></a>函数库的不同加载方式（静态链接和动态链接）</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p><strong>在编译时将所有需要的库代码直接打包到可执行文件中</strong></p><img src="/../../images/static_linking.png" alt="image.png" style="zoom:20%;" /><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p><strong>在程序运行时（加载时或执行过程中）将库文件动态加载到内存中</strong>，与程序进行绑定。程序只保存对库的引用，而库本身作为共享资源存储在外部文件中（如 .so 或 .dll）。</p><img src="/../../images/dynamic_linking.png" alt="image.png" style="zoom:20%;" /><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>特性</th><th>静态链接</th><th>动态链接</th></tr></thead><tbody><tr><td><strong>链接时间</strong></td><td>编译时</td><td>程序运行时</td></tr><tr><td><strong>可执行文件大小</strong></td><td>较大（包含库代码）</td><td>较小（引用外部库）</td></tr><tr><td><strong>内存占用</strong></td><td>每个程序独立加载库代码，内存占用多</td><td>多个程序共享库，节省内存</td></tr><tr><td><strong>运行时效率</strong></td><td>无需加载外部库，效率高</td><td>首次加载外部库稍慢</td></tr><tr><td><strong>更新与维护</strong></td><td>库更新需要重新编译相关程序</td><td>库更新无需修改程序</td></tr><tr><td><strong>独立性</strong></td><td>无需依赖外部库</td><td>依赖外部共享库</td></tr><tr><td><strong>灵活性</strong></td><td>固定，无法动态更换库</td><td>灵活，可在运行时加载或替换库</td></tr></tbody></table><h3 id="如何创建子进程（fork）"><a href="#如何创建子进程（fork）" class="headerlink" title="如何创建子进程（fork）"></a>如何创建子进程（fork）</h3><p><strong>fork 的拷贝特点</strong></p><ol><li><strong>写时复制 (COW)</strong></li></ol><ul><li>fork 的内存部分在最初是浅拷贝形式：</li><li>父子进程共享相同的物理内存页面（例如代码段、数据段、堆、栈）。</li><li>只要父子进程不修改内存，所有页面保持共享。</li><li>当父进程或子进程尝试写入某个页面时，操作系统会触发<strong>页面级复制</strong>：</li><li>把要修改的页面复制到新的内存区域，使父子进程各自持有独立的副本。</li><li>这种机制避免了创建子进程时立即复制所有内存的高昂成本。</li></ul><ol start="2"><li><strong>文件描述符</strong>：</li></ol><ul><li>子进程复制父进程的文件描述符表。</li><li>文件描述符指向同一内核文件表项，因此父子进程共享文件偏移量。</li><li>这是一种<strong>浅拷贝</strong>。</li></ul><ol start="3"><li><strong>信号处理设置、环境变量、当前工作目录等</strong>：</li></ol><ul><li>这些是简单的值拷贝（深拷贝），因为它们不涉及共享资源。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归算法的理解</title>
      <link href="/2025/01/08/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2025/01/08/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="如何写一个递归算法"><a href="#如何写一个递归算法" class="headerlink" title="如何写一个递归算法"></a>如何写一个递归算法</h2><ol><li><strong>确定问题</strong>：给当前的算法一个符合计算机处理流程的解释。例如对于斐波那契数数列求解<code>int fib(int n)</code>，应该翻译成计算数列第n项并返回数列的值</li></ol><img src="/../../images/recursion.png" style="width:50%" /><ol start="2"><li><strong>解决基准问题</strong>：思考当输入值为基础值时，其返回的结果是什么。该步用于<strong>确定递归终止条件</strong>。例如对于汉诺塔问题，在只有一块积木时只需要将其从From移到Target即可</li></ol><img src="/../../images/recursion_2.png" style="width:50%;" /><ol start="3"><li><p><strong>拆解问题</strong>：考虑在当前的普通输入时，应该如何解决问题。例如对于斐波那契数数列求解，当前应该返回的值是<code>fib(n-1)+fib(n-2)</code>。</p><p>❗️❗️<strong>不要尝试去思考其内部具体是如何执行的，只要把当前函数当作一个已经实现的库函数即可。否则只会越绕越晕。</strong></p></li></ol><img src="/../../images/recursion_3.png" style="width:50%;" /><h2 id="递归算法举例分析"><a href="#递归算法举例分析" class="headerlink" title="递归算法举例分析"></a>递归算法举例分析</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ol><li><strong>确定问题</strong>：遍历以root为根结点的二叉树</li><li><strong>解决基准问题</strong>：当root为空指针时返回</li><li><strong>拆解问题</strong>：在访问完当前结点后，继续遍历左子树（具体说：遍历以root-&gt;left为根结点的二叉树），继续遍历右子树（具体说：遍历以root-&gt;right为根结点的二叉树）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; root-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><ol><li><strong>确定问题</strong>：计算以root为根结点的二叉树的最大深度并返回最大深度</li><li><strong>解决基准问题</strong>：当root为空指针时，表示该树空，返回0</li><li><strong>拆解问题</strong>：当前结点的最大深度即为左右子树中的最大深度+1，所以只需要获取左右子树的最大深度后+1即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line">    <span class="type">int</span> res = std::<span class="built_in">max</span>(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在二叉搜索树中插入结点"><a href="#在二叉搜索树中插入结点" class="headerlink" title="在二叉搜索树中插入结点"></a>在二叉搜索树中插入结点</h3><ol><li><strong>确定问题</strong>：在root为根结点的二叉树中插入值为val的结点，返回root的根结点</li><li><strong>解决基准问题</strong>：当root为空指针时，表示该树空，插入新结点</li><li><strong>拆解问题</strong>：如果当前结点非空，那就表示待插入结点应该在左或右子树，那如果<code>root-&gt;val&gt;val</code>则在左子树中插入，如果<code>root-&gt;val&lt;val</code>则在右子树中插入，并且返回值为当前子树的根结点（不用管插入的具体位置，以及是否为<code>root-&gt;left</code>或<code>root-&gt;right</code>，要想的只是把已经修改好的树返回给左右孩子指针），最后返回根结点<code>root</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在root为根的树中插入值为val的结点，并返回root</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *new_node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val&gt;val)</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>  (root-&gt;val&lt;val)</span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理与实现</title>
      <link href="/2025/01/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/01/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池原理与实现"><a href="#线程池原理与实现" class="headerlink" title="线程池原理与实现"></a>线程池原理与实现</h2><blockquote><p>B站讲解视频：<a href="https://www.bilibili.com/video/BV1sk4y1P7UM/?vd_source=c5564ed8491572469d815a8188748293">线程池原理与实现</a></p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h4><p><strong>线程池（Thread Pool）</strong>是一种基于<strong>池化思想</strong>管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p><strong>线程过多会带来额外的开销</strong>，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><span id="more"></span><p><img src="/../../images/thread_pool.png" alt="thread_pool"></p><p>使用线程池可以带来一系列好处：</p><ul><li><strong>降低资源消耗（系统资源）</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高线程的可管理性（系统资源）</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提高响应速度（任务响应）</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提供更多更强大的功能（功能扩展）</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h4 id="线程池解决的问题"><a href="#线程池解决的问题" class="headerlink" title="线程池解决的问题"></a>线程池解决的问题</h4><p>线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p><ul><li><p><strong>频繁申请&#x2F;销毁资源和调度资源</strong>，将带来额外的消耗，可能会非常巨大。</p></li><li><p><strong>对资源无限申请缺少抑制手段</strong>，易引发系统资源耗尽的风险。</p></li><li><p><strong>系统无法合理管理内部的资源分布</strong>，会降低系统的稳定性。</p></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><a href="https://github.com/Pithikos/C-Thread-Pool">C Thread Pool（Github）</a></p><table><thead><tr><th>Function example</th><th>Description</th></tr></thead><tbody><tr><td><em><strong>thpool_init(4)</strong></em></td><td>Will return a new threadpool with <code>4</code> threads.</td></tr><tr><td><em><strong>thpool_add_work(thpool, (void*)function_p, (void*)arg_p)</strong></em></td><td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td></tr><tr><td><em><strong>thpool_wait(thpool)</strong></em></td><td>Will wait for all jobs (both in queue and currently running) to finish.</td></tr><tr><td><em><strong>thpool_destroy(thpool)</strong></em></td><td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td></tr><tr><td><em><strong>thpool_pause(thpool)</strong></em></td><td>All threads in the threadpool will pause no matter if they are idle or executing work.</td></tr><tr><td><em><strong>thpool_resume(thpool)</strong></em></td><td>If the threadpool is paused, then all threads will resume from where they were.</td></tr><tr><td><em><strong>thpool_num_threads_working(thpool)</strong></em></td><td>Will return the number of currently working threads.</td></tr></tbody></table><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><h4 id="thpool-init-int-num-threads"><a href="#thpool-init-int-num-threads" class="headerlink" title="thpool_init(int num_threads)"></a>thpool_init(int num_threads)</h4><ol><li>创建线程池基本结构</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">thread **threads;  <span class="comment">/* pointer to threads        */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;  <span class="comment">/* threads currently alive   */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num_threads_working; <span class="comment">/* threads currently working */</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> thcount_lock;  <span class="comment">/* used for thread count etc */</span></span><br><span class="line"><span class="type">pthread_cond_t</span> threads_all_idle;  <span class="comment">/* signal to thpool_wait     */</span></span><br><span class="line">jobqueue jobqueue;  <span class="comment">/* job queue                 */</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建线程池中的线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread *));</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n=<span class="number">0</span>; n&lt;num_threads; n++)&#123;</span><br><span class="line">thread_init(thpool_p, &amp;thpool_p-&gt;threads[n], n);</span><br></pre></td></tr></table></figure><h5 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h5><ol><li><p>对于<strong>资源申请失败的处理</strong>，防止<strong>异常退出和内存泄漏</strong></p><p>由于malloc申请失败是不报错的，在malloc之后<strong>一定要判断返回的指针值是否为NULL</strong>。如果对于这个空指针不做处理，那之后对于空指针的操作<strong>会引发Segmentation Fault</strong>而程序直接core了。还有就是在异常处理中要对已经申请的资源释放掉，否则会引发<strong>内存泄漏</strong></p></li><li><p>对于<strong>传值和传址</strong>的区分，传值传的是值的拷贝</p></li></ol><p>​如果对于指针理解得比较困难的开发者可以看看<a href="https://space.bilibili.com/519963684">南科大于仕琪老师的C&#x2F;C++教程</a></p><h4 id="int-thpool-add-work-thpool-thpool-p-void-function-p-void-void-arg-p"><a href="#int-thpool-add-work-thpool-thpool-p-void-function-p-void-void-arg-p" class="headerlink" title="int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p)"></a>int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p)</h4><ol><li>创建任务</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newjob = (<span class="keyword">struct</span> job *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure><ol start="2"><li>配置函数和函数参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure><ol start="3"><li>将任务加入队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure><h5 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h5><ol><li><p>对于队列<strong>没有任务时的处理</strong></p><p>不是采用轮询的方式，而是使用条件变量，在有任务时唤醒条件变量</p></li><li><p>对于<strong>函数指针类型转换的处理</strong></p></li></ol><p>​自定义的函数原型可以与api的原型不一致，但需要进行强制类型转换，<code> (void *(*)(void *))</code>里面中间的*表示当前为函数指针，右边的void *表示参数类型，左边的void *表示返回值类型。切记不要让编译器去做这种类型转换，可能会有意想不到的问题。（pthread_create参数里最后的函数指针的参数这样写好像就不必转换类型了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   int pthread_create(pthread_t *restrict thread,</span></span><br><span class="line"><span class="comment">//                   const pthread_attr_t *restrict attr,</span></span><br><span class="line"><span class="comment">//                   void *(*start_routine)(void *),</span></span><br><span class="line"><span class="comment">//                   void *restrict arg);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static void *thread_do(struct thread *thread_p)</span></span><br><span class="line">pthread_create(&amp;(*thread_p)-&gt;pthread, <span class="literal">NULL</span>, (<span class="type">void</span> *(*)(<span class="type">void</span> *))thread_do, (*thread_p));</span><br></pre></td></tr></table></figure><h4 id="void-thpool-destroy-thpool-thpool-p"><a href="#void-thpool-destroy-thpool-thpool-p" class="headerlink" title="void thpool_destroy(thpool_ *thpool_p)"></a>void thpool_destroy(thpool_ *thpool_p)</h4><ol><li>结构体元素的复位</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">time_t</span> start, end;</span><br><span class="line">  <span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过条件变量的唤醒终止线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive)</span><br><span class="line">&#123;</span><br><span class="line">  bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">  time(&amp;end);</span><br><span class="line">  tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive)</span><br><span class="line">&#123;</span><br><span class="line">  bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>任务队列的释放</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure><ol start="4"><li>其余堆上元素的释放</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; threads_total; n++)</span><br><span class="line">&#123;</span><br><span class="line">  thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure><h5 id="关注点-2"><a href="#关注点-2" class="headerlink" title="关注点"></a>关注点</h5><ol><li>对于<strong>线程释放的处理</strong></li></ol><p>​可以<strong>定义一个条件变量来唤醒所有线程</strong>，然后通过一个<strong>表示是否存活的布尔值来作为while循环的终止条件</strong>，达到优雅的释放</p><ol start="2"><li>别漏，别漏，别漏</li></ol><p>​一定要细心检查，不要忘记释放堆上的资源</p><h4 id="static-void-thread-hold-int-sig-id"><a href="#static-void-thread-hold-int-sig-id" class="headerlink" title="static void thread_hold(int sig_id)"></a>static void thread_hold(int sig_id)</h4><ol><li>注册信号量句柄</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function thread_do</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler function</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span></span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>)sig_id;</span><br><span class="line">threads_on_hold = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (threads_on_hold)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过信号量发送暂停信号</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++)</span><br><span class="line">&#123;</span><br><span class="line">  pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-thpool-resume-thpool-thpool-p"><a href="#void-thpool-resume-thpool-thpool-p" class="headerlink" title="void thpool_resume(thpool_ *thpool_p)"></a>void thpool_resume(thpool_ *thpool_p)</h4><p>修改循环条件值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们明白了线程池是什么（What），线程池有什么用（Why）以及接口的具体实现（How）。这个线程池项目中有许多值得学习的地方，比方说对于条件变量的使用，对于资源的申请和释放方法，是很优质的开源项目。另外，项目里也有可以扩充的点，比方说把队列改成比方说把队列改成优先级队列，那这样要考虑的东西就更多了，比方说它任务是可抢占还是不可抢占的，有任务的调度顺序的变化，这可能会牵涉到线程逻辑的大修改，如果大家感兴趣的话可以试试～</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB使用手册</title>
      <link href="/2025/01/05/GDB/"/>
      <url>/2025/01/05/GDB/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB使用手册"><a href="#GDB使用手册" class="headerlink" title="GDB使用手册"></a>GDB使用手册</h2><p>编译时加上<code>-g</code>选项</p><table><thead><tr><th>命令名称</th><th>命令缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行一个待调试的程序</td></tr><tr><td>continue</td><td>c</td><td>让暂停的程序继续运行</td></tr><tr><td>next</td><td>n</td><td>运行到下一行</td></tr><tr><td>step</td><td>s</td><td>单步执行，遇到函数会进入</td></tr><tr><td>until</td><td>u</td><td>运行到指定行停下来</td></tr><tr><td>finish</td><td>fi</td><td>结束当前调用函数，回到上一层调用函数处</td></tr><tr><td>return</td><td>return</td><td>结束当前调用函数并返回指定值，到上一层函数调用处</td></tr><tr><td>jump</td><td>j</td><td>将当前程序执行流跳转到指定行或地址，不运行跳过的代码</td></tr><tr><td>print</td><td>p</td><td>打印变量或寄存器值</td></tr><tr><td>backtrace</td><td>bt</td><td>查看当前线程的调用堆栈</td></tr><tr><td>frame</td><td>f</td><td>切换到当前调用线程的指定堆栈</td></tr><tr><td>thread</td><td>thread</td><td>切换到指定线程</td></tr><tr><td>break</td><td>b</td><td>添加断点</td></tr><tr><td>tbreak</td><td>tb</td><td>添加临时断点</td></tr><tr><td>delete</td><td>d</td><td>删除断点</td></tr><tr><td>enable</td><td>enable</td><td>启用某个断点</td></tr><tr><td>disable</td><td>disable</td><td>禁用某个断点</td></tr><tr><td>watch</td><td>watch</td><td>监视某一个变量或内存地址的值是否发生变化</td></tr><tr><td>list</td><td>l</td><td>显示源码</td></tr><tr><td>info</td><td>i</td><td>查看断点 &#x2F; 线程等信息</td></tr><tr><td>ptype</td><td>ptype</td><td>查看变量类型</td></tr><tr><td>disassemble</td><td>dis</td><td>查看汇编代码</td></tr><tr><td>set args</td><td>set args</td><td>设置程序启动命令行参数</td></tr><tr><td>show args</td><td>show args</td><td>查看设置的命令行参数</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面试题</title>
      <link href="/2025/01/05/C++questions/"/>
      <url>/2025/01/05/C++questions/</url>
      
        <content type="html"><![CDATA[<h3 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h3><ol><li>header中防御式声明的目的</li></ol><ul><li>防止两个头文件相互include时的循环include</li><li>防止cpp在include不同头文件时可能产生的重复定义</li></ul><ol start="2"><li>inline</li></ol><p>将函数声明为inline可以避免函数调用的开销，空间换时间</p><p>常规的函数调用需要用到栈，需要返回地址和参数压栈，但通过inline展开后就为普通的顺序执行</p><p><strong>与define的区别</strong>：</p><ul><li>define无类型检查，inline有</li><li>define编写时运算符的优先级较难处理</li><li>define在预处理时展开，inline由编译器实现展开</li></ul><ol start="2"><li>const</li></ol><p>const对象的<strong>值创建后值不能再改变</strong>，所以必须初始化</p><p>对于<strong>const指针</strong>，分为：</p><ul><li>底层const：<code>int* const p = &amp;a</code>无法改变p的指向</li><li>顶层const：<code>const int* p = &amp;a</code>无法通过p改变a的值</li></ul><p>对于<strong>const引用</strong>，其原来就不能改变引用的变量，所以只有底层const<code>const int&amp; a = 1</code></p><p>顶层const<strong>拷贝</strong>不受限制</p><p>底层const拷贝时，右值必须为非常量或者为底层const变量</p><p>对于<strong>const成员函数</strong>，无法改变成员变量的值</p><ol start="2"><li>Static</li></ol><ul><li><p>用于修饰变量：在函数内部，static 修饰的变量具有静态存储期，意味着它们的生命周期与程序的生命周期相同，而不是与函数的调用次数相关。在全局或命名空间作用域中，static 修饰的变量具有内部链接，只能在当前文件或当前命名空间中访问。</p></li><li><p>用于修饰函数：在函数内部，static 修饰的函数具有内部链接，只能在当前文件中调用，不能被其他文件调用。</p></li><li><p>用于修饰类成员变量：在类中，static 修饰的成员变量是类共享的，即所有类对象共享同一份内存。这些变量可以被类的任何成员函数访问，甚至在没有类对象的情况下也可以访问。需要注意的是，静态成员变量必须在类外进行定义和初始化。</p></li><li><p>用于修饰类成员函数：在类中，static 修饰的成员函数是类相关的，而不是对象相关的。这意味着它们不需要通过类对象来调用，可以直接通过类名来调用。</p></li></ul><ol start="2"><li>调用构造函数和析构函数，内存的影响</li><li>内存对齐</li></ol><p>分配内存时，按照一些规则对内存地址调整，不使用一些内存，通过空间换时间，优化访存效率</p><p>对于基础数据类型，按照4，8，16B等对齐</p><p>对于结构体和类，按照最宽基本数据类型为对齐单元</p><p>可以通过<code>sizeof()</code>查看</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）内存管理</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h2><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><p>在编译形成可执行程序时，用到的地址都是从0开始的相对地址，也被称为<strong>逻辑地址</strong>。但被加载到内存后可能使用任意一块空闲地址，所以需要将逻辑地址转化成内存中实际的物理地址，即<strong>重定位</strong>。</p><p>有以下几种解决方法：</p><ol><li><p>编译时重定位：需要在编译时确定哪块内存空间空闲，且在装入前不允许使用（用于执行固定任务的计算机系统，如嵌入式系统）</p></li><li><p>载入时重定位：在程序载入时，根据初始内存地址修改程序里的逻辑地址，但如果进程阻塞换出内存后换入时的地址不一定是之前的地址，造成错误</p></li><li><p><strong>运行时重定位（PC机使用）</strong>：在指令执行时才将逻辑地址转化为物理地址，取出指令—修改地址（<strong>存储管理部件MMU</strong>计算）—执行指令</p><p>基地址存在PCB中，在内存基地址修改时更新，在执行时加载到寄存器中使MMU修改地址</p><img src="/../../images/mem_base.png" width=700px /></li></ol><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>程序由若干段组成，每段都有各自的用途</p><ul><li>代码段：程序指令形成的段，只读</li><li>数据段：存放程序使用的数据，可读可写</li><li>栈：实现函数调用，通常只能向下（低地址）增长</li><li>函数库：include的函数库，可有可无</li></ul><img src="/../../images/memoryLayoutC.jpg" width=500px /><p>由于各个段有不同的语义及限制操作，所以需要进行区分。</p><p>因为程序已经分段，故不需要将其整体放入内存的连续空间，可一段段放入不同的内存空间，提高内存使用效率</p><p>在进行重定位时，访问<strong>段表（局部描述符表LDT，PCB中）</strong>中对应段的基地址给MMU运算得到物理地址</p><img src="/../../images/seg_table.png" width=700px /><p>分段的缺点是由于段较大，经过多次的申请和释放，很容易产生很多细小的无法分配给其他进程的<strong>内存碎片</strong>，故引入基于物理地址的分页机制（区别于基于逻辑地址分段机制）</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页机制首先将内存分为大小相等的页框（通常为4B），然后再把请求放入内存的数据切成大小相同的页，最后将所有页映射到页框上。<strong>以解决内存碎片问题造成的空间浪费。</strong></p><p><strong>页表存在内存中</strong></p><img src="/../../images/page_table.png" width=700px /><p>在32位机上最大的逻辑地址为2^32，每个页面4K，所以有2^20页，每个页表项需要4B存储，故每个进程需要4MB在存储页表（每个进程都有自己的页表），当进程数多时，需要很大的空间存储页表，但实际上页表只是做了索引保存基地址的作用，没有实际作用，这代价不可接受。</p><p>但是由于程序的<strong>局部性原则</strong>，不需要把程序的所有页加载到内存中，可以去除未被使用的逻辑页，<strong>缩小页表</strong>。</p><p>可是这又引发了其他问题，由于删除了未使用项导致页表无法随机访问，需要通过多次查找页表获取页号对应的页框号。<strong>每次访问页表就是访问内存，效率很低。</strong>所以引入了<strong>多级页表</strong>，且保证<strong>页表项连续</strong>，可以随机访问，减少搜索（访存）次数，另外<strong>只在内存中存需要一级页表对应的页表项</strong>，提升内存利用率。</p><img src="/../../images/multi_page.png" width=700px /><p>由于程序的<strong>局部性原则</strong>，访问的页集中，所以可以将近期使用的页信息放在<strong>快表（TLB，Cache中）</strong>，减少访存次数。</p><p>TLB内页表项无序。</p><img src="/../../images/TLB.png" width=700px /><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>从程序员角度，程序分为一个个逻辑段，但分段的缺点是由于段较大，在申请和释放时很容易产生内存碎片</p><p>从内存角度，程序分为一个个小的长度均匀的物理页存放到内存中，优点是提高了内存的利用率，但是有违程序员对于程序的理解</p><p>所以引入<strong>段页式内存管理</strong>方式，先将程序分段，再将程序分页，存储到物理内存上</p><img src="/../../images/virtual_add.png" width=500px /><p>当<strong>磁盘上的一个程序要放入内存</strong>时，会依次完成如下工作：</p><ol><li>在<strong>虚拟内存分割分区，放入各个“段”</strong>，不是真的放入，而是建立映射关系（fork出的子进程和父进程用不同的虚拟内存）</li><li><strong>建立段表</strong>记录<strong>逻辑地址和虚拟地址的映射</strong>关系</li><li>将<strong>虚拟内存分割成页，放入空闲物理内存</strong></li><li>建立页表记录<strong>逻辑地址和物理地址的映射</strong>关系（fork出的子进程拷贝父进程的映射关系，但如果子进程要修改数据区，则申请新内存页，建立映射关系，内核已将父进程的内存空间设为只读，防止了子进程的修改，所以子进程对于数据区的修改不会影响父进程）</li></ol><img src="/../../images/address_translate.png" width=700px /><p>虚拟地址对用户透明，用户无法获取物理地址</p><img src="/../../images/different_view_of_mem.png" width=700px /><h3 id="页的换入和换出"><a href="#页的换入和换出" class="headerlink" title="页的换入和换出"></a>页的换入和换出</h3><p>虚拟内存就是操作系统给进程提供的一个规整的、总长度总为4GB（32位操作系统）的地址空间，但实际的物理内存可能少于4GB，所以虚拟内存不可能全部映射到物理内存上，需要物理内存和磁盘存储的<strong>换入&#x2F;换出操作</strong>。</p><p>通过虚拟内存和页表<strong>确认页表项</strong>，看其有效位是否为1（0表示在物理内存中，1表示不在），若为0，则需从磁盘<strong>换入</strong>。换入的系统调用（缺页中断）如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 0: push variable to stack</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_no_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> error_code, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">  address &amp;= <span class="number">0xfffff00</span>; <span class="comment">// Step 1: get page numuber</span></span><br><span class="line">  page = get_free_page(); <span class="comment">// Step2: malloc free page on physical memory</span></span><br><span class="line">  bread_page(page,current-&gt;executable-&gt;i_dev, nr); <span class="comment">//Step3: copy block to physical memory</span></span><br><span class="line">  put_page(page, address); <span class="comment">//Step4: update page table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果物理内存满在<code>Step 2</code>直接分配内存会失败，需要选取页面<strong>换出</strong></p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ol><li>LRU（最近最少使用）</li></ol><p>基于页面栈（数据结构采用链表），搜索新页面是否在栈中，若不在则pop栈底元素，新元素入栈。如果在，则将栈顶元素修改为当前元素，其他元素下移</p><img src="/../../images/LRU.png" width=700px /><p><strong>操作系统不采用，因为每次页面访问都需要维护页面栈，也就是访存，另外还涉及到指针的修改</strong></p><ol start="2"><li>clock算法（SCR算法，second-chance-replacement）</li></ol><p><strong>clock算法是对于LRU的近似，LRU为最近最少使用，clock为最近的上次缺页以来不使用</strong></p><p>页面每次访问时R位置1，缺页时扫描当前线性表</p><ul><li>如果R&#x3D;1，置为0，不换出给它一次机会</li><li>如果R&#x3D;0，换出，并将换入页R置为1</li></ul><img src="/../../images/clock_algo.png" width=500px /><p><strong>存在的问题是实际发生缺页的概率并不大，可能找不出R&#x3D;0的页，所以引入改近clock算法</strong></p><ol start="3"><li>改进的clock算法</li></ol><p>需要一个指针定期扫描所有页并将对应R置0，换出页遇到R&#x3D;0换出</p><img src="/../../images/advanced_clock_algo.png" width=700px />]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）进程管理（如何实现多进程）</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>运行中的程序（区别于未运行的静态程序），需要有数据结构保存当前运行的信息（PCB），便于切换不同进程</p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><img src="/../../images/process_state.png" alt="process_state" width=700px /><h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><p>操作系统切换进程（宏观）</p><p>例子为进程运行到磁盘读写操作后与其他进程的切换</p><img src="/../../images/process.png" alt="process" width=500px/><p>操作系统切换进程的PCB（微观）</p><img src="/../../images/PCB_use.png" alt="PCB_use" width=500px/><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p>PCB的结构</p><ul><li><strong>Process scheduling state</strong> – The state of the process in terms of “ready”, “suspended”, etc., and other scheduling information as well, such as priority value, the amount of time elapsed since the process gained control of the CPU or since it was suspended. Also, in case of a suspended process, event identification data must be recorded for the event the process is waiting for;</li><li><strong>Process structuring information</strong> – the process’s children id’s, or the id’s of other processes related to the current one in some functional way, which may be represented as a queue, a ring or other data structures;</li><li><strong>Interprocess communication information</strong> – flags, signals and messages associated with the communication among independent processes;</li><li><strong>Process Privileges</strong> – allowed&#x2F;disallowed access to system resources;</li><li><strong>Process State</strong> – new, ready, running, waiting, dead;</li><li><strong>Process Number (PID)</strong> – unique identification number for each process (also known as Process ID);</li><li><strong>Program Counter (PC)</strong> – a pointer to the address of the next instruction to be executed for this process;</li><li><strong>CPU Registers</strong> – register set where process needs to be stored for execution for running state;</li><li><strong>CPU Scheduling Information</strong> – information scheduling CPU time;</li><li><strong>Memory Management Information</strong> – page table, memory limits, segment table;</li><li><strong>Accounting Information</strong> – amount of CPU used for process execution, time limits, execution ID etc.;</li><li><strong>I&#x2F;O Status Information</strong> – list of I&#x2F;O devices allocated to the process.</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>将资源和指令执行分开，进程为资源+指令执行序列。</p><p><strong>线程几乎不拥有资源（通过共享进程的资源），只实现指令的切换（切换PC指针，寄存器等）</strong>，保留了并发的优点，避免了进程切换的代价（保留现场，切换PCB）</p><p><strong>当需要并发而且共享相同资源（内存）时使用多线程编程</strong>，进程间资源相互独立</p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><strong>只有用户级线程没有用户级进程，因为进程拥有内存资源，需要到内核态执行</strong></p><p>如果对于多线程使用同一个栈，则在return访问栈时会跳转到其他线程，所以应对于不同的线程使用不同的栈</p><p>yield：当前线程会尽量让出CPU资源来给其他线程执行</p><img src="/../../images/user_thread_one_stack.png" alt="user_thread_one_stack" width=700px /><p>每个线程使用不同栈，通过不同的栈顶指针区分，yield更新当前线程TCB的栈顶指针，切换到下个线程的TCB，取栈顶指针</p><img src="/../../images/user_thread_multi_stack.png" alt="user_thread_multi_stack" width=700px /><img src="/../../images/user_multi_process.png" alt="user_multi_process" width=700px /><p>操作系统无法看到用户级线程，进而无法分配硬件多核处理，只有通过内核级线程调用多核</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>有几个内核级线程就要有几套栈（每套包括用户态执行函数调用的栈，内核态执行函数调用的栈）</p><img src="/../../images/kernal_thread_stack.png" alt="kernal_thread_stack" width=700px /><img src="/../../images/kernal_thread_stack_exp.png" alt="kernal_thread_stack_exp" width=700px /><p>内核级线程切换步骤</p><img src="/../../images/kernal_thread_switch.png" alt="kernal_thread_switch" width=700px /><h3 id="CPU调度策略"><a href="#CPU调度策略" class="headerlink" title="CPU调度策略"></a>CPU调度策略</h3><h4 id="任务调度策略的三个基本准则"><a href="#任务调度策略的三个基本准则" class="headerlink" title="任务调度策略的三个基本准则"></a>任务调度策略的三个基本准则</h4><ul><li>任务周转时间：从新建到完成的时间</li><li>任务响应时间：从交互操作到任务响应的时间（前台任务关心）</li><li>系统吞吐量：一段时间内系统能完成的任务数</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ol><li>先来先服务</li><li>短作业优先调度：可抢占，平均周转时间短（作业运行时间只能近似给出）</li><li>轮转调度：保证响应时间</li><li>多级队列调度：两个任务队列，一个是采用轮转调度的前台任务，一个是采用短作业优先的后台任务</li><li>多级反馈队列调度：动态调整任务类型（近期多IO可能为前台任务，无IO时间片结束未完成可能为后台大任务）</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="多处理器和多核"><a href="#多处理器和多核" class="headerlink" title="多处理器和多核"></a>多处理器和多核</h4><p>多处理器：多套CPU，Cache，MMU（内存映射表）资源</p><p>多核：多个CPU，共用Cache和MMU</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（五）传输层</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h3><p>可靠的、保序的传输：TCP</p><ul><li>多路复用，解复用</li><li>拥塞控制</li><li>流量控制（防止接收方缓存区满造成的分组丢失）</li><li>建立连接</li></ul><p>不可靠、不保序的传输：UDP</p><ul><li>多路复用，解复用</li><li>没有为尽力而为的IP服务添加更多的其他服务</li></ul><p>都不提供的服务：</p><ul><li>延时保证</li><li>带宽保证</li></ul><h3 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h3><h4 id="RDT协议（递进关系）"><a href="#RDT协议（递进关系）" class="headerlink" title="RDT协议（递进关系）"></a>RDT协议（递进关系）</h4><ol><li><p>rdt1.0：不提供反馈信息（假设所有数据包都正确从发送端传送到接收端）</p></li><li><p>rdt2.0：<strong>停止等待协议</strong>，引入差错检验，接收方反馈，重传机制。接收方在检验后向发送方返回ACK（正确）&#x2F;NCK（错误），这里的重传是对于NCK的重传，没有考虑对于丢失处理的超时重传（假设所有反馈消息都能正确送到发送端，没有消息分组的丢弃）</p></li><li><p>rdt2.1：ACK&#x2F;NCK对于接受到的消息编号，由于为停止等待协议，发送方若未收到消息的确认则不发下个消息，所以只需要一个位表示序号0&#x2F;1</p></li><li><p>rdt2.2：通过对于上个消息序号的确认替代对于本次消息的NCK（基于rdt2.1的小升级）</p></li><li><p>rdt3.0：引入超时重传机制，可能在接收端会出现冗余分组，但rdt2.2已可以应对（应对消息分组的丢失，但由于为停止等待，网络利用率很低）</p></li></ol><h5 id="回退N步（GBN）协议"><a href="#回退N步（GBN）协议" class="headerlink" title="回退N步（GBN）协议"></a>回退N步（GBN）协议</h5><p>基于发送方的<strong>滑动窗口</strong>实现，允许发送方发送多个分组而不需要等待确认，但它也受限于流水线中未取人的分组书不能超过最大允许数N（<strong>流量控制</strong>，防止因接收方缓存空间不足引发的包丢弃）。</p><p>接收方只按序接收分组（假设为k），一次交付给上层一个分组，对于所有大于k的分组丢弃，即只维护一个待接收分组序号的变量</p><p>发送方采取<strong>累计确认</strong>，即对于k的ACK确保小于等于k的分组已被接受</p><p>缺点：接收方丢弃正确但失序的分组，存在<strong>冗余重传</strong>的问题</p><h5 id="选择重传（SR）协议"><a href="#选择重传（SR）协议" class="headerlink" title="选择重传（SR）协议"></a>选择重传（SR）协议</h5><p>发送方只对于超时或者错误的分组重传，通过接收方维护一个滑动窗口实现</p><p>对于发送方的冗余分组，发送方必须给出该分组的ACK，否则发送方滑动窗口始终无法前进</p><p>对于SR协议，窗口长度必须小于等于序号空间大小的一半</p><h4 id="可靠数据传输的机制"><a href="#可靠数据传输的机制" class="headerlink" title="可靠数据传输的机制"></a>可靠数据传输的机制</h4><img src="/../../images/reliable_2.png" alt="socket" style="zoom:100%;" /><img src="/../../images/reliable_1.png" alt="socket" style="zoom:100%;" /><h3 id="面向连接的TCP协议"><a href="#面向连接的TCP协议" class="headerlink" title="面向连接的TCP协议"></a>面向连接的TCP协议</h3><p>序号：当前分组编号</p><p>确认号：希望收到的下个分组的序号</p><p>发送方采取<strong>累计确认</strong>，接收方对于失序分组丢弃或者缓存（TCP未规定）</p><p>对于发送多个分组，如果超时，发送方只发送最早的未确认分组</p><p><strong>快速重传</strong>：接收方收到三个对于同样序号k的ACK，则立即发送k分组，不再等到超时</p><p><strong>流量控制</strong>：接收方把缓存区余量发送给接收方，便于接收方控制发送速率（捎带）</p><p><strong>三次握手</strong>：</p><img src="/../../images/tcp_three_hands.png" alt="socket" style="zoom:50%;" /><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><p>两次握手的问题（无法防止历史连接）：</p><img src="/../../images/tcp_two_hands.png" alt="tcp_two_hands" style="zoom:50%;" /><p>如果为三次握手</p><img src="/../../images/three_hands_good.png" alt="three_hands_good" style="zoom:50%;" /><p>TCP连接释放四次握手（其实是没法做到完备的）</p><img src="/../../images/tcp_four_close.png" alt="tcp_four_close" style="zoom:50%;" /><p><strong>拥塞控制</strong>：调整发送速率处理网络内部拥塞的问题</p><p>对于超时的拥塞控制机制（严重）</p><img src="/../../images/tcp_timeout.png" alt="tcp_timeout" style="zoom:50%;" /><p>对于三个冗余ACK的拥塞控制机制（不严重）</p><img src="/../../images/tcp_three_ack.png" alt="tcp_three_ack" style="zoom:50%;" /><p>快速恢复算法过程中，为什么收到新的数据后，cwnd 设置回了 ssthresh ？</p><ol><li>在快速恢复的过程中，首先 ssthresh &#x3D; cwnd&#x2F;2，然后 cwnd &#x3D; ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包；</li><li>随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。</li></ol><p><strong>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</strong></p><p><strong>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（四）应用层（网络编程）</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><img src="/../../images/udpprocess.png" alt="udpprocess" style="zoom:50%;" /><p>UdpClient</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&quot;hostname&quot;</span></span><br><span class="line">severPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_DGRAM) <span class="comment"># ipv4,udp</span></span><br><span class="line">message = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">clientSocket.sendto(message.encode(),(serverName,severPort))</span><br><span class="line">modifiedMessage,serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode)</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p>Udpserver</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)  <span class="comment"># ipv4,udp</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMssage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMssage.encode(), clientAddress)</span><br></pre></td></tr></table></figure><h4 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h4><img src="/../../images/tcpprocess.png" alt="tcpprocess" style="zoom:50%;" /><p>TcpClient</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&quot;servername&quot;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_STREAM) <span class="comment">#ipv4,tcp</span></span><br><span class="line">clientSocket.connect((serverName,serverPort))</span><br><span class="line">sentence = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">clientSocket.send(sentence.encode()) <span class="comment"># tcp three-way handshake to welcomesocket</span></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p>TcpServer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">welcomeSocket = socket(AF_INET,SOCK_STREAM) <span class="comment"># create for client to handshake</span></span><br><span class="line">welcomeSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line">welcomeSocket.listen(<span class="number">1</span>) <span class="comment"># accept one connection</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket,addr = welcomeSocket.accept() <span class="comment"># create socket to connect to client</span></span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    modifiedMssage = sentence.decode().upper()</span><br><span class="line">    connectionSocket.send(modifiedMssage.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>TCP需要在传输前建立连接，传输后关闭连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（三）应用层</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><p>传输层向应用层提供的服务为socket API</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>简化本主机应用层向传输层发送的非有效信息，通过socket代表一组信息</p><p>TCP socket包含源IP，源端口，目标IP，目标端口，连接状态</p><p>UDP socket包含源IP，源端口</p><p>但是传输报文时必须提供对方IP，port。接收报文时传输层需要上传对方的IP，port</p><img src="/../../images/socket.png" alt="socket" style="zoom:30%;" /><h3 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h3><p>http为无状态协议，状态通过cookies实现</p><img src="/../../images/http.png" alt="http" style="zoom:50%;" /><img src="/../../images/cookies.png" alt="cookies" style="zoom:50%;" /><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>IP到域名的转换，运行在UDP上</p><img src="/../../images/dns.png" alt="http" style="zoom:50%;" /><h3 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h3><p>FTP：文件传输协议</p><p>SMTP：简单邮件传输协议（发送）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（二）英特网</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%8B%B1%E7%89%B9%E7%BD%91/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%8B%B1%E7%89%B9%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>网络：由节点和边组成的结构</p><p>计算机网络：由主机节点（主机）和数据交换结点（数据的转发，如路由器交换机）构成的网络，边称为数据链路。</p><p>还可分为网络边缘（主机），网络核心（数据交换），接入（连接网络边缘和网络核心）</p><p>P2P（peer）：分布式处理，客户端也可以是服务端</p><p>吞吐量：在源主机和目标主机之间的有效传输速率</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>电路交换：独享资源，保证性能（计算机之间的通信有突发性，使用该方法则浪费的片较多）</p><p>分组交换：不独占资源，数据分组，存储转发（存在排队延迟和丢失，维护队列，超过长度则丢弃分组）</p><p>网络资源（如带宽）分成片：时分，频分，波分，码分</p><h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><p>节点处理延时：检查bit级差错，检查分组首部和决定将分组导向何处</p><p>排队延时：在输出链路上等待传输的时间</p><p>传输延时：将分组发送到链路上的时间</p><p>传播延时：在链路上的传输时间</p><h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><p>传输队列满，分组丢弃</p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>服务（service）：低层实体向上层实体提供它们之间的通信的能力</p><p>原语（primitive）：上层使用下层服务的形式</p><p>面向连接的服务：建立连接，通信，拆除连接（特点：保序）</p><p>无连接的服务：两个对等层实体在通信前不需要建立连接，不预留资源，不需要通信双方都是活跃（特点：不可靠，可能重复，可能失序）</p><h3 id="计算机网络层次结构"><a href="#计算机网络层次结构" class="headerlink" title="计算机网络层次结构"></a>计算机网络层次结构</h3><p>物理层：将帧转换为物理信号，在物理介质上传输（位）</p><p>数据链路层：使数据在相邻节点传输（帧）</p><p>网络层：使数据在端（主机）到端（主机）进行传输（分组packet，如果为无连接，称为数据报）</p><p>传输层：使数据在进程到进程进行传输，将网络层不可靠服务处理为可靠服务（报文段）</p><p>应用层：网络应用（报文）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）绪论</title>
      <link href="/2025/01/05/%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/01/05/%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>传输层：进程到进程</p><p>网络层：端到端（end to end），网络设备到网络设备</p><p>数据链路层：点到点（point to point）</p><p>物理层：数字信号与物理信号的转换</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft</title>
      <link href="/2025/01/05/Chapter4%20RAFT/"/>
      <url>/2025/01/05/Chapter4%20RAFT/</url>
      
        <content type="html"><![CDATA[<p>每个node维护一个election timeout（每次150ms-300ms随机）。作为follower，如果到了timeout则转为candidate</p><p>转完后参加vote：</p><ol><li>term+1</li><li>投给自己，并行发RequestVote RPC给所有的其他server</li><li>收server结果，如果获得超过半数的投票，则成为leader</li><li>如果没选出leader则进入election timeout，当选了则立刻发送一条AppendEntries消息给其他所有的服务器，没当选则等待leader的heartbeat</li></ol><p>在3前如果收到了其他candidate的RequestVote则重制timeout</p><p>term</p><p>拒绝过期的term</p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文导读 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMwareFT</title>
      <link href="/2025/01/05/Chapter3%20VMwareFT/"/>
      <url>/2025/01/05/Chapter3%20VMwareFT/</url>
      
        <content type="html"><![CDATA[<h4 id="状态转移和复制状态机"><a href="#状态转移和复制状态机" class="headerlink" title="状态转移和复制状态机"></a>状态转移和复制状态机</h4><p>状态转移（State Transfer）：Primary将自己的完整状态（例如内存中的内容），拷贝发给Backup</p><p>复制状态机（Replicated State Machine）：将来自客户端的操作或其他外部事件，从Primary传到Backup。由于<strong>外部操作比服务的状态要小得多</strong>，所以大多采用该方法，缺点是同步会比较复杂</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>主虚拟机(Primary VM)简称为主机，Backup VM 简称为备机</strong>。</p><p>VMware FT 需要两台物理服务器，主机与备机保持同步，虚拟机的虚拟磁盘在共享存储上。</p><p>所有的输入(如网络、鼠标、键盘等)都会输入到主机，然后通过 Logging channel 转发到备机，对于非确定性的操作，还将发送额外的信息，确保备机以确定性的方式执行这些操作。</p><p>两台虚拟机都会执行输入操作，但<strong>只有主机的输出会返回客户端，备机的输出会被管理程序丢弃</strong>。</p><img src="/../../images/VMware_ft_architecture.png" width=400px /><h4 id="非确定性事件"><a href="#非确定性事件" class="headerlink" title="非确定性事件"></a>非确定性事件</h4><p>非确定性事件：Primary和Backup执行会有不同的结果</p><table><thead><tr><th>事件</th><th>具体情况</th><th>解决方案</th></tr></thead><tbody><tr><td>客户端输入</td><td></td><td>通过log 确保网络数据包的内容，中断时间相同</td></tr><tr><td>怪异指令</td><td>随机数生成，时间获取等</td><td>Primary直接将结果传给Backup</td></tr><tr><td>多CPU的并发</td><td>不同的核做了不同的处理</td><td>论文没提到</td></tr></tbody></table><p>对于不确定性输入，必须记录足够的信息来重放，<em>但是论文中没有描述具体的日志格式</em>，可能有三种记录：</p><ul><li>事件发生时的指令序号；</li><li>日志类型。可能是普通的网络数据输入，也可能是怪异的指令；</li><li>数据</li></ul><img src="/../../images/VMware_logging.png" width=400px /><h4 id="输出控制"><a href="#输出控制" class="headerlink" title="输出控制"></a>输出控制</h4><p>VMware FT 通过确定性重放来产生相关的日志条目，但不将日志写入磁盘，而是通过 logging channel 发送给备机。备机实时重放日志项。</p><p>为了容错，必须在 loggin channel 上实现严格的容错协议，有以下要求：</p><p><strong>输出要求</strong>：如果备机在主机故障后接管，备机将以和主机已经向外界发送的输出完全一致的方式继续运行。</p><p>最简单的方式是对每一个输出操作创建一个特殊的日志项。</p><p>但有一种情况，假设虚拟机运行的是数据库，主机备机的数据都是 10。现在客户端发送自增请求，主机做了 <code>+1</code> 并回复给客户端 11，之后马上宕机了，更糟糕的是主机发送给备机的 <code>+1</code> 操作也丢包了。这时候备机还是 10，并接管了主机的工作，客户端再次请求 <code>+1</code>，又会收到 11 的回复。客户端会得到一个怪异的结果（自增两次还是 11）。</p><p>所以要求：</p><p><strong>输出规则：主机直到备机接收并确认了和输出相关的日志的时候，才发送输出给外界。</strong></p><p>这样做的目的是，只要备机收到了所有的日志条目，即使主机宕机了，备机仍能够重放到客户端最后看到的状态。</p><p>向外界的输出会被延迟，直到主机收到来自备机的确认。<strong>在Backup接管后需要把log buffer内的指令全部运行完才响应客户端的新请求。</strong></p><p><strong>几乎每一个复制系统都有这个问题：在某个时间点，主机必须停下来等待备机，这肯定会限制性能。</strong></p><blockquote><p>注意：因为没有两阶段提交事务，不能保证所有的输出只被生成一次。<strong>备机无法判断主机是在宕机之前还是之后发送了最后的输出，备机可能会重新执行一次输出操作</strong>。不过，VMware 通过其网络基础设施来检测重复数据包，并防止输出重传到客户端。</p></blockquote><h4 id="发现与处理故障"><a href="#发现与处理故障" class="headerlink" title="发现与处理故障"></a>发现与处理故障</h4><p>主机和备机必须快速知道另一方故障，通过 <strong>udp 心跳包</strong>和<strong>监控 logging channel 上的流量</strong>相结合来检测，如果心跳超时或 logging channel 流量停止则表明故障。</p><p>如果备机故障，主机就会停止向 logging channel 发送日志，继续正常运行。</p><blockquote><p>在这之后备机怎么追上主机呢？VMware有一个工具叫 VMotion，它能够在最小程度上中断虚拟机的执行，克隆一个虚拟机。</p></blockquote><p>如果主机故障，备机必须先重放，直到消耗完最后一个日志项。然后备机接替主机，开始向客户端生产输出。</p><p>为了确保一次只有一个虚拟机成为主机，避免出现脑裂，VMware 在共享存储上执行一个原子的 <code>test-and-set</code> 锁指令。该操作每次只能对其中一台机器返回成功，这在主机和备机因为网络分区都想接替工作时很有用。但如果共享存储因为网络问题不能访问，那么无论如何都不能正常工作。</p><p>当其中一台虚拟机发生故障时，VMware FT 会在另一台物理机上自动启动新的备份虚拟机来恢复冗余。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&mid=2247484239&idx=1&sn=27c7430f51e88628874ef1514cb6c152&chksm=9709808aa07e099c3d49637b05d62bf951ea48fa8e0c74b0d02f4af32e75569ea1bc535403ac&cur_album_id=1751707148520112128&scene=189#wechat_redirect">【MIT 6.824】学习笔记4: 主从复制(Primary&#x2F;Backup Replication)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文导读 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GFS</title>
      <link href="/2025/01/05/Chapter2%20GFS/"/>
      <url>/2025/01/05/Chapter2%20GFS/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>GFS是一个可以支持上千个机器和硬盘，上百用户同时访问的文件系统</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><table><thead><tr><th>问题或现象</th><th>解决办法</th></tr></thead><tbody><tr><td>机器错误</td><td>持续监控，错误发现，错误处理，自动恢复</td></tr><tr><td>文件过大</td><td>设计IO操作和block大小</td></tr><tr><td>大部分文件写为append而不是overwrite</td><td>只优化append保证性能和原子性</td></tr><tr><td>引入GFS特有文件读写方式</td><td>复用部分文件系统API</td></tr></tbody></table><h4 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h4><h5 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h5><ul><li>系统通过廉价机器组成</li><li>日常处理GB级的文件</li><li>写大部分为append</li><li>多个用户看到的同一个文件必须相同</li><li>保证高频使用的准确性</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>GFS<strong>不使用类似于POSIX的标准API</strong></p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>chunk：</strong>文件被分成<strong>固定大小</strong>的chunks。Chunkserver在本地磁盘保存chunks，通过chunk handle读写字节范围的chunk data</p><p><strong>master：</strong>master节点维护所有文件系统的<strong>元数据</strong>，包括namespace，可用的控制信息，文件到chunks的map-ping，当前所有chunks的存储位置。另外还控制系统级别的事件，比如chunk租约管理，孤立chunks的垃圾回收，chunkserver间的chunk迁移。master还会周期性地与chunkserver通信heartbeat信息，给它指令和收集信息</p><p><strong>client：</strong>GFS client节点链接所有应用实现文件系统API，代表应用程序<strong>与master和chunkserver通信</strong>。client只和masrer交换元数据，所有data通过直接与chunkserver通信拿到。client和chunkserver都不缓存文件data</p><img src="/../../images/gfs_architecture.png" width=700px /><h4 id="通信步骤（介绍GFS读方法）"><a href="#通信步骤（介绍GFS读方法）" class="headerlink" title="通信步骤（介绍GFS读方法）"></a>通信步骤（介绍GFS读方法）</h4><p>client不从master节点读写data，而是询问master哪个chunkserver可以访问，然后在一段时间内<strong>缓存</strong>该信息，之后直接与chunkserver通信</p><p>通信步骤如下：</p><ol><li>client将应用程序给的（file name，byte offset）转化为chunk index（offset&#x2F;chunk_size）</li><li>client将（file name，chunk index）传给master</li><li>master返回（chunk handle，chunk对应的所有备份文件的localtions）</li><li>client缓存这些信息，通过（file name，chunk index）和chunk handle的map记录</li><li>client优先向离自己最近的含有需要chunk的chunkserver请求（chunk handle，byte range），通常是请求所有的包含需要chunk的服务器</li><li>chunkserver返回client（chunk data）</li></ol><p>除非client的缓存信息过期或者文件被其他client打开，client不会访问master</p><p>由于读最近的server，所以<strong>data未必是最新的</strong></p><h4 id="Chunk大小"><a href="#Chunk大小" class="headerlink" title="Chunk大小"></a>Chunk大小</h4><p>chunk大小为64MB，选取这么大的优点是</p><ul><li>减少client和master的通信次数</li><li>减少client和master的TCP通信的overhead</li><li>减少master存储的元数据的大小</li></ul><p>缺点是</p><ul><li>如果原始data很小而且client一直访问它，会造成同一个chunk的高频访问</li></ul><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>master保存了三种主要的元数据</p><ul><li>file和chunk的namespace（NV）</li><li>file到chunks的映射（NV）</li><li>每个chunk副本的位置（V）</li></ul><p>所有元数据都存在master的内存中，前两个也存在持久化的log中，而且有远程的备份。对于第三个，master不使用持久化存储，因为master可以在启动后询问所有chunkserver它保存的chunk</p><h5 id="在内存中的数据结构"><a href="#在内存中的数据结构" class="headerlink" title="在内存中的数据结构"></a>在内存中的数据结构</h5><p>对于内存中元数据的周期性扫描可以实现</p><ul><li>chunk垃圾回收</li><li>在chunkserver出错时重新复制</li><li>为了平衡chunkservers中硬盘使用负载而需要的chunk迁移</li></ul><h5 id="chunk位置"><a href="#chunk位置" class="headerlink" title="chunk位置"></a>chunk位置</h5><p>master<strong>从不持久化记录</strong>哪几个chunkserver有特定chunk的副本，而是在启动时询问chunkserver这些信息</p><p>不进行持久化保存<strong>减少了master和chunkserver间的一些同步问题</strong>，比如chunkserver的退出和加入，名字的变化，失败和重启等等</p><h5 id="操作日志"><a href="#操作日志" class="headerlink" title="操作日志"></a>操作日志</h5><p>操作日志记录了每次重要的元数据变化，它不仅是元数据的持久化记录还规定了同步操作的顺序。只有在本地和远程的操作日志都更新后才进行具体操作。</p><p>使用checkpoint可以减少日志的大小，有问题时只需要从最近的checkpoint恢复即可</p><p>master 会在本地磁盘存储 log，而不是存到数据库，原因是：数据库的本质是某种 B 树或者 hash table，而相比之下追加 log 会更加高效；而且，通过在 log 中创建一些 checkpoint 点，重建状态也会更快</p><h4 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h4><h5 id="通过GFS保证"><a href="#通过GFS保证" class="headerlink" title="通过GFS保证"></a>通过GFS保证</h5><p><strong>file namespace</strong>的变化是原子的。通过master里的namespace锁保证</p><p>如果文件状态是consistent，则所有client看到的同个文件多个副本的data都是相同的，文件状态如下图</p><img src="/../../images/gfs_file_region.png" width=500px /><p>concurrent success表示所有client能看到相同的data但是不代表所有修改都被写入</p><p>应用程序可以区分undefined状态</p><p>GFS通过对于某个chunk及其所有副本以<strong>相同顺序写入</strong>来保证data是准确的，通过<strong>chunk version</strong>来标识写入的情况。过时的副本将不会参加接下来的变化或者被master将位置传给client，它将在之后以高优先级被回收</p><p>由于client缓存chunk位置，所以它<strong>可能会读到过时的chunk</strong>。这种情况无法避免，只能<strong>通过缓存时间失效并重新向master访问减少</strong></p><p>GFS通过<strong>定期向chunkserver握手</strong>，通过<strong>checksumming</strong>来检查问题。一旦有问题，data将尽早通过其他副本恢复。只有当所有副本都有问题时该data才会出错，应用程序会收到明确的错误信息而不是错误的data</p><h5 id="对应用程序的影响"><a href="#对应用程序的影响" class="headerlink" title="对应用程序的影响"></a>对应用程序的影响</h5><p>writer的所有record包含checksum等额外信息，来确保有效性</p><p>reader能够通过checksum来删除额外信息，找到data</p><h5 id="租约机制和修改顺序"><a href="#租约机制和修改顺序" class="headerlink" title="租约机制和修改顺序"></a>租约机制和修改顺序</h5><p>master会将chunk的lease（租约）授权给其中一个副本，称为primary，它可以规定修改的顺序，所有副本必须遵循primary的修改顺序</p><p>lease的timeout默认为60秒。然而只要chunk正在被改变，primary可以通过heartbeat message向master请求延长timeout。另外master也可以提前重新分配primary。</p><p>即使master断开了与primary的通信，只需要等待timeout后重新分配primary即可</p><h4 id="GFS写方法"><a href="#GFS写方法" class="headerlink" title="GFS写方法"></a>GFS写方法</h4><img src="/../../images/gfs_write.png" width=500px /><ol><li>client向master询问要写部分对应的chunk和chunkserver的信息，并知道其中哪个是primary</li><li>master返回chunk handle，chunkserver，primary chunkserver。client将信息缓存在本地。只有缓存信息过期才会去询问master</li><li>client将信息传给所有拥有副本的chunkserver</li><li>client发写指令给primary</li><li>primary以自己规定的顺序写，secondary和primary写的顺序保持一致</li><li>secondary写完后将信息同步给primary</li><li>primary告知client已写完或某步失败</li></ol><p>对于第一步，master可能不知道谁是primary，它会把version和所有拥有副本的chunkserver比较，过段时间后（使前一个lease过期，防止同时出现两个primary），取最新的version作为primary。master维护的version可能也不是最新的，如果落后也会更新到最新版本</p><h4 id="GFS的局限"><a href="#GFS的局限" class="headerlink" title="GFS的局限"></a>GFS的局限</h4><p>GFS 是<strong>宽松的一致性模型</strong>(relaxed consistency model)，可以理解是弱一致性的，它并<strong>不保证一个 chunk 的所有副本是相同的</strong></p><p><strong>GFS 最严重的局限性就在于它只有一个 master 节点</strong>(这篇文章讨论了这个问题：<a href="https://queue.acm.org/detail.cfm?id=1594206)%EF%BC%8C">https://queue.acm.org/detail.cfm?id=1594206)，</a> 单个 master 会带来以下问题：</p><ul><li>随着 GFS 的应用越来越多，文件也越来越多，最后 master 会耗尽内存来存储 metadata；你可以增加内存，但单台计算机的内存始终有上限；</li><li>master 节点要承载数千个 client 的请求，master 节点的 CPU 每秒只能处理数百个请求，尤其是还要将部分数据写入磁盘——client 的数量会超过单个 master 的能力；</li><li>弱一致性会导致应用程序很难处理 GFS 奇怪的语义；</li><li>最后一个问题，master 的故障切换不是自动的，需要人工干预来处理已经永久故障的 master 节点，并更换新的服务器，这需要几十分钟甚至更长的时间来处理。对于某些应用程序来说，这个时间太长了。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 论文导读 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“开卷”何必“有益”</title>
      <link href="/2025/01/03/%E5%BC%80%E5%8D%B7%E4%BD%95%E5%BF%85%E6%9C%89%E7%9B%8A/"/>
      <url>/2025/01/03/%E5%BC%80%E5%8D%B7%E4%BD%95%E5%BF%85%E6%9C%89%E7%9B%8A/</url>
      
        <content type="html"><![CDATA[<p>记得小学阅读课上，我在读一本悬疑小说并写到了读后感作业中，结果第二天就被老师批评，并以“开卷有益”这个成语来教导我说，你这种书以后少读读。当时，我就觉得老师这种说法一定是错的，但限于那时的表达能力和逻辑能力并不能给出完整的反驳，现写下此文以表述自己的想法。<br>“以后少读读”这句话一直在我脑海中，我不理解曾几何时，书之间也有了贵贱之分，难道读四大名著的就是好学生，读《福尔摩斯》的就是差学生吗？“开卷有益”指的是读书总有好处，并非告诉我们先对于书是否有益有了定性之后再去读。老师说的这些话显然是没有道理的。<br>那她又是出于什么原因这样说呢？说到底，四个字，功利主义。什么书对于学习有帮助那就是有益的，没帮助就是浪费时间。我们中的很多人从小被灌输这样一个观念：只有努力学习才能上好大学，只有上好大学才能找到好工作，才能有幸福的生活。曾经我也认为这句话是对的，为了以后能开心地生活现在必须努力学习。但真的是这样吗？从学校到工作到生话并非完全是后者依赖前者的先序关系，其中某一环节的丢失并不一定能影响到之后的生活。这种观点只是指出人生中几个重要结点，并对每一个结点提出要求。上了好大学能就能仕途一帆风顺，有了好工作真能天天开开心心享受生活？不尽然。<br>    前段时间，“鸡娃”一度成为社会热点问题，家长给孩子报了各种补课班，兴趣班，以求孩子能领先他人一步。我想，他们也许都是上文观点的拥趸，生怕自己孩子因为没补课而落后其他同学。其实，我小时候也是个“鸡娃”，从幼儿园开始补课直到高中毕业，周末只是换了个地方上课。现在看来，报那么多班其实未必有用，现在的我也只是刚从普通大学毕业，过着平淡的生话。每个人学习能力不同，那假设补课班是有用的，能让所有上课的孩子成绩提升，考上好大学，但那之后呢，补课班除了能培养出优秀的做题家外并不会给孩子带来什么。<br>    好大学并不是人生的终点，拥有幸福快乐的人生也不是名校生的特权，否则怎么会有某大学投毒案，某大学弑母案呢？这一切的一切都是功利主义在作祟，他们认为人生只需要为那几个重要结点去准备就行了，达到目的则视为成功，在他们的眼中，世界是线性的，必须要完成一个个小目标，追求利益最大化，否则就是失败。但他们不知道的是人生并不是一蹴而就的，阶段性的成功并不意味着什么。事物之间也在不断变化发展，幸福的人生并不是公式化的结果，在这之中更重要的是我们对为人处世的态度，以及对于个人，社会，以及世界的看法，这会贯穿人的一生，而非学校，工作等短暂的光环。<br>冯友兰先生将人生分为四种境界：自然镜界，功利境界，道德境界和天地境界。你我皆为凡人，虽难以达到“敬天爱人，天人合一”，但也不应在功利境界一直徘徊，为了眼前的利益患得患失。“开卷”何必“有益”，看自己想看的书，做自己想做的事，何必要按照公式走完自己的人生呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（三）指针</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-C-基础——指针"><a href="#第二章-C-基础——指针" class="headerlink" title="第二章 C++基础——指针"></a>第二章 C++基础——指针</h2><p>指针是一个变量，其存储的是值的地址，而不是值本身</p><p>使用常规变量时，值是指定的量，而地址是派生量，而指针相反</p><p><strong>OOP</strong>强调的是在运行阶段（而不是编译阶段）进行决策，提供了灵活性，对于内存管理也更加高效</p><h3 id="初始化指针"><a href="#初始化指针" class="headerlink" title="初始化指针"></a>初始化指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr_a;</span><br><span class="line"><span class="type">double</span>* ptr_b;</span><br></pre></td></tr></table></figure><p>初始化时必须指定所指元素类型，因为对所有指针来说其都是代表一个初始地址，但从该初始地址读多少字节则由指针类型判断</p><p>指针也是作为变量存储，只不过其内存空间存的是地址。指针p1,p2有各自的地址&amp;p1,&amp;p2。长度为4B（32位）或8B（64位）。p1,p2表示存储的所指向元素的地址。*p1表示指向元素的值。<br><img src="/../../images/1.png" alt="image.png" style="zoom:30%;" /></p><h3 id="指针注意事项"><a href="#指针注意事项" class="headerlink" title="指针注意事项"></a>指针注意事项</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存（指向不确定）。另外，<strong>一定要在对指针提取（*）之前，将指针初始化为一个确定的、适当的地址。</strong></p><p>一个未指向任何对象的指针，其地址值为0。有时称之为<code>null指针</code>。任何指针都可以被初始化或令其值为0。</p><p>指针不是整型，虽然计算机通常把地址当作整数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pt;</span><br><span class="line">pt = <span class="number">0xB80000000</span>; <span class="comment">//invalid, type mismatch</span></span><br><span class="line">pt = (<span class="type">int</span>*)<span class="number">0xB80000000</span>; <span class="comment">//valid, type match</span></span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>可以修改指针的值，但数组名是常量不能修改</p><p>指针变量加1后，其增加的值等于指向的类型占用的字节数</p><p>将一个指针减去另一个指针，获得两个指针的差（必须类型相同，差为地址实际差&#x2F;变量类型长度），仅在都指向同一数组时有意义</p><p>对数组应用sizeof得到的是数组的长度，而对指针应用sizeof得到的是指针的长度</p><h4 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h4><p>  tell和&amp;tell数值相同，但tell指向数组第一个元素，tell+1将地址值加2。&amp;tell指向整个数组，&amp;tell+1将地址值加2*10&#x3D;20</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> tell[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt; tell &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; &amp;tell &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>  数组指针指向整个数组，初始化为</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">short</span> (*pas)[<span class="number">10</span>] = &amp;tell;</span><br></pre></td></tr></table></figure><p>  指针数组为多个指针变量组成的数组，初始化为</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> *pas[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="自由存储空间"><a href="#自由存储空间" class="headerlink" title="自由存储空间"></a>自由存储空间</h3><h4 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeName * pointer_name = new typeName</span></span><br><span class="line"><span class="type">int</span>* pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```typeName*```指声明什么类型的指针，左右两侧的类型必须相同，否则因为读取的块大小不同而访问错误</span><br><span class="line"></span><br><span class="line">**变量存储在栈（stack）的内存区域中，new从堆（heap）或自由存储（free store）的内存区域分配内存**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用delete释放内存</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">int* ps = new int;</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure><p>这将删除<em>ps</em>所指向的内存，但不会删除<em>ps</em>本身，ps还可指向其他内存空间</p><p>需要注意的是：</p><ul><li>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存</li><li>不要使用<code>delete</code>释放同一个内存两次</li><li>对空指针(<em>null pointer</em>)使用<code>delete</code>是安全的</li></ul><h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] psome;</span><br></pre></td></tr></table></figure><p>数组直接通过<code>psome[num]</code>访问</p><p>需要注意的是：</p><ul><li>如果使用<code>new [] </code>为数组分配内存，则需要通过<code>delete []</code>来释放</li><li>如果使用<code>new</code>为一个实体分配内存，则应使用<code>delete</code>来释放</li></ul><h3 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h3><p>对于复杂表达式应从右往左读</p><p><code>int *&amp;r = p</code></p><p>表示r首先是对p的引用，其次r是一个int*型的引用</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p> 定义时必须初始化</p><p>不能改变绑定的指向（内部通过顶层const实现，type * const p）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//(pointer to b) equal to (pointer to a)</span></span><br></pre></td></tr></table></figure><p>引用间不能赋值</p><p>没有引用的引用，没有指针的引用，可以有引用的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;* p; <span class="comment">//illegal</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp; p)</span></span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（二）基本数据类型</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>当一个算术表达式中既有无符号数又有<code>int</code>值时，int会被转换为无符号数</li><li>当从无符号数中减去一个值时，不管这个值是不是无符号数，都必须保证结果不为负（否则为取模后值）</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量声明于定义的关系"><a href="#变量声明于定义的关系" class="headerlink" title="变量声明于定义的关系"></a>变量声明于定义的关系</h4><p>变量<strong>声明（declaration）</strong>定义了变量的类型和名字，<strong>定义（definition）</strong>在声明外还申请存储空间</p><p>如果只想声明，可在变量名前添加关键字<code>extern</code></p><p>变量只能被定义一次，但是可以多次声明</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（四）const限定符</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>const对象一经创建后其值不能再改变，所以const对象必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，const对象仅在文件内有效。若需在不同文件使用同一const对象，则const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>用于声明引用的const都是底层const，引用本身已默认为顶层const（无法改变指向）</p><p>const型变量只能由const型引用（底层const）</p><p>不能把普通引用绑定到字面值上，需用底层const</p><p>非const型变量可以由const型引用，但不可通过引用修改被引用变量值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">1</span>; <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><h3 id="指针和常量"><a href="#指针和常量" class="headerlink" title="指针和常量"></a>指针和常量</h3><p>若变量为const，则它的指针或引用必为const</p><p>要想存放常量对象的地址，只能使用指向常量的指针（底层const）</p><p>指向常量的指针（pointer to const）不能通过指针改变常量值 —— 底层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i; <span class="comment">// eqal to (int const *p =&amp;i;)</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><p>常量指针（const pointer）必须初始化，而且初始化完成后，其指向的地址不能再改变 —— 顶层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;i;</span><br><span class="line">p = &amp;j;<span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><p>指向常量的常量指针（const pointer to const），包含上述两种特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = &amp;i;</span><br></pre></td></tr></table></figure><p>类和const</p><p>函数后加const表示不修改任何成员变量（通过const *this实现 ）</p><p>如果类包含const变量，必须通过初始化列表初始化</p><h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><p>当执行对象的拷贝操作时，顶层const不受影响</p><p>底层const要求拷入和拷出的对象必须具有相同的底层const资格，或者两个对象能相互转换。非常量可以转化为常量（等号右侧表达式），反之不行</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（六）异常处理</title>
      <link href="/2025/01/03/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2025/01/03/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当执行throw时，throw后的语句都不执行，控制权转移到与之对应的catch模块</p><p>退出catch后，catch模块中的局部变量将会销毁</p><p>当异常处理完毕后，异常对象将被销毁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="built_in">catch</span> (exception_a)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="built_in">catch</span> (exception_b)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕捉catch（对于每个catch执行下述步骤）"><a href="#捕捉catch（对于每个catch执行下述步骤）" class="headerlink" title="捕捉catch（对于每个catch执行下述步骤）"></a>捕捉catch（对于每个catch执行下述步骤）</h3><ol><li>判断是否是精确匹配</li><li>派生类向基类转换（仅引用和指针类型）</li><li>（…）匹配所有</li></ol><p>其中一个被捕捉，跳过下面的catch</p><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>一条catch语句通过重新抛出的稻作将异常传递给另一个catch语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>new申请内存失败返回bad_alloc异常，不是返回0</p><p>处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（五）static关键字</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h3><p>static变量只能在当前文件访问，其他文件不能通过extern访问</p><h3 id="static局部变量"><a href="#static局部变量" class="headerlink" title="static局部变量"></a>static局部变量</h3><p>定义时创建，程序结束时销毁，修改了生命周期，作用域不变</p><h3 id="static类"><a href="#static类" class="headerlink" title="static类"></a>static类</h3><p>static对象的构造在main函数前执行，析构在main函数结束后</p><h3 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h3><p>存在于所有对象且保持一致，可在其他文件访问</p><p>不能在初始化列表初始化</p><p>需在类外定义，因为class内语句都是声明</p><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><p>可通过类名::函数调用，只能使用static成员变量，否则报错，没有this指针，不能访问非static成员 变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发面试题整理</title>
      <link href="/2025/01/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2025/01/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题汇总"><a href="#面试题汇总" class="headerlink" title="面试题汇总"></a>面试题汇总</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><strong>C 和 CPP 区别是什么</strong></p><table><thead><tr><th></th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>编程范式</td><td>面向过程</td><td>面向对象</td></tr><tr><td>函数重载</td><td>无</td><td>有</td></tr><tr><td>引用</td><td>无</td><td>有</td></tr></tbody></table><p><strong>C++编译过程</strong></p><p>预处理：展开include和define</p><p>编译：转化为汇编代码</p><p>汇编：转化为二进制机器码</p><p>链接：将目标和其需要的库链接成可执行文件</p><p><strong>指针和引用的区别</strong></p><table><thead><tr><th></th><th>指针</th><th>引用</th></tr></thead><tbody><tr><td>内存空间</td><td>占用</td><td>不占用</td></tr><tr><td>是否可为空</td><td>可以</td><td>不可以，必须只指向存在的变量</td></tr><tr><td>修改指向</td><td>可以</td><td>不可以</td></tr></tbody></table><p>其实<strong>引用在编译时作为const指针处理</strong></p><p><strong>C++ 内存分布</strong></p><img src="/../../images/memoryLayoutC.jpg" width=500px /><p><strong>sizeof数组是多少，指针是多少</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; endl;           <span class="comment">// 0x16fb9b28c</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;            <span class="comment">// 0x16fb9b28c</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;    <span class="comment">// 12 = 3 * 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a[<span class="number">1</span>]) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(&amp;a) &lt;&lt; endl;   <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">test</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组名和指针的区别</strong></p><p>对于数组名和指针是两个概念，但是对于<code>a[3]</code>来说a和&amp;a的地址是一样的，数组名a代表的是整个数组，当dereference如<code>a[1]</code>时，数组名转化为指向首元素的指针，得出的值为<code>*(a+1*sizeof(int))</code>，另外在做右值时a也会转化为指向首元素的指针（<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer">参考</a>）</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p><strong>继承方法</strong></p><p><strong>C++ 重载和重写的区别</strong></p><p>重载（Overloading）：重载是指在同一个作用域内，对一个函数或者运算符进行多次定义，每个定义有不同的参数列表或参数类型。通过重载，我们可以在同一个作用域内使用相同的函数名或运算符符号来执行不同的操作。</p><p>重写（Overriding）：重写是指在派生类中重新定义基类中已经存在的虚函数。重写后的函数与基类中的函数具有相同的函数名和参数列表，但是在派生类中的实现可以不同于基类中的实现。重写允许派生类覆盖基类的实现，以实现多态性。</p><p><strong>多态的概念</strong></p><p>不同的对象对于同一消息作出不同的响应。子类在继承父类后可以设计自己的版本，在运行时动态选择调用哪个版本实现</p><p><strong>静态绑定和动态绑定</strong></p><p>在面向对象编程中，静态绑定和动态绑定是两种不同的函数调用机制。</p><p><strong>静态绑定（Static Binding）</strong>，也称为早期绑定或编译期绑定，是指<strong>在程序编译时就将函数调用与函数实现绑定起来，而不考虑对象的实际类型</strong>。这种绑定是通过函数的名称和参数列表来实现的。在静态绑定中，编译器会<strong>在编译期间确定调用哪个函数</strong>，而不是在运行时确定。静态绑定通常适用于非虚函数的调用，因为非虚函数的调用是在编译期间就可以确定的。</p><p><strong>动态绑定（Dynamic Binding）</strong>，也称为晚期绑定或运行时绑定，是指<strong>在程序运行时根据对象的实际类型来决定调用哪个函数</strong>。这种绑定是通过虚函数来实现的。在动态绑定中，编译器会在运行时确定调用哪个函数，而不是在编译期间确定。动态绑定适用于需要实现多态性的情况，可以<strong>让基类指针或引用调用派生类中的函数实现，实现运行时多态性</strong>。</p><p><strong>虚函数</strong></p><p><strong>作用</strong></p><ul><li><p>实现动态多态性（Runtime Polymorphism）：通过使用虚函数，可以在运行时动态地确定调用的是基类函数还是派生类函数，实现多态性。例如，如果我们有一个指向基类对象的指针，我们可以使用虚函数来调用派生类中的适当函数。</p></li><li><p>支持运行时类型识别（RTTI）：通过使用虚函数和类型信息（type information），可以在运行时确定对象的实际类型，从而实现更加灵活的代码设计。</p></li><li><p>简化代码维护：使用虚函数可以将代码的实现细节从类的使用者中分离出来，使得修改基类的实现对派生类的影响最小。</p></li></ul><p><strong>实现</strong></p><p>类保存指向保存了所有虚函数指针的表（vtable）的指针（vptr），通过基类指针调用虚函数时访问vtable选择特定的函数指针调用</p><p><strong>类中有一个虚函数大小是多少</strong></p><p>为一个指针的大小</p><p><strong>C++ 的友元</strong></p><p>可以访问一个类的非公有成员的函数或类。作用是提高代码封装性，简化了一些实现</p><ul><li>友元函数：该函数可以访问该类的私有成员和保护成员</li><li>友元类：该类可以访问该类的私有成员和保护成员</li><li>友元成员函数：该成员函数的私有成员和保护成员</li></ul><p><strong>空类包括什么成员</strong></p><p>不包含任何成员，只是sizeof时为1，应为C++中每个对象大小必须大于0</p><p><strong>悬空指针所指向的内存被释放了，那么这个指针还存在吗</strong></p><p>存在，只是释放了指向的内容</p><p><strong>浅拷贝和深拷贝有什么区别</strong> </p><p>浅拷贝为字节流的拷贝，对于指针来说，通过浅拷贝会使新对象和旧对象指向同一块内存（类默认的拷贝构造和拷贝赋值）</p><p>深拷贝在复制时为指针分配新的内存，新对象和旧对象有各自独立的空间</p><p><strong>一个类的大小由什么决定</strong></p><p>成员变量的个数，是否继承，是否有虚函数等，有虚函数的话，那么类就会多一个虚表指针，类的大小就会多8字节</p><p><strong>一个子类继承空基类，对子类的大小会有影响吗 (空白基优化)</strong></p><p>不会，基类大小的1优化成0</p><h5 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h5><p><strong>左值和右值引用</strong></p><p>左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong></p><p>使用<code>std::move()</code>可以将左值转化为右值，其在调用右值的拷贝时为浅拷贝，性能较深拷贝强。但作为右值被使用后，这个变量不应该再使用</p><p><strong>悬空指针和野指针的区别</strong></p><p>悬空指针为指针最初指向的内容已经被释放的指针</p><p>野指针是没初始化的指针</p><p><strong>智能指针，循环引用会怎么样</strong></p><p>内存泄漏</p><p>可以这样避免</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;B&gt; p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  weak_ptr&lt;A&gt; p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sharedptr 和weakptr使用场景</strong></p><ul><li><code>unique_ptr</code><br>只允许基础指针的一个所有者</li><li><code>shared_ptr</code><br>采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 <code>shared_ptr</code> 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块</li><li><code>weak_ptr</code><br>结合 <code>shared_ptr</code> 使用的特例智能指针。 <code>weak_ptr</code> 提供对一个或多个 <code>shared_ptr</code> 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 <code>shared_ptr</code> 实例间的循环引用。</li></ul><p><strong>在A函数里用指针申请好空间后，这块空间需要返回给B函数，然后B函数使用后不再使用这块内存，虽然我们可以手动释放，但往往可能忘记释放，请问用什么方式解决？（智能指针解决）</strong></p><p>A为shared pointer，B为A的weak pointer</p><p><strong>智能指针的局限</strong></p><p>智能指针<strong>不能用于指向栈上的对象或静态变量</strong>，因为这些对象的生命周期是<strong>由编译器控制的</strong>，不需要手动管理内存。<br>智能指针可能会<strong>对性能产生一定的开销</strong>，因为它们需要维护引用计数、析构器等信息</p><h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><p><strong>map和set插入删除有啥区别</strong></p><p><strong>说一下迭代器失效的情况，以及解决方法</strong></p><p>在C++ STL中，迭代器是一种指向容器中元素的对象，它提供了访问容器元素的能力，从而使得程序员可以对容器中的元素进行遍历、修改等操作。然而，在某些情况下，迭代器可能会失效，即不能继续使用。以下是一些常见的导致迭代器失效的情况：</p><ol><li>容器大小发生改变</li></ol><p>在使用迭代器遍历容器的过程中，如果容器的大小发生改变（如插入或删除元素），则迭代器可能会失效。此时，继续使用失效的迭代器会导致程序崩溃或产生不可预期的结果。</p><ol start="2"><li>插入元素导致内存重新分配</li></ol><p>对于一些容器（如vector、deque），在容器中插入元素时，可能会导致容器重新分配内存。如果此时使用了失效的迭代器，则可能会指向一个已被释放的内存地址，进而导致程序崩溃或产生不可预期的结果。</p><ol start="3"><li>删除元素导致迭代器失效</li></ol><p>在使用迭代器遍历容器的过程中，如果删除了容器中的元素，则可能导致迭代器失效。例如，对于vector容器，当使用erase()方法删除元素时，该元素之后的所有迭代器都会失效，因为它们指向的元素已经被删除。</p><p>为了避免迭代器失效，可以采取以下方法：</p><ol><li>使用迭代器前先进行检查</li></ol><p>在使用迭代器前，可以先检查容器中的元素是否发生了改变，从而避免使用失效的迭代器。例如，可以在循环遍历容器的时候，在每次循环前检查容器大小是否发生改变。</p><ol start="2"><li>使用智能指针或引用</li></ol><p>智能指针或引用是一种安全的访问容器中元素的方式，因为它们不会失效。在使用迭代器时，可以将它们转换为智能指针或引用，从而避免迭代器失效。</p><ol start="3"><li>使用成员函数返回值</li></ol><p>对于某些容器（如vector、deque），它们的成员函数返回值本身就是迭代器，而且使用这些函数返回的迭代器不会失效。例如，使用vector的begin()和end()方法返回的迭代器可以安全地用于遍历容器，即使在容器中插入或删除元素时也不会失效。</p><p><strong>函数返回引用类型和普通类型有什么区别</strong></p><p>函数返回引用类型和普通类型的最大区别在于，返回引用类型的函数可以返回一个左值，而返回普通类型的函数只能返回一个右值。</p><p>当一个函数返回引用类型时，返回值实际上是对一个对象的引用。如果这个对象是一个变量，那么这个函数返回的就是这个变量的引用，也就是一个左值。在这种情况下，返回值可以被用作左值进行赋值或修改。</p><p><strong>如果设计一个string类，头文件应该怎样设计？写头文件就行了。列举出需要哪些函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_STRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_STRING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_string</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="built_in">my_string</span>();</span><br><span class="line">  <span class="built_in">my_string</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">  <span class="built_in">my_string</span>(<span class="type">const</span> my_string&amp; other);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">my_string</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值运算符</span></span><br><span class="line">  my_string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> my_string&amp; other);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下标运算符</span></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串拼接运算符</span></span><br><span class="line">  my_string <span class="keyword">operator</span>+(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串比较运算符</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="built_in">operator</span>&lt;=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串长度函数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串查找函数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> my_string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串截取函数</span></span><br><span class="line">  <span class="function">my_string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* data_; <span class="comment">// 存储字符串的动态数组</span></span><br><span class="line">  <span class="type">size_t</span> size_; <span class="comment">// 字符串的长度</span></span><br><span class="line">  <span class="type">size_t</span> capacity_; <span class="comment">// 存储字符串的动态数组的容量</span></span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> npos = <span class="number">-1</span>; <span class="comment">// 无效位置的标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_STRING_H</span></span></span><br></pre></td></tr></table></figure><p>可以增加右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">my_string::<span class="built_in">my_string</span>(my_string&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">capacity_</span>(other.capacity_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    <span class="comment">// 将原对象置为空</span></span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">    other.capacity_ = <span class="number">0</span>;</span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_string&amp; my_string::<span class="keyword">operator</span>=(my_string&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前对象的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原对象的资源转移给当前对象</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原对象置为空</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.capacity_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector是什么？vector的底层实现？vector的扩容机制？</strong> </p><p><strong>deque是什么？deque的底层实现？怎么实现O(1)头插？</strong> </p><p><strong>map有几类？底层实现是什么？红黑树是什么？平衡树怎么实现平衡？</strong> </p><p><strong>set和map的区别？</strong></p><p><strong>set和map的理解及使用场景</strong></p><p><strong>map和unordered_map的结构及使用场景</strong></p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p><strong>内核态和用户态区别</strong></p><p>操作系统中内核态和用户态是两种运行模式，区别如下：</p><ol><li><strong>权限不同</strong>：内核态具有更高的权限，可以执行所有的指令，包括访问系统资源、执行特权指令等，而用户态则只能执行受限的指令，不能直接访问系统资源。</li><li><strong>执行环境不同</strong>：内核态运行在操作系统内核的上下文中，而用户态则运行在用户程序的上下文中。</li><li><strong>系统调用</strong>：用户态程序如果需要访问系统资源或执行特权指令，需要通过系统调用的方式切换到内核态，由内核代表用户程序执行相应的操作。</li><li><strong>中断处理</strong>：当硬件设备发生中断时，操作系统会切换到内核态进行中断处理，以保证系统正常运行。</li></ol><p><strong>线程间的同步方式</strong></p><ol><li><strong>互斥锁（Mutex）</strong>：使用互斥锁可以保证同一时间只有一个线程可以访问共享资源。当一个线程获得互斥锁后，其他线程需要等待该线程释放锁后才能再次尝试获取锁。</li><li><strong>信号量（Semaphore）</strong>：信号量是一个计数器，用于控制同时访问某个共享资源的线程数量。当某个线程需要访问共享资源时，它必须先获取信号量。如果当前信号量计数为0，则线程需要等待，直到有其他线程释放信号量。</li><li><strong>条件变量（Condition Variable）</strong>：条件变量用于线程间的通信和同步，当一个线程需要等待某个条件满足时，可以使用条件变量来阻塞自己，等待其他线程发出通知。当条件满足时，其他线程可以发出信号通知等待的线程继续执行。</li><li><strong>屏障（Barrier）</strong>：屏障用于控制多个线程在某个点上同步。当所有线程都到达这个点时，才能继续执行后面的代码。这种同步方式通常用于多个线程执行完某个任务后需要进行汇总的场景。</li><li><strong>读写锁（Read-Write Lock）</strong>：读写锁用于在多线程环境下对共享资源进行读写操作的同步。读写锁分为读锁和写锁两种，多个线程可以同时获得读锁，但只能有一个线程获得写锁。这样可以在保证数据一致性的前提下提高并发性能。</li></ol><p><strong>进程间的通信方式</strong></p><ol><li><strong>管道（Pipe）</strong>：管道是一种半双工的IPC机制，可以在两个进程之间传递数据。管道分为无名管道和命名管道两种，<strong>无名管道只能在具有亲缘关系的进程之间使用，而命名管道可以在不同进程之间使用</strong>。<strong>缺点：在没有读数据前不可以写数据</strong></li><li><strong>消息队列（Message Queue）</strong>：消息队列是一种基于队列的IPC机制，多个进程可以通过发送和接收消息来进行通信。消息队列具有一定的<strong>缓存能力</strong>，可以在进程之间传递不同大小的数据块。<strong>缺点：每个消息大小固定，队列大小受限，并且需要把消息从用户态拷贝到内核态</strong></li><li><strong>共享内存（Shared Memory）</strong>：共享内存是一种快速且高效的IPC机制，多个进程可以访问同一块物理内存，从而实现数据共享。共享内存需要使用信号量等同步机制来保证数据的一致性。</li><li><strong>信号（Signal）</strong>：信号是一种异步通信机制，可以用于向进程发送通知。当一个进程接收到信号时，会执行相应的信号处理函数。常见的<strong>信号包括中断信号和软件信号等</strong>。</li><li><strong>套接字（Socket）</strong>：套接字是一种通用的IPC机制，可以在不同的进程之间传递数据。套接字通常用于网络编程中，可以实现不同计算机之间的进程通信。</li></ol><p><strong>线程安全要加锁，什么情况可以不加锁?</strong></p><p>线程安全是指在多线程环境下，对共享数据的访问操作不会出现冲突或竞争，从而保证程序的正确性和可靠性。为了实现线程安全，通常需要对共享数据的访问加锁。</p><p>然而，并非所有情况都需要对共享数据加锁，以下是一些情况：</p><p>1**.只读访问**：如果一个共享数据只会被读取而不会被修改，那么在多个线程同时访问时就不需要加锁。因为只读操作不会改变数据的值，所以多个线程同时读取同一个数据也不会出现冲突。</p><p>2.<strong>线程本地存储</strong>：有些数据只需要在一个线程内部使用，不需要在多个线程之间共享，那么就不需要对这些数据加锁。例如，每个线程都有一个独立的栈空间，线程内部的栈空间就是线程本地存储，不需要对其加锁。</p><p>3.<strong>不变对象</strong>：如果一个对象在创建后就不再被修改，那么多个线程同时访问它也不需要加锁。因为对象不会被修改，所以多个线程同时访问同一个对象也不会出现冲突。</p><p>需要注意的是，虽然上述情况下不需要加锁，但仍然需要保证数据的可见性。为了保证数据的可见性，可以使用volatile关键字或者synchronized块来同步内存中的数据</p><p><strong>死锁（怎么预防）</strong></p><p>破坏“请求与保持”：一次性申请进程所需的所有资源</p><p>破坏“循环等待”：资源按顺序申请（其实达不到，没法预测程序走的分支）</p><p><strong>死锁避免（拒绝某些资源请求）</strong></p><p>每次申请资源都要判断是否出现死锁的危险，如果有危险就拒绝这次请求</p><p>通过<strong>银行家算法</strong>计算安全序列，充分性算法，<strong>完全避免死锁</strong></p><p>算法优先分配给能满足进程所需最大资源量的进程，一次分配所有所需要的所有资源</p><p><strong>死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）</strong></p><p>检测发生死锁的进程（资源未被使用，进程长时间未调度等），恢复进程并重新分配资源（<strong>改进的银行家算法</strong>）</p><p>改进的银行家算法分配每次进程请求的资源，而不是分配所需的所有资源，因为有事进程对于资源使用后就会释放，这样系统有更多余量</p><p><strong>虚拟内存和物理内存的关系</strong></p><p>虚拟内存将<strong>硬盘上的一部分空间映射到了物理内存中</strong>，通过<strong>地址映射</strong>实现虚拟内存和物理内存的交互。当应用程序需要访问某个地址时，操作系统<strong>先检查该地址是否在物理内存</strong>中，如果不在物理内存中，则从虚拟内存中将该地址所对应的数据读取到物理内存中。当物理内存中的空间不足时，操作系统会将一些较少使用的数据换出到硬盘上，以释放物理内存空间供其他程序使用。</p><p><strong>在4G物理内存机器上申请8G内存</strong></p><p>在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</p><p>在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题（申请只是分配虚拟内存，只有访问时才会调用缺页中断分配物理内存），因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：</p><ul><li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li><li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li></ul><p><strong>函数调用对内存的使用</strong></p><ol><li>所需参数压栈</li><li>返回地址压栈</li><li>被调用函数局部变量压栈</li><li>被调用函数局部变量出栈</li><li>返回地址出栈</li><li>所需参数出栈</li></ol><p>实际1，2不同的编译器和语言有差异，另外参数也可以通过寄存器传</p><p><strong>从磁盘预读的数据可能最后没有用到，有什么改善方法（预读污染）；批量读数据时可能会把热点数据挤出，有什么改善方法（缓存污染）</strong></p><p>传统的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><p>为了避免「预读失效」造成的影响，Linux 和 MySQL 对传统的 LRU 链表做了改进：</p><ul><li>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）</strong>。</li><li>MySQL Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li></ul><p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么<strong>还存在缓存污染的问题</strong>。</p><p>为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：</p><ul><li><p>Linux 操作系统：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</p></li><li><p>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行</p><p>停留在 old 区域的时间判断</p><ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p><strong>五大 IO 模型</strong></p><ol><li>阻塞 I&#x2F;O (Blocking I&#x2F;O)</li></ol><p>在阻塞 I&#x2F;O 中，当用户线程发起一个 I&#x2F;O 操作时，线程会一直阻塞等待，直到内核完成 I&#x2F;O 操作并将结果返回给用户线程。这种模型非常简单易懂，但是效率很低，因为当一个线程阻塞等待 I&#x2F;O 完成时，CPU 时间无法充分利用，这会导致程序的性能受到严重影响。</p><ol start="2"><li>非阻塞 I&#x2F;O (Non-blocking I&#x2F;O)</li></ol><p>在非阻塞 I&#x2F;O 中，用户线程发起一个 I&#x2F;O 操作后并不会阻塞，而是立即返回，然后线程不断地轮询该操作是否完成。这种模型比阻塞 I&#x2F;O 的效率高，但是也会导致 CPU 占用率过高，因为线程需要不断地轮询操作状态，浪费了大量的 CPU 资源。</p><ol start="3"><li>I&#x2F;O 多路复用 (I&#x2F;O Multiplexing)</li></ol><p>I&#x2F;O 多路复用可以监视多个文件描述符（sockets、标准输入输出、套接字等等）的可读可写等状态，当任何一个文件描述符就绪（可读或可写）时，就能够通知相应的线程进行读写操作。这种模型使用 select、poll、epoll 等多路复用技术，可以有效地避免线程阻塞等待 I&#x2F;O 完成的问题，提高程序的并发处理能力。</p><ol start="4"><li>信号驱动 I&#x2F;O (Signal-driven I&#x2F;O)</li></ol><p>信号驱动 I&#x2F;O 使用信号机制通知用户线程 I&#x2F;O 操作已经完成。在这种模型中，当用户线程发起 I&#x2F;O 操作后，内核会立即返回并允许线程继续执行其他任务。当 I&#x2F;O 操作完成后，内核会向用户线程发送一个信号来通知操作已经完成，然后线程可以调用相应的系统调用来读取数据。信号驱动 I&#x2F;O 可以避免线程阻塞等待 I&#x2F;O 完成的问题，但是也会导致一些其他问题，例如信号可能会被其他程序捕获，使得程序难以控制。</p><ol start="5"><li>异步 I&#x2F;O (Asynchronous I&#x2F;O)</li></ol><p>异步 I&#x2F;O 中，用户线程发起 I&#x2F;O 操作后，内核会立即返回并允许线程继续执行其他任务。当 I&#x2F;O 操作完成后，内核会向用户线程发送一个通知来告诉它操作已经完成，然后线程可以调用相应的系统调用来读取数据。异步 I&#x2F;O 模型可以避免线程阻塞等待 I&#x2F;O 完成的问题，并且可以自动处理 I&#x2F;O 缓冲区的数据传输</p><table><thead><tr><th>IO 模型</th><th>第一阶段</th><th>第二阶段</th></tr></thead><tbody><tr><td>阻塞式IO</td><td>阻塞</td><td>阻塞</td></tr><tr><td>非阻塞式IO</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>IO多路复用</td><td>阻塞（Select）</td><td>阻塞</td></tr><tr><td>信号驱动式IO</td><td>异步</td><td>阻塞</td></tr><tr><td>异步IO</td><td>异步</td><td>异步</td></tr></tbody></table><img src="/../../images/io_module.png" width=700px /><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p><strong>TCP 三次握手</strong></p><p>步骤为：</p><ol><li>client传给server自己的SYN c</li><li>server传给client自己的SYN s，对于server SYN的确认ACK c+1表示下个要接收的数据包序号</li><li>client传给server对于server SYN的确认ACK s+1</li></ol><p>为什么不是2次？</p><p><strong>防止历史连接的建立，造成资源浪费，而且无法可靠同步双方序号</strong></p><p>如果有一个历史连接到达server，对于两次连接server会立即分配资源，把ack c+1传给client，但是client比对下不是自己需要建立的连接，会拒绝请求，把RST发给server。相当于server白申请资源</p><p><strong>TCP与UDP区别</strong></p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>建立连接</td><td>有</td><td>无</td></tr><tr><td>流量控制</td><td>有</td><td>无</td></tr><tr><td>拥塞控制</td><td>有</td><td>无</td></tr><tr><td>有序</td><td>有</td><td>无</td></tr></tbody></table><p><strong>Tcp和Udp使用场景</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信</li></ul><p><strong>流量控制和拥塞控制</strong></p><p><strong>Get和Post</strong></p><table><thead><tr><th></th><th>Get</th><th>Post</th></tr></thead><tbody><tr><td>可被缓存</td><td>可以，浏览器或者server可以换讯</td><td>不可以</td></tr><tr><td>参数传递方式</td><td>url里</td><td>body里</td></tr><tr><td>应用场景</td><td>数据的请求，查询，搜索</td><td>提交数据，上传文件</td></tr><tr><td>请求大小</td><td>几KB到几百KB</td><td>理论上没限制</td></tr></tbody></table><p><strong>HTTP和HTTPS</strong></p><table><thead><tr><th></th><th>Http</th><th>Https</th></tr></thead><tbody><tr><td>安全性</td><td>明文传输</td><td>采用SSL&#x2F;TLS协议对数据加密</td></tr><tr><td>传输方式</td><td>TCP</td><td>SSL&#x2F;TLS</td></tr><tr><td>默认段口号</td><td>80</td><td>443</td></tr></tbody></table><p><strong>url解析</strong></p><ol><li>访问缓存，包括浏览器，操作系统缓存，hosts，本地域名服务器</li><li>通过本地域名服务器访问根DNS服务器获得对应顶级DNS服务器的地址</li><li>通过本地域名服务器访问顶级DNS服务器获得对应权威DNS服务器的地址</li><li>通过本地域名服务器访问权威DNS服务器获得ip</li><li>本地域名服务器将ip返回给主机</li></ol><p><strong>http1.1和http2</strong></p><p>HTTP&#x2F;1.1和HTTP&#x2F;2是两个不同的HTTP协议版本，下面是它们之间的一些主要差别：</p><ol><li><strong>多路复用</strong>：HTTP&#x2F;1.1协议使用串行化的方式在一个TCP连接上依次传输多个HTTP请求和响应，这样会产生一些性能瓶颈。而HTTP&#x2F;2协议则使用多路复用的方式，通过<strong>在同一个TCP连接上并行传输多个HTTP请求和响应</strong>，提高了性能和效率。</li><li><strong>头部压缩</strong>：HTTP&#x2F;1.1协议的请求和响应头部信息没有压缩，这样会占用较多的带宽和网络资源。而HTTP&#x2F;2协议引入了头部压缩机制，可以有效地减少网络传输的数据量，提高性能和效率。</li><li><strong>服务器推送</strong>：HTTP&#x2F;1.1协议需要客户端发起每个请求，服务器无法主动推送内容给客户端。而HTTP&#x2F;2协议允许服务器<strong>在客户端请求之前主动推送内容给客户端</strong>，可以减少客户端请求的次数和提高性能。</li><li><strong>流量控制</strong>：HTTP&#x2F;2协议引入了流量控制机制，可以对每个流进行流量控制，避免网络拥塞和资源竞争。而HTTP&#x2F;1.1协议没有流量控制机制，容易导致网络拥塞和性能瓶颈。</li><li><strong>请求优先级</strong>：HTTP&#x2F;2协议允许客户端设置请求的优先级，可以确保高优先级的请求优先得到响应，提高性能和效率。而HTTP&#x2F;1.1协议没有请求优先级机制，容易导致低优先级的请求得不到及时响应。</li></ol><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><strong>什么情况下建立索引</strong></p><ol><li>频繁使用的列：对于经常用于 WHERE 子句或 JOIN 子句中的列，可以考虑创建索引，以便更快地查询这些数据。</li><li>唯一性约束：对于需要唯一性约束的列，例如主键或唯一索引，需要创建索引来确保数据的唯一性。</li><li>外键约束：对于外键约束，也需要在相关的列上创建索引以提高查询性能。</li><li>多表连接：当进行多表连接时，可以在涉及到的列上创建索引，以提高查询性能。</li><li>经常使用的排序列：对于经常用于排序操作的列，可以创建索引，以提高排序的性能</li></ol><p><strong>MySQL 存储引擎有哪些</strong></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><strong>protobuf，它和 JSON 的区别是什么，为什么使用它</strong></p><ol><li>性能：由于 Protobuf 的大小和速度优势，它非常适合在网络上发送大量数据的情况。例如，如果您正在构建一个需要大量数据传输的分布式系统，那么 Protobuf 可能比 JSON 更好。</li><li>类型定义：Protobuf 的类型定义可以强制执行消息格式的正确性，这可以帮助您在发送和接收消息时避免错误。</li><li>兼容性：Protobuf 具有跨平台兼容性，并且提供了各种语言的支持库。因此，如果您正在构建一个需要跨多种编程语言进行通信的系统，那么 Protobuf 可能比 JSON 更好。</li><li>可扩展性：由于 Protobuf 可以定义任意数量的字段和消息类型，因此它非常适合在以后需要添加或更改消息格式的情况下使用。与 JSON 相比，Protobuf 更易于维护和扩展。</li></ol><p><strong>RPC 协议和 HTTP 协议的区别和特点</strong></p><p>RPC（Remote Procedure Call，远程过程调用）协议和 HTTP（Hypertext Transfer Protocol，超文本传输协议）协议是两种不同的网络通信协议，它们的区别和特点如下：</p><ol><li>通信方式</li></ol><p>RPC 协议和 HTTP 协议的通信方式不同。<strong>RPC 协议是基于函数调用的方式进行通信的</strong>，<strong>客户端通过调用远程服务端暴露的 API 接口</strong>，实现远程过程调用。<strong>HTTP 协议则是基于请求-响应的方式进行通信的</strong>，客户端通过向服务器发送 HTTP 请求，并接收服务器返回的 HTTP 响应来进行通信。</p><ol start="2"><li>传输协议</li></ol><p>RPC 协议和 HTTP 协议使用的传输协议也不同。<strong>RPC 协议通常使用二进制协议</strong>进行传输，如 Protobuf、Thrift 等，以提高传输效率和可靠性。而 <strong>HTTP 协议则通常使用文本协议进行传输</strong>，如 JSON、XML 等。在一些特殊情况下，也可以使用二进制协议，如 HTTP&#x2F;2 协议中的二进制帧。</p><ol start="3"><li>请求方式</li></ol><p>RPC 协议和 HTTP 协议的请求方式也不同。<strong>RPC 协议通常使用不同的 RPC 方法来表示不同的请求类型</strong>，如 gRPC 中使用的 RPC 方法名。而 <strong>HTTP 协议则使用不同的 HTTP 方法来表示不同的请求类型</strong>，如 GET、POST、PUT、DELETE 等。</p><ol start="4"><li>性能和效率</li></ol><p>RPC 协议和 HTTP 协议在性能和效率上也有一定的区别。由于 RPC 协议使用二进制协议进行传输，相对于 HTTP 协议使用文本协议进行传输，它<strong>在传输效率和带宽利用率上具有优势</strong>。同时，RPC 协议也<strong>更加灵活和高效</strong>，可以根据不同的应用场景进行优化。然而，HTTP 协议作为一种通用协议，在跨平台、跨语言、跨网络等方面具有优势。</p><ol start="5"><li>应用场景</li></ol><p>RPC 协议和 HTTP 协议适用于不同的应用场景。<strong>RPC 协议通常用于高性能、大规模分布式系统的通信</strong>，如微服务架构、数据中心内部通信等。而 <strong>HTTP 协议则更适用于 Web 应用和客户端-服务器模式的通信</strong>，如浏览器和服务器之间的通信、RESTful API 等。</p><p>总之，RPC 协议和 HTTP 协议都有各自的优点和局限性，在实际应用中需要根据具体的应用场景和需求来选择适合的协议。</p><p><strong>浏览器较少支持grpc对http2原语的较低级别的访问，需要通过grpc-web做代理</strong></p><p><strong>GRPC通信流程</strong></p><p>gRPC 通信流程一般包括以下几个步骤：</p><ol><li>编写 <code>.proto</code> 文件定义服务接口：首先需要使用 Protocol Buffers 定义接口和消息格式，将接口定义保存在 <code>.proto</code> 文件中。</li><li>生成客户端和服务端代码：使用 Protocol Buffers 编译器 <code>protoc</code> 将 <code>.proto</code> 文件编译为客户端和服务端所需要的代码。</li><li>启动服务端：服务端通过监听指定的端口，等待客户端的连接请求。</li><li>客户端发起调用请求：客户端使用生成的 SDK 中提供的 stub 函数调用服务端提供的方法，并将请求参数传递给服务端。</li><li>服务端处理请求并返回响应：服务端接收到客户端的请求后，根据请求参数执行对应的逻辑，并将处理结果封装为响应对象返回给客户端。</li><li>客户端接收响应并处理：客户端接收到服务端的响应后，根据响应参数执行对应的逻辑，完成一次 RPC 调用。</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p><strong>单例模式</strong></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>B树</p><p>DFS</p><p>BFS</p><p>每个stl的初始化方法</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p><strong>线性一致，强一致，最终一致</strong></p><p><strong>强一致性</strong>要求分布式系统中的每个节点都保持同步，任何时刻都能够读取到最新的数据，并且每个节点读取到的数据都是相同的。换句话说，强一致性下，分布式系统中的所有节点都能够看到同样的数据，而且所有节点的数据都是最新的。这种一致性模型是最常见的一种，也是很多应用程序最基本的需求。</p><p><strong>线性一致性</strong>是强一致性的一种特殊形式。它要求系统中的所有节点必须按照相同的顺序读取写入操作，而且这个顺序必须是全局有序的，也就是说，所有操作的顺序都是唯一确定的。这种模型通常用于需要有序的多节点事务，如交易系统等</p><p>假设有一个分布式系统，里面有三个节点：节点A、节点B、节点C。现在有一个操作需要在这三个节点上执行，并且需要保证强一致或线性一致。</p><p>在强一致性模型下，这个操作必须在所有节点上同时执行，并且执行结果必须相同。例如，如果这个操作是将某个数据从0改成1，那么在所有节点上执行结束之后，这个数据必须在所有节点上都是1，否则操作失败。</p><p>在线性一致性模型下，这个操作可以在任意一个节点上执行，只要这个节点的执行结果被所有节点看到的时间都是一样的。例如，如果这个操作是将某个数据从0改成1，那么执行这个操作的节点可以是任意一个节点，只要在所有节点看到的时间上，这个数据从0改成1的时刻是一样的。这样可以保证所有节点最终看到的数据都是1，因此也保证了一致性。</p><p>总之，强一致性要求所有节点同时执行，而线性一致性只要求所有节点看到的结果是一样的，但是并不要求同时执行。</p><p><strong>最终一致性</strong>（eventual consistency）是分布式系统中一种弱一致性模型，它的基本思想是在分布式系统中的数据更新不需要实时同步，而是通过异步的方式在不同的节点之间复制和传播数据，最终达到一致的状态。</p><p>在最终一致性模型中，数据的更新是通过消息传递的方式在不同的节点之间进行的，不同节点之间的消息传递可能存在延迟，也可能存在网络分区（network partition）等问题，这些都可能导致节点之间的数据不一致。但是，最终一致性模型保证在一定时间内，所有节点最终会达到一致的状态。</p><p>举个例子，假设有一个分布式缓存系统，其中有两个节点A和B，它们都缓存了某个数据。当客户端请求获取数据时，它可以从节点A或节点B中获取数据，因为它们都缓存了这个数据。如果在某个时刻，节点A更新了这个数据，那么节点B上缓存的数据就过期了，但是由于节点之间可能存在延迟等问题，客户端有可能在一段时间内还是从节点B获取到了旧数据。但是，随着时间的推移，节点B最终会从节点A获取到最新的数据，然后更新自己的缓存，最终达到一致的状态。</p><p><strong>分布式准则</strong></p><p><strong>数据可靠性（Reliability）</strong></p><ul><li>复制技术（Replication）：将数据复制到多个不同节点</li><li>纠删码技术（Erasure Code）：通过校验数据来保证数据可靠性的技术</li></ul><p><strong>数据一致性（Consistency）</strong></p><p><strong>设备故障和容错（Fault Tolerance）</strong></p><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><p><strong>数据库索引失效</strong></p><p> 6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h3 id="工作项目"><a href="#工作项目" class="headerlink" title="工作项目"></a>工作项目</h3><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><p><strong>流程</strong></p><ol><li>指定发布版本运行回归</li><li>评估指标结果，对于基础指标如是否到达，是否碰撞需一一排查；其他指标优先级不高只做报警处理（因为随机性较大），若所有场景的某一指标都有异常变化则需要排查（震荡幅度，运行时间等）</li><li>记录反馈回归结果，与其他模块测试沟通，通过则发灰度版本；否则联系负责人修复</li></ol><p><strong>场景库</strong></p><p>覆盖基础场景和corner case。按场景细分为不同型号车辆，车道环境，障碍物，自车朝向；根据项目细分为绕障，借道等</p><p>来源手动构造，每周接管，数据挖掘抽取</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p><strong>流程</strong></p><ol><li>通过单帧或多帧运行场景，期间监控相关进程的资源占用</li><li>和历史值对比，查看是否合理，反馈问题或者调整阈值</li></ol><p><strong>监控项</strong></p><p>cpu_times：单位时间内CPU 在执行程序时所花费的时间，包括user，kernal，none</p><p>IO rchar&#x2F;wchar：io吞吐量</p><p>Physical&#x2F;Virtual Memory_peak：物理&#x2F;虚拟内存峰值</p><p>GPU_memory_used，GPU_util：显存占用，gpu使用率</p><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p><strong>流程</strong></p><ol><li>更新的优化点和风险点的理解与讨论</li><li>测试用例集的构建</li><li>评估指标的设计</li><li>具体算法问题追踪</li><li>上线流程的把握</li><li>上线后的更新点持续跟踪</li></ol><h3 id="RAFT项目"><a href="#RAFT项目" class="headerlink" title="RAFT项目"></a>RAFT项目</h3><h4 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h4><p><strong>raft通信流程</strong></p><p><strong>leader election</strong></p><h4 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h4><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h4 id="与Paxos对比"><a href="#与Paxos对比" class="headerlink" title="与Paxos对比"></a>与Paxos对比</h4>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（二）引用</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-面向对象编程（二）"><a href="#第五章-面向对象编程（二）" class="headerlink" title="第五章 面向对象编程（二）"></a>第五章 面向对象编程（二）</h2><h3 id="引用的其他用法"><a href="#引用的其他用法" class="headerlink" title="引用的其他用法"></a>引用的其他用法</h3><p>引用作为成员变量</p><p>函数返回引用，可以将返回值做左值</p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>通过类的其他对象初始化当前对象（有默认拷贝构造方法，成员对成员的拷贝，可能发生对象的嵌套拷贝）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//During call by value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">roster</span><span class="params">(Person)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function">Person <span class="title">child</span><span class="params">(<span class="string">&quot;Ruby&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">roster</span>(child); <span class="comment">// call copy ctors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// During initialization, call copy ctor</span></span><br><span class="line"><span class="function">Person <span class="title">baby_a</span><span class="params">(<span class="string">&quot;Fred&quot;</span>)</span></span>;</span><br><span class="line">Person baby_b = baby_a;</span><br><span class="line"><span class="function">Person <span class="title">baby_c</span><span class="params">(baby_a)</span></span>; <span class="comment">// same as above</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//During function return</span></span><br><span class="line"><span class="function">Person <span class="title">captain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">player</span><span class="params">(<span class="string">&quot;George&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T::T(const T&amp;)</p><p>建议每个类提供默认构造函数，拷贝构造函数，虚函数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>private针对类而非对象，可访问另一对象中的private成员</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>定义：存在于某作用域的一块内存空间，在函数本体内声明的任何变量，其使用的内存都取自于栈。在作用域结束后自动清理</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>定义：操作系统提供的一块全局内存空间，程序可动态分配从中获得若干区块。其生命在做犹豫结束后仍然存在，直到整个程序结束</p><p>包含：</p><ul><li>static local objects</li><li>global objects</li><li>heap objects（new）</li></ul><h4 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h4><p>new先分配内存后调用构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Complex* pc = new Complex(1,2);</span></span><br><span class="line"><span class="comment">//for complier, it transform to follow be like</span></span><br><span class="line">Complex *pc;</span><br><span class="line"><span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Complex));<span class="comment">//call malloc to allocate memory</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex *&gt;(mem); <span class="comment">//cast</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//call ctor</span></span><br></pre></td></tr></table></figure><p>delete先调用析构函数后释放内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//delete pc</span></span><br><span class="line"><span class="comment">//for complier, it transform to follow be like</span></span><br><span class="line">Complex::~<span class="built_in">Complex</span>(pc); <span class="comment">//call dtor</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>; <span class="comment">//call free(pc) to release memory</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（三）模版</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>模版函数（template function）为声明不是定义，在使用时根据输入类型定义</p><p>使用模版时，不会使用隐式类型转换</p><p>类模版里的每个函数都是函数模版，需要在声明前加上<code>template</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  BTnode&lt;elemType&gt; *_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（二）字符串、向量和数组</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="标准库类型String"><a href="#标准库类型String" class="headerlink" title="标准库类型String"></a>标准库类型String</h3><p>读写string对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;   <span class="comment">//from empty to empty</span></span><br><span class="line"><span class="built_in">getline</span>(cin,s); <span class="comment">//one line, stop by ENTER</span></span><br></pre></td></tr></table></figure><p>当把string对象和字符（串）字面值混在一条语句时，必须确保加法运算符（+）两侧的运算对象至少一个是string</p><h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h3><p>vector是模板而非类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line">vector&lt;T&gt; v3 = v1; <span class="comment">//same to above</span></span><br><span class="line">vector&lt;T&gt; v4&#123;a,b,c,...&#125;;</span><br><span class="line">vector&lt;T&gt; v5 = &#123;a,b,c,...&#125;; <span class="comment">//same to above</span></span><br></pre></td></tr></table></figure><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>理解复杂的数组声明（P102-103）</p><p>从变量名开始由内往外看，即变量名-数组-变量类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">//含有10个整型指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*parrary)[<span class="number">10</span>] = &amp;arr; <span class="comment">//指向一个含有10个整数的数组的指针</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrREF)[<span class="number">10</span>] = arr; <span class="comment">//引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//引用一个含有10个整型指针的数组</span></span><br></pre></td></tr></table></figure><p>指向一个数组的指针+1后指向数组尾部的下一个地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">int</span>(*a)[<span class="number">2</span>] = &amp;arr;</span><br><span class="line"><span class="type">int</span> *b = arr;</span><br><span class="line">cout &lt;&lt; arr &lt;&lt; endl; <span class="comment">//0x61fe08</span></span><br><span class="line">cout &lt;&lt; arr + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe0c</span></span><br><span class="line">cout &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe10 = 0x61fe08 + (4*2)D</span></span><br><span class="line">cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe0c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（五）自增的问题</title>
      <link href="/2025/01/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/01/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>后置递增运算符的优先级高于解引用运算符，因此<code>*p++</code>等同于<code>*（p++）</code></p><p>将p+1后返回p的初始值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（四）inline函数</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="inline-函数"><a href="#inline-函数" class="headerlink" title="inline 函数"></a>inline 函数</h3><p>将函数声明为inline可以避免函数调用的开销，空间换时间</p><p>调用函数步骤：</p><ol><li>返回地址压栈</li><li>函数参数压栈</li><li>计算返回值</li><li>函数部分所有元素出栈，返回值</li></ol><img src="/../../images/assembly code.png" width=500px /><p>普通函数与inline函数的汇编代码对比</p><img src="/../../images/inline.png" width=500px /><p><strong>inline函数不是定义是声明，应该写在头文件里，保证编译器将其作为inline函数展开</strong></p><p>宏定义与inline函数的区别</p><table><thead><tr><th></th><th>宏定义</th><th>inline函数</th></tr></thead><tbody><tr><td>类型检查</td><td>无</td><td>有</td></tr><tr><td>实现方式</td><td>预处理时展开</td><td>由编译器实现展开，是否将函数作为inline依赖于编译器的判断</td></tr><tr><td>其他</td><td>容易引发运算符优先级的问题，不可调试</td><td>可以调试</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL基础</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/</url>
      
        <content type="html"><![CDATA[<h3 id="六大部件"><a href="#六大部件" class="headerlink" title="六大部件"></a>六大部件</h3><img src="/../../images/stl_items.png" alt="stl_items.png" style="zoom:60%;" /><p>分配器：为容器分配内存</p><p>迭代器：算法只能通过迭代器访问容器</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><img src="/../../images/stl.png" alt="stl.png" style="zoom:60%;" /><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h4><p>_M_instance：指向数组首元素的指针（int a[10]的a）</p><img src="/../../images/array_overview.png" alt="array_overview.png" style="zoom:60%;" /><p><strong>iterator为指针，traits通过指针特化处理</strong></p><img src="/../../images/array.png" alt="array.png" style="zoom:60%;" /><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><p>start（4B）：指向第一个元素的指针</p><p>finish（4B）：指向最后一个元素的下一个指针</p><p>end_of_storage（4B）：容器申请的内存空间的最后一个元素的下一个地址</p><p>若内存空间不够则申请当前空间两倍的空间</p><img src="/../../images/vector_overview.png" alt="vector_overview.png" style="zoom:60%;" /><p><strong>iterator为指针，traits通过指针特化处理</strong></p><img src="/../../images/vector_iterator.png" alt="vector_iterator.png" style="zoom:60%;" /><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>node（4B）：指向头节点的指针</p><img src="/../../images/list_overview.png" alt="list_overview.png" style="zoom:60%;" /><p><strong>iterator里的node为指向当前节点的指针</strong></p><img src="/../../images/list_iterator.png" alt="list_iterator.png" style="zoom:60%;" /><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward List"></a>Forward List</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><img src="/../../images/forward_list.png" alt="forward_list.png" style="zoom:60%;" /><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>queue在内存中每个buffer块离散存储，通过map表记录各buffer块的地址</p><p>start（16B）：指向首元素的iterator</p><p>finish（16B）：指向尾巴元素下一个块的iterator</p><p>map（4B）：指向map首元素的指针</p><p>map_size：map占用内存的大小</p><img src="/../../images/deque_overview.png" alt="deque_overview.png" style="zoom:60%;" /><p>cur：指向当前元素的指针</p><p>first：指向当前buffer块首元素的指针</p><p>last：指向当前buffer块尾元素下一个块的指针</p><p>node：指向map对应元素的指针</p><img src="/../../images/deque_iterator.png" alt="deque_iterator.png" style="zoom:60%;" /><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>不允许遍历也不提供iterator</p><p>可选择list或deque作为底层存储</p><p>不可选择vector作为底层存储</p><img src="/../../images/queue.png" alt="queue.png" style="zoom:60%;" /><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>不允许遍历也不提供iterator</p><p>可选择list或deque或vector作为底层存储</p><img src="/../../images/stack.png" alt="stack.png" style="zoom:60%;" /><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>t：红黑树</p><img src="/../../images/set.png" alt="set.png" style="zoom:60%;" /><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="键值对集合"><a href="#键值对集合" class="headerlink" title="键值对集合"></a>键值对集合</h4><p>t：红黑树</p><img src="/../../images/map.png" alt="map.png" style="zoom:60%;" /><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的</p><h3 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h3><h3 id="Iterator-Traits"><a href="#Iterator-Traits" class="headerlink" title="Iterator Traits"></a>Iterator Traits</h3><p>由于算法需要得到iterator的某些属性，对于非指针iterator的结构包含属性，但对于指针类型无法获取。通过iterator traits对于iterator处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（一）运算符重载</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><p>只能重载存在的运算法</p><p>重载运算符必须保留相同操作数数量和优先级</p><h3 id="成员或全局函数"><a href="#成员或全局函数" class="headerlink" title="成员或全局函数"></a>成员或全局函数</h3><p>单目运算符应该做成成员函数</p><p><code>= （） []</code>只能做成成员函数</p><p>所有其他二元运算符做成非成员函数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>成员函数左操作数（reciver）必须是隶属于同一个class的对象</p><p>加const可以防止返回结果做左值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（一）CPP编译过程、宏以及头文件</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<ol><li><p><code>endl</code>将与设备关联的<strong>缓冲区（buffer）</strong>中的内容刷到设备中。在调试时应保证”一直”刷新流。否则若程序崩溃，输出可能还是缓冲区，导致对于程序崩溃位置的错误推断</p></li><li><p>读取数量不定的输入数据可用<code>while (std::in &gt;&gt; value)</code></p><p>当遇到<strong>文件结束符（end-of-file）</strong>，或遇到一个无效输入时，<em>istream</em>对象状态变为无效，使条件为假</p><p>EOF：在Windows中为<code>Ctrl+Z</code>，UNIX为<code>Ctrl+D</code></p></li></ol><h3 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++编译过程"></a>C++编译过程</h3><ol><li><p>预处理（Preprocessing）</p><p>将所有的#include<strong>头文件以及宏定义替换成其真正的内容</strong>，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是<strong>预处理器cpp来完成的</strong>。（include只做文本插入，在include的位置将头文件展开）</p></li><li><p>编译（Compilation）</p><p>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定<strong>汇编代码（assembly code）</strong>的过程。</p><p>一个cpp文件是一个编译单元。</p></li><li><p>汇编（Assemble）</p><p>汇编过程将上一步的汇编代码转换成<strong>机器码（machine code）</strong>，这一步产生的文件叫做目标文件，是二进制格式。</p><p><strong>这一步会为每一个源文件产生一个目标文件</strong>。</p></li><li><p>链接（Linking）</p><p>链接过程将<strong>多个目标文以及所需的库文件（.so等）链接</strong>成最终的<strong>可执行文件（executable file）</strong></p></li></ol><p><img src="/../../images/compiler.png" alt="compiler"></p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>预处理阶段将宏所写内容替换</p><p>宏没有类型检查</p><p>在宏外加括号防止运算符优先级错误</p><p>在宏后不需要加分号（非C++语句）</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>把函数原型放到头文件中，在需要调用这个函数的源代码文件中include到这个头文件，能让编译器在编译时知道函数的原型，以确保函数类型的统一</p><p>头文件里存放声明（extren变量，函数原型，类或结构体的定义），cpp文件里存放定义</p><img src="/../../images/header and cpp.png" width=500px/><p>头文件的标准格式</p><p>用宏定义防止：</p><ol><li>两个头文件相互include时的循环include</li><li>cpp在include不同头文件时可能产生的重复定义（class不能重复定义）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _MY_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _MY_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标签测试文章</title>
      <link href="/2025/01/02/index/"/>
      <url>/2025/01/02/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> Another Tag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/02/hello-world/"/>
      <url>/2025/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
