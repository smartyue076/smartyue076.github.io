<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树算法（回溯，动态规划，迭代）</title>
      <link href="/2025/01/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%BF%AD%E4%BB%A3%EF%BC%89/"/>
      <url>/2025/01/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%BF%AD%E4%BB%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>二叉树题型的算法主要分为<strong>回溯，动态规划，迭代</strong>三类。从本质上三者都是在遍历算法基础上的修改。<strong>回溯</strong>关心的是在<strong>每个结点的访问过程中如何更新结果</strong>；动态规划关心的是<strong>如何拆解出子问题，不具体分析每个结点的状态，而是通过划分子问题让其通过基本问题递归解决</strong>；迭代主要是指<strong>BFS层序遍历</strong>，适用于与深度（或高度）相关的问题求解</p><h2 id="二叉树基本结构"><a href="#二叉树基本结构" class="headerlink" title="二叉树基本结构"></a>二叉树基本结构</h2><ol><li>二叉树</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>多叉树</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TreeNode *&gt; children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ol><li>递归遍历</li></ol><p>前序位置：刚进入当前子树根结点的时候（已知根结点信息）</p><p>中序位置：访问完左子树后，准备访问右子树的时候（已知根，左孩子结点信息）</p><p>后序位置：访问完左右子树后的，回溯到当前子树根结点的时候（已知根，左孩子，右孩子结点信息）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>层序遍历</li></ol><p>通过对每层访问后完后栈内元素个数的统计可以实现层数的更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树题型解法"><a href="#二叉树题型解法" class="headerlink" title="二叉树题型解法"></a>二叉树题型解法</h2><h3 id="回溯（DFS）"><a href="#回溯（DFS）" class="headerlink" title="回溯（DFS）"></a>回溯（DFS）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><strong>回溯</strong>关心的是在<strong>每个结点的访问过程中如何更新结果</strong>，着眼点在<strong>结点间移动的过程</strong></p><p>在求解过程中<strong>假定当前处理的为其中一颗子树</strong>，考虑两个问题：</p><ol><li>前&#x2F;中序位置：<strong>进入当前层后要做的事</strong></li><li>后序位置：<strong>回溯到父结点前要做的事</strong></li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h5><p>在结点访问时更新depth，如果为根结点则表示为可能的当前子树深度最大值，更新全局最大深度<strong>（进入时）</strong>。当返回到父结点前，表示当前子树已经遍历完成，父结点的depth应为当前depth-1<strong>（回溯前）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        max_depth=<span class="built_in">max</span>(max_depth,depth);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(root);</span><br><span class="line">    <span class="keyword">return</span> max_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划（分解子问题）"><a href="#动态规划（分解子问题）" class="headerlink" title="动态规划（分解子问题）"></a>动态规划（分解子问题）</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>动态规划关心的是<strong>如何拆解出子问题，不具体分析每个结点的状态，而是通过划分子问题让其通过基本问题递归解决</strong>，着眼点在<strong>结构相同的子问题</strong></p><p>在求解过程中需要考虑三个问题</p><ol><li><strong>确定问题</strong>：给当前的计算过程一种解释</li><li><strong>解决基准问题</strong>：思考当输入值为基础值时，其返回的结果是什么。该步用于<strong>确定递归终止条件</strong></li><li><strong>拆解问题</strong>：考虑在当前的普通输入时，应该如何解决问题</li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><h5 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h5><ol><li><strong>确定问题</strong>：计算以root为根结点的二叉树的最大深度并返回最大深度</li><li><strong>解决基准问题</strong>：当root为空指针时，表示该树空，返回0</li><li><strong>拆解问题</strong>：当前结点的最大深度即为左右子树中的最大深度+1，所以只需要获取左右子树的最大深度后+1即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_max_depth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right_max_depth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_max_depth,right_max_depth)<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代（BFS）"><a href="#迭代（BFS）" class="headerlink" title="迭代（BFS）"></a>迭代（BFS）</h3><p>同上二叉树层序遍历</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h3><p>可以看作<strong>动态规划</strong>的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归构造二叉树，处理空节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build_tree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 越界或遇到空节点值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= arr.<span class="built_in">size</span>() || arr[index] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建当前节点</span></span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(arr[index]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构造左、右子树</span></span><br><span class="line">    node-&gt;left = <span class="built_in">build_tree</span>(arr, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">build_tree</span>(arr, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归算法的理解</title>
      <link href="/2025/01/08/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2025/01/08/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="如何写一个递归算法"><a href="#如何写一个递归算法" class="headerlink" title="如何写一个递归算法"></a>如何写一个递归算法</h2><ol><li><strong>确定问题</strong>：给当前的算法一个符合计算机处理流程的解释。例如对于斐波那契数数列求解<code>int fib(int n)</code>，应该翻译成计算数列第n项并返回数列的值</li></ol><img src="/../../images/recursion.png" style="width:50%" /><ol start="2"><li><strong>解决基准问题</strong>：思考当输入值为基础值时，其返回的结果是什么。该步用于<strong>确定递归终止条件</strong>。例如对于汉诺塔问题，在只有一块积木时只需要将其从From移到Target即可</li></ol><img src="/../../images/recursion_2.png" style="width:50%;" /><ol start="3"><li><p><strong>拆解问题</strong>：考虑在当前的普通输入时，应该如何解决问题。例如对于斐波那契数数列求解，当前应该返回的值是<code>fib(n-1)+fib(n-2)</code>。</p><p>❗️❗️<strong>不要尝试去思考其内部具体是如何执行的，只要把当前函数当作一个已经实现的库函数即可。否则只会越绕越晕。</strong></p></li></ol><img src="/../../images/recursion_3.png" style="width:50%;" /><h2 id="递归算法举例分析"><a href="#递归算法举例分析" class="headerlink" title="递归算法举例分析"></a>递归算法举例分析</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ol><li><strong>确定问题</strong>：遍历以root为根结点的二叉树</li><li><strong>解决基准问题</strong>：当root为空指针时返回</li><li><strong>拆解问题</strong>：在访问完当前结点后，继续遍历左子树（具体说：遍历以root-&gt;left为根结点的二叉树），继续遍历右子树（具体说：遍历以root-&gt;right为根结点的二叉树）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; root-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><ol><li><strong>确定问题</strong>：计算以root为根结点的二叉树的最大深度并返回最大深度</li><li><strong>解决基准问题</strong>：当root为空指针时，表示该树空，返回0</li><li><strong>拆解问题</strong>：当前结点的最大深度即为左右子树中的最大深度+1，所以只需要获取左右子树的最大深度后+1即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line">    <span class="type">int</span> res = std::<span class="built_in">max</span>(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在二叉搜索树中插入结点"><a href="#在二叉搜索树中插入结点" class="headerlink" title="在二叉搜索树中插入结点"></a>在二叉搜索树中插入结点</h3><ol><li><strong>确定问题</strong>：在root为根结点的二叉树中插入值为val的结点，返回root的根结点</li><li><strong>解决基准问题</strong>：当root为空指针时，表示该树空，插入新结点</li><li><strong>拆解问题</strong>：如果当前结点非空，那就表示待插入结点应该在左或右子树，那如果<code>root-&gt;val&gt;val</code>则在左子树中插入，如果<code>root-&gt;val&lt;val</code>则在右子树中插入，并且返回值为当前子树的根结点（不用管插入的具体位置，以及是否为<code>root-&gt;left</code>或<code>root-&gt;right</code>，要想的只是把已经修改好的树返回给左右孩子指针），最后返回根结点<code>root</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在root为根的树中插入值为val的结点，并返回root</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *new_node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val&gt;val)</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>  (root-&gt;val&lt;val)</span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）进程管理（进程同步与死锁）</title>
      <link href="/2025/01/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%89/"/>
      <url>/2025/01/07/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU调度策略"><a href="#CPU调度策略" class="headerlink" title="CPU调度策略"></a>CPU调度策略</h3><h4 id="任务调度策略的三个基本准则"><a href="#任务调度策略的三个基本准则" class="headerlink" title="任务调度策略的三个基本准则"></a>任务调度策略的三个基本准则</h4><ul><li>任务周转时间：从新建到完成的时间</li><li>任务响应时间：从提交请求到首次响应的时间（前台任务关心）</li><li>系统吞吐量：一段时间内系统能完成的任务数</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ol><li><p>先来先服务</p></li><li><p>最短作业优先调度：不可抢占，平均周转时间短（作业运行时间只能近似给出）</p></li><li><p>最短剩余时间有限：最短作业优先的可抢占版本</p></li><li><p>时间片轮转调度：保证响应时间</p><p><strong>时间片设得太短</strong>会导致过多的进程切换，<strong>降低了CPU效率</strong>；<strong>设得太长</strong>会引起<strong>对短作业的交互请求的响应时间变长</strong></p></li></ol><img src="/../../images/rr.png" align='left' width=700px/><ol start="5"><li><p>多级反馈队列调度：动态调整任务类型（近期多IO可能为前台任务，无IO时间片结束未完成可能为后台大任务）</p><p>运行流程</p><ol><li>设置<strong>多级就绪队列</strong>，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时<strong>先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。 若用完时间片进程还未结束，则进程<strong>进入下一级队列队尾</strong>。如果此时已经是在最下级的队列，则重新放回最下级队列队尾</li><li>只有第k级队列为空时，才会<strong>为k+1级队头的进程分配时间片</strong></li></ol></li></ol><h4 id="调度算法比较"><a href="#调度算法比较" class="headerlink" title="调度算法比较"></a>调度算法比较</h4><img src="/../../images/process_control.png" align='left' width=700px/><img src="/../../images/process_control_2.png" align='left' width=700px/><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol><li>IO占比越大，任务优先级越高</li></ol><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><h5 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h5><p><strong>软件实现</strong></p><p>Peterson算法：访问临界区前判断其他进程是否要用，要用则循环等待；等其他进程使用完后访问临界区</p><p><strong>硬件实现</strong></p><ol><li>开关中断：只适用于单处理机，可以使得一个处理机内任务不中断。如果多处理机要实现互斥需要总线支持</li><li>TestAndSet</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKED 1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Critical</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (TestAndSet(&amp;lock) == <span class="number">1</span>);</span><br><span class="line">     critical section <span class="comment">// only one process can be in this section at a time</span></span><br><span class="line">     lock = <span class="number">0</span> <span class="comment">// release lock when finished with the critical section</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">int</span> TestAndSet(<span class="type">int</span>* lockPtr) &#123;</span><br><span class="line">    <span class="type">int</span> oldValue;</span><br><span class="line">    oldValue = *lockPtr;</span><br><span class="line">    *lockPtr = LOCKED; <span class="comment">//不管原来有没有上锁，先加锁</span></span><br><span class="line">    <span class="keyword">return</span> oldValue; <span class="comment">//返回本来是否上锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>记录型信号量支持让权等待（while判断循环的都不是让权等待）</p><p>退出临界区的进程负责唤醒阻塞态进程（区别于while判断循环的自发进入临界区）</p><img src="/../../images/semaphore.png" align='left' width=700px/><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> value; <span class="comment">// value of block_process or free resource</span></span><br><span class="line">  PCB *<span class="built_in">queue</span>; <span class="comment">// process queue wait on sem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">  s.value--;</span><br><span class="line">  <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)</span><br><span class="line">  sleep_on(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">  s.value++;</span><br><span class="line">  <span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>) <span class="comment">// release one wake_up one(唤醒阻塞队列的队头任务)</span></span><br><span class="line">  wake_up(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者&#x2F;消费者模型"></a>生产者&#x2F;消费者模型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use semaphore</span></span><br><span class="line">semaphore empty = BUFFER_SIZE; <span class="comment">// count of empty size</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">// count of resource in space</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// prevent change to space</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  P(empty); <span class="comment">//确保有空间</span></span><br><span class="line">  P(mutex);</span><br><span class="line">  buffer[in] = item;</span><br><span class="line">  in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  P(full); <span class="comment">//确保有东西</span></span><br><span class="line">  P(mutex);</span><br><span class="line">  item = buffer[out];</span><br><span class="line">  out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读者-写者模型"><a href="#读者-写者模型" class="headerlink" title="读者&#x2F;写者模型"></a>读者&#x2F;写者模型</h4><h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><img src="/../../images/reader_writer.png" align='left' width=700px/><h5 id="读写公平"><a href="#读写公平" class="headerlink" title="读写公平"></a>读写公平</h5><img src="/../../images/reader_writer_2.png" align='left' width=700px/><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>各哲学家互斥得拿筷子，即同一时间至多有一个哲学家拿筷子阻塞</p><img src="/../../images/eat.png" align='left' width=700px/><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的四个<strong>必要条件</strong></p><ul><li>互斥：资源不能被共享，一个资源每次只能被一个进程使用</li><li>不可剥夺：进程已获得的资源，在未使用完之前，不能强行剥夺</li><li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>循环等待：若干进程之间形成一种头尾相接的循环性资源等待关系</li></ul><h4 id="死锁预防（不会发生死锁）"><a href="#死锁预防（不会发生死锁）" class="headerlink" title="死锁预防（不会发生死锁）"></a>死锁预防（不会发生死锁）</h4><p>破坏“请求与保持”：一次性申请进程所需的所有资源</p><p>破坏“循环等待”：资源按顺序申请（其实达不到，没法预测程序走的分支）</p><p>缺点：</p><ul><li>需要预先计算程序要请求的资源</li><li>可能很久以后才使用的资源早早地预留下来，造成资源的浪费</li></ul><h4 id="死锁避免（拒绝某些资源请求）"><a href="#死锁避免（拒绝某些资源请求）" class="headerlink" title="死锁避免（拒绝某些资源请求）"></a>死锁避免（拒绝某些资源请求）</h4><p>每次申请资源都要判断是否出现死锁的危险，如果有危险就拒绝这次请求</p><p>通过<strong>银行家算法</strong>计算安全序列，充分性算法，<strong>完全避免死锁</strong></p><p>算法优先分配给能满足进程所需最大资源量的进程，一次分配所有所需要的所有资源</p><p>缺点：</p><ul><li>每次资源请求发生就要计算，且时间复杂度不小（时间复杂度O(mn^2)，m为资源种类，n为进程数）</li><li>需要已知进程执行完成所需的资源总数</li></ul><p><strong>银行家算法（‼️）</strong></p><ol><li>判断请求是否小于所需资源</li><li>判断请求是否小于当前系统资源量</li><li>尝试分配，判断能否找出安全序列</li><li>若能找到则分配，若不能找到则不分配</li></ol><p><strong>求安全序列</strong></p><p>最大资源组A，已分配组B，还需资源组C（C&#x3D;A-B）</p><p>系统资源组P</p><ol><li>查看<strong>还需 资源A 小于等于 系统资源P 的进程</strong></li><li>一次分配后，将已分配的资源回收，<strong>更新系统P</strong></li><li>返回1，若所有进程都能分配，则存在安全序列（不唯一）</li></ol><p>备注：</p><ol><li>存在安全序列 -》无死锁进程</li><li>不存在安全序列不一定发生死锁（依赖于请求资源的序列）</li></ol><p><strong>不发生死锁的最小资源量</strong></p><p>每个所需资源都-1后累加，再加一（每个所需资源都-1为请求与保持的最坏情况，+1即可确保分配不发生死锁）</p><img src="/../../images/banker.png" align='left' width=700px/><h4 id="死锁检测-恢复（排查因资源导致的阻塞进程）"><a href="#死锁检测-恢复（排查因资源导致的阻塞进程）" class="headerlink" title="死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）"></a>死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）</h4><p>检测发生死锁的进程（资源未被使用，进程长时间未调度等），恢复进程并重新分配资源（<strong>改进的银行家算法</strong>）</p><p>改进的银行家算法分配每次进程请求的资源，而不是分配所需的所有资源，因为有事进程对于资源使用后就会释放，这样系统有更多余量</p><p>缺点：</p><ul><li>回滚的处理问题</li></ul><h4 id="死锁忽略（大部分PC机操作系统）"><a href="#死锁忽略（大部分PC机操作系统）" class="headerlink" title="死锁忽略（大部分PC机操作系统）"></a>死锁忽略（大部分PC机操作系统）</h4><p>不进行死锁处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（一）封装、继承和多态</title>
      <link href="/2025/01/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/01/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>类不是实体，对象是实体</p><p>成员变量（filed）属于对象</p><p>成员函数（member function）属于类</p><h3 id="Big-Three（构造函数，拷贝构造，拷贝赋值）"><a href="#Big-Three（构造函数，拷贝构造，拷贝赋值）" class="headerlink" title="Big Three（构造函数，拷贝构造，拷贝赋值）"></a>Big Three（构造函数，拷贝构造，拷贝赋值）</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p><strong>列表初始化（initialize list）</strong>仅对成员变量初始化。</p><p>在构造函数里对成员变量初始化则为先初始化（默认）后赋值，故所有成员变量必须要有默认的初始化方法（成员变量包含其他类但该类没有默认构造函数则会报错）。构造函数无法主动调用。</p><p>尽量使用列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">a</span>(i)&#123;&#125;;  <span class="comment">//initialize list</span></span><br><span class="line">  <span class="comment">// A(int i):&#123;a=i;&#125; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造和拷贝赋值"><a href="#拷贝构造和拷贝赋值" class="headerlink" title="拷贝构造和拷贝赋值"></a>拷贝构造和拷贝赋值</h4><p><strong>浅拷贝和深拷贝有什么区别</strong></p><p>浅拷贝为字节流的拷贝，对于指针来说，通过浅拷贝会使新对象和旧对象指向同一块内存（类默认的拷贝构造和拷贝赋值）</p><p>深拷贝在复制时为指针分配新的内存，新对象和旧对象有各自独立的空间。</p><p><strong>对于成员变量含有指针的类，尽量自己实现拷贝构造和拷贝赋值，防止不同对象的成员变量的指针指向同一块内存</strong></p><h5 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">ptr</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        ptr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> <span class="type">char</span> *c_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(c_ptr) + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            ptr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test(const char *c_ptr)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;test)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, test.ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call Test(Test &amp;test)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(Test &amp;test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;test) <span class="comment">//1.防止无意义拷贝 2.防止在拷贝自身前清空ptr内容</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(test.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, test.ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call copy operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test; <span class="comment">//构造函数，call Test()</span></span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>; <span class="comment">//拷贝构造,call Test(const char *c_ptr)</span></span><br><span class="line">    Test test2 = test1; <span class="comment">//拷贝赋值,call Test(Test &amp;test)</span></span><br><span class="line">    <span class="function">Test <span class="title">test3</span><span class="params">(test1)</span></span>; <span class="comment">//拷贝赋值,call Test(Test &amp;test)</span></span><br><span class="line">    test3 = test2; <span class="comment">//赋值,call copy operator=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，<strong>是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体</strong>。</p><p>数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。</p><p>其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p>使用封装有 4 大好处：</p><ul><li>1、良好的封装能够减少耦合。</li><li>2、类内部的结构可以自由修改。</li><li>3、可以对成员进行更精确的控制。</li><li>4、隐藏信息，实现细节。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="为什么需要继承？"><a href="#为什么需要继承？" class="headerlink" title="为什么需要继承？"></a>为什么需要继承？</h4><p>如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。</p><p>这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样<strong>使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见</strong></p><h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><table><thead><tr><th>访问限制符\访问位置</th><th>当前类</th><th>子类</th><th align="center">类外</th></tr></thead><tbody><tr><td>public</td><td>可以</td><td>可以</td><td align="center">可以</td></tr><tr><td>protected</td><td>可以</td><td>可以</td><td align="center">不可以</td></tr><tr><td>private</td><td>可以</td><td>不可以</td><td align="center">不可以</td></tr></tbody></table><h3 id="重载、重写和覆盖"><a href="#重载、重写和覆盖" class="headerlink" title="重载、重写和覆盖"></a>重载、重写和覆盖</h3><h4 id="重载（overloading）"><a href="#重载（overloading）" class="headerlink" title="重载（overloading）"></a>重载（overloading）</h4><p>在同一个作用域中，<strong>函数名相同</strong>，但<strong>参数列表（包括参数的类型、个数或顺序）不同</strong>，形成的多个函数称为<strong>函数重载</strong>。</p><h4 id="重写（overriding）"><a href="#重写（overriding）" class="headerlink" title="重写（overriding）"></a>重写（overriding）</h4><p>在<strong>派生类中</strong>，定义了一个与<strong>基类中同名且参数列表完全相同</strong>的函数，并通过 virtual 声明基类函数实现动态多态。（<strong>虚函数</strong>实现）</p><h4 id="覆盖（Hiding）"><a href="#覆盖（Hiding）" class="headerlink" title="覆盖（Hiding）"></a>覆盖（Hiding）</h4><p>在<strong>派生类中</strong>，定义了一个与<strong>基类同名但参数列表不同</strong>的函数时，基类的函数被隐藏（覆盖）。函数覆盖不是动态多态的一部分，与重写不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a):<span class="built_in">i</span>(a)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::print()&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::print(int i)&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> a):<span class="built_in">A</span>(a)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::print()&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">2</span>); <span class="comment">//ERROR, cant found print(int a) in A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>不同的对象对于同一消息作出不同的响应</strong>。子类在继承父类后可以设计自己的版本，在运行时动态选择调用哪个版本实现</p><h4 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a><strong>静态绑定和动态绑定</strong></h4><p>在面向对象编程中，静态绑定和动态绑定是两种不同的函数调用机制。</p><p><strong>静态绑定（Static Binding）</strong>，也称为早期绑定或编译期绑定，是指<strong>在程序编译时就将函数调用与函数实现绑定起来，而不考虑对象的实际类型</strong>。这种绑定是通过函数的名称和参数列表来实现的。在静态绑定中，编译器会<strong>在编译期间确定调用哪个函数</strong>，而不是在运行时确定。静态绑定通常适用于非虚函数的调用，因为非虚函数的调用是在编译期间就可以确定的。</p><p><strong>动态绑定（Dynamic Binding）</strong>，也称为晚期绑定或运行时绑定，是指<strong>在程序运行时根据对象的实际类型来决定调用哪个函数</strong>。这种绑定是通过虚函数来实现的。在动态绑定中，编译器会在运行时确定调用哪个函数，而不是在编译期间确定。动态绑定适用于需要实现多态性的情况，可以<strong>让基类指针或引用调用派生类中的函数实现，实现运行时多态性</strong>。</p><h4 id="函数重载或函数模版（编译时多态）"><a href="#函数重载或函数模版（编译时多态）" class="headerlink" title="函数重载或函数模版（编译时多态）"></a>函数重载或函数模版（编译时多态）</h4><h4 id="虚函数（运行时多态）"><a href="#虚函数（运行时多态）" class="headerlink" title="虚函数（运行时多态）"></a>虚函数（运行时多态）</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>实现动态多态性（Runtime Polymorphism）：通过使用虚函数，可以在运行时动态地确定调用的是基类函数还是派生类函数，实现多态性。例如，如果我们有一个指向基类对象的指针，我们可以使用虚函数来调用派生类中的适当函数。</li><li>支持运行时类型识别（RTTI）：通过使用虚函数和类型信息（type information），可以在运行时确定对象的实际类型，从而实现更加灵活的代码设计。</li><li>简化代码维护：使用虚函数可以将代码的实现细节从类的使用者中分离出来，使得修改基类的实现对派生类的影响最小。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>对于有虚函数的类，其对象会包含指向vtable的vptr指针（vtable中为所有虚函数的地址）。在运行时确定对象类型，来选取相应的vptr，进而找到vptr指向的vtable的虚函数的具体函数地址</p><img src="/../../images/vtable.PNG" style="zoom:30%;" /><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><ol><li>新建子类对象</li><li>通过父类指针指向该对象</li><li>用虚函数定义目标函数</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *test = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">//向上造型（upcasting）指将派生类的引用或指针转化为父类的引用或指针</span></span><br><span class="line">test-&gt;<span class="built_in">print</span>();  <span class="comment">//Derived print</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>如果派生类<strong>没有覆盖基类的虚函数</strong>，则派生类会直接<strong>继承基类中的版本</strong></p><p>如果<strong>类存在虚函数</strong>，则需<strong>将析构函数设为虚函数</strong>，否则在基类指针调用析构时只能运行基类的析构</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般来说，最好在类定义开始货结束前的集中位置声明友元</p><p>友元的声明只指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么就必须在友元声明外再专门对函数进行一次声明</p><p>相同类的对象互为友元</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理与实现</title>
      <link href="/2025/01/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/01/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池原理与实现"><a href="#线程池原理与实现" class="headerlink" title="线程池原理与实现"></a>线程池原理与实现</h2><blockquote><p>B站讲解视频：<a href="https://www.bilibili.com/video/BV1sk4y1P7UM/?vd_source=c5564ed8491572469d815a8188748293">线程池原理与实现</a></p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h4><p><strong>线程池（Thread Pool）</strong>是一种基于<strong>池化思想</strong>管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p><strong>线程过多会带来额外的开销</strong>，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。<strong>线程池维护多个线程，等待监督管理者分配可并发执行的任务</strong>。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><span id="more"></span><p><img src="/../../images/thread_pool.png" alt="thread_pool"></p><p>使用线程池可以带来一系列好处：</p><ul><li><strong>降低资源消耗（系统资源）</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高线程的可管理性（系统资源）</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提高响应速度（任务响应）</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提供更多更强大的功能（功能扩展）</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h4 id="线程池解决的问题"><a href="#线程池解决的问题" class="headerlink" title="线程池解决的问题"></a>线程池解决的问题</h4><p>线程池解决的核心问题就是资源管理问题。<strong>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</strong>。这种不确定性将带来以下若干问题：</p><ul><li><p><strong>频繁申请&#x2F;销毁资源和调度资源</strong>，将带来额外的消耗，可能会非常巨大。</p></li><li><p><strong>对资源无限申请缺少抑制手段</strong>，易引发系统资源耗尽的风险。</p></li><li><p><strong>系统无法合理管理内部的资源分布</strong>，会降低系统的稳定性。</p></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><a href="https://github.com/Pithikos/C-Thread-Pool">C Thread Pool（Github）</a></p><table><thead><tr><th>Function example</th><th>Description</th></tr></thead><tbody><tr><td><em><strong>thpool_init(4)</strong></em></td><td>Will return a new threadpool with <code>4</code> threads.</td></tr><tr><td><em><strong>thpool_add_work(thpool, (void*)function_p, (void*)arg_p)</strong></em></td><td>Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, <code>NULL</code> should be passed.</td></tr><tr><td><em><strong>thpool_wait(thpool)</strong></em></td><td>Will wait for all jobs (both in queue and currently running) to finish.</td></tr><tr><td><em><strong>thpool_destroy(thpool)</strong></em></td><td>This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish.</td></tr><tr><td><em><strong>thpool_pause(thpool)</strong></em></td><td>All threads in the threadpool will pause no matter if they are idle or executing work.</td></tr><tr><td><em><strong>thpool_resume(thpool)</strong></em></td><td>If the threadpool is paused, then all threads will resume from where they were.</td></tr><tr><td><em><strong>thpool_num_threads_working(thpool)</strong></em></td><td>Will return the number of currently working threads.</td></tr></tbody></table><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><h4 id="thpool-init-int-num-threads"><a href="#thpool-init-int-num-threads" class="headerlink" title="thpool_init(int num_threads)"></a>thpool_init(int num_threads)</h4><ol><li>创建线程池基本结构</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thpool_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">thread **threads;  <span class="comment">/* pointer to threads        */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num_threads_alive;  <span class="comment">/* threads currently alive   */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num_threads_working; <span class="comment">/* threads currently working */</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> thcount_lock;  <span class="comment">/* used for thread count etc */</span></span><br><span class="line"><span class="type">pthread_cond_t</span> threads_all_idle;  <span class="comment">/* signal to thpool_wait     */</span></span><br><span class="line">jobqueue jobqueue;  <span class="comment">/* job queue                 */</span></span><br><span class="line">&#125; thpool_;</span><br><span class="line"></span><br><span class="line">thpool_p = (<span class="keyword">struct</span> thpool_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thpool_));</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_init(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建线程池中的线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thpool_p-&gt;threads = (<span class="keyword">struct</span> thread**)<span class="built_in">malloc</span>(num_threads * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread *));</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n=<span class="number">0</span>; n&lt;num_threads; n++)&#123;</span><br><span class="line">thread_init(thpool_p, &amp;thpool_p-&gt;threads[n], n);</span><br></pre></td></tr></table></figure><h5 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h5><ol><li><p>对于<strong>资源申请失败的处理</strong>，防止<strong>异常退出和内存泄漏</strong></p><p>由于malloc申请失败是不报错的，在malloc之后<strong>一定要判断返回的指针值是否为NULL</strong>。如果对于这个空指针不做处理，那之后对于空指针的操作<strong>会引发Segmentation Fault</strong>而程序直接core了。还有就是在异常处理中要对已经申请的资源释放掉，否则会引发<strong>内存泄漏</strong></p></li><li><p>对于<strong>传值和传址</strong>的区分，传值传的是值的拷贝</p></li></ol><p>​如果对于指针理解得比较困难的开发者可以看看<a href="https://space.bilibili.com/519963684">南科大于仕琪老师的C&#x2F;C++教程</a></p><h4 id="int-thpool-add-work-thpool-thpool-p-void-function-p-void-void-arg-p"><a href="#int-thpool-add-work-thpool-thpool-p-void-function-p-void-void-arg-p" class="headerlink" title="int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p)"></a>int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p)</h4><ol><li>创建任务</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newjob = (<span class="keyword">struct</span> job *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br></pre></td></tr></table></figure><ol start="2"><li>配置函数和函数参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newjob-&gt;function = function_p;</span><br><span class="line">newjob-&gt;arg = arg_p;</span><br></pre></td></tr></table></figure><ol start="3"><li>将任务加入队列</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob);</span><br></pre></td></tr></table></figure><h5 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h5><ol><li><p>对于队列<strong>没有任务时的处理</strong></p><p>不是采用轮询的方式，而是使用条件变量，在有任务时唤醒条件变量</p></li><li><p>对于<strong>函数指针类型转换的处理</strong></p></li></ol><p>​自定义的函数原型可以与api的原型不一致，但需要进行强制类型转换，<code> (void *(*)(void *))</code>里面中间的*表示当前为函数指针，右边的void *表示参数类型，左边的void *表示返回值类型。切记不要让编译器去做这种类型转换，可能会有意想不到的问题。（pthread_create参数里最后的函数指针的参数这样写好像就不必转换类型了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   int pthread_create(pthread_t *restrict thread,</span></span><br><span class="line"><span class="comment">//                   const pthread_attr_t *restrict attr,</span></span><br><span class="line"><span class="comment">//                   void *(*start_routine)(void *),</span></span><br><span class="line"><span class="comment">//                   void *restrict arg);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static void *thread_do(struct thread *thread_p)</span></span><br><span class="line">pthread_create(&amp;(*thread_p)-&gt;pthread, <span class="literal">NULL</span>, (<span class="type">void</span> *(*)(<span class="type">void</span> *))thread_do, (*thread_p));</span><br></pre></td></tr></table></figure><h4 id="void-thpool-destroy-thpool-thpool-p"><a href="#void-thpool-destroy-thpool-thpool-p" class="headerlink" title="void thpool_destroy(thpool_ *thpool_p)"></a>void thpool_destroy(thpool_ *thpool_p)</h4><ol><li>结构体元素的复位</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threads_keepalive = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> TIMEOUT = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">time_t</span> start, end;</span><br><span class="line">  <span class="type">double</span> tpassed = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过条件变量的唤醒终止线程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive)</span><br><span class="line">&#123;</span><br><span class="line">  bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">  time(&amp;end);</span><br><span class="line">  tpassed = difftime(end, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (thpool_p-&gt;num_threads_alive)</span><br><span class="line">&#123;</span><br><span class="line">  bsem_post_all(thpool_p-&gt;jobqueue.has_jobs);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>任务队列的释放</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobqueue_destroy(&amp;thpool_p-&gt;jobqueue);</span><br></pre></td></tr></table></figure><ol start="4"><li>其余堆上元素的释放</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; threads_total; n++)</span><br><span class="line">&#123;</span><br><span class="line">  thread_destroy(thpool_p-&gt;threads[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(thpool_p-&gt;threads);</span><br><span class="line"><span class="built_in">free</span>(thpool_p);</span><br></pre></td></tr></table></figure><h5 id="关注点-2"><a href="#关注点-2" class="headerlink" title="关注点"></a>关注点</h5><ol><li>对于<strong>线程释放的处理</strong></li></ol><p>​可以<strong>定义一个条件变量来唤醒所有线程</strong>，然后通过一个<strong>表示是否存活的布尔值来作为while循环的终止条件</strong>，达到优雅的释放</p><ol start="2"><li>别漏，别漏，别漏</li></ol><p>​一定要细心检查，不要忘记释放堆上的资源</p><h4 id="static-void-thread-hold-int-sig-id"><a href="#static-void-thread-hold-int-sig-id" class="headerlink" title="static void thread_hold(int sig_id)"></a>static void thread_hold(int sig_id)</h4><ol><li>注册信号量句柄</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function thread_do</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">act.sa_handler = thread_hold;</span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  err(<span class="string">&quot;thread_do(): cannot handle SIGUSR1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler function</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_hold</span><span class="params">(<span class="type">int</span> sig_id)</span></span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>)sig_id;</span><br><span class="line">threads_on_hold = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (threads_on_hold)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过信号量发送暂停信号</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; thpool_p-&gt;num_threads_alive; n++)</span><br><span class="line">&#123;</span><br><span class="line">  pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-thpool-resume-thpool-thpool-p"><a href="#void-thpool-resume-thpool-thpool-p" class="headerlink" title="void thpool_resume(thpool_ *thpool_p)"></a>void thpool_resume(thpool_ *thpool_p)</h4><p>修改循环条件值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)thpool_p;</span><br><span class="line">threads_on_hold = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们明白了线程池是什么（What），线程池有什么用（Why）以及接口的具体实现（How）。这个线程池项目中有许多值得学习的地方，比方说对于条件变量的使用，对于资源的申请和释放方法，是很优质的开源项目。另外，项目里也有可以扩充的点，比方说把队列改成比方说把队列改成优先级队列，那这样要考虑的东西就更多了，比方说它任务是可抢占还是不可抢占的，有任务的调度顺序的变化，这可能会牵涉到线程逻辑的大修改，如果大家感兴趣的话可以试试～</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB使用手册</title>
      <link href="/2025/01/05/GDB/"/>
      <url>/2025/01/05/GDB/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB使用手册"><a href="#GDB使用手册" class="headerlink" title="GDB使用手册"></a>GDB使用手册</h2><p>编译时加上<code>-g</code>选项</p><table><thead><tr><th>命令名称</th><th>命令缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行一个待调试的程序</td></tr><tr><td>continue</td><td>c</td><td>让暂停的程序继续运行</td></tr><tr><td>next</td><td>n</td><td>运行到下一行</td></tr><tr><td>step</td><td>s</td><td>单步执行，遇到函数会进入</td></tr><tr><td>until</td><td>u</td><td>运行到指定行停下来</td></tr><tr><td>finish</td><td>fi</td><td>结束当前调用函数，回到上一层调用函数处</td></tr><tr><td>return</td><td>return</td><td>结束当前调用函数并返回指定值，到上一层函数调用处</td></tr><tr><td>jump</td><td>j</td><td>将当前程序执行流跳转到指定行或地址，不运行跳过的代码</td></tr><tr><td>print</td><td>p</td><td>打印变量或寄存器值</td></tr><tr><td>backtrace</td><td>bt</td><td>查看当前线程的调用堆栈</td></tr><tr><td>frame</td><td>f</td><td>切换到当前调用线程的指定堆栈</td></tr><tr><td>thread</td><td>thread</td><td>切换到指定线程</td></tr><tr><td>break</td><td>b</td><td>添加断点</td></tr><tr><td>tbreak</td><td>tb</td><td>添加临时断点</td></tr><tr><td>delete</td><td>d</td><td>删除断点</td></tr><tr><td>enable</td><td>enable</td><td>启用某个断点</td></tr><tr><td>disable</td><td>disable</td><td>禁用某个断点</td></tr><tr><td>watch</td><td>watch</td><td>监视某一个变量或内存地址的值是否发生变化</td></tr><tr><td>list</td><td>l</td><td>显示源码</td></tr><tr><td>info</td><td>i</td><td>查看断点 &#x2F; 线程等信息</td></tr><tr><td>ptype</td><td>ptype</td><td>查看变量类型</td></tr><tr><td>disassemble</td><td>dis</td><td>查看汇编代码</td></tr><tr><td>set args</td><td>set args</td><td>设置程序启动命令行参数</td></tr><tr><td>show args</td><td>show args</td><td>查看设置的命令行参数</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面试题</title>
      <link href="/2025/01/05/C++questions/"/>
      <url>/2025/01/05/C++questions/</url>
      
        <content type="html"><![CDATA[<h3 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h3><ol><li>header中防御式声明的目的</li></ol><ul><li>防止两个头文件相互include时的循环include</li><li>防止cpp在include不同头文件时可能产生的重复定义</li></ul><ol start="2"><li>inline</li></ol><p>将函数声明为inline可以避免函数调用的开销，空间换时间</p><p>常规的函数调用需要用到栈，需要返回地址和参数压栈，但通过inline展开后就为普通的顺序执行</p><p><strong>与define的区别</strong>：</p><ul><li>define无类型检查，inline有</li><li>define编写时运算符的优先级较难处理</li><li>define在预处理时展开，inline由编译器实现展开</li></ul><ol start="2"><li>const</li></ol><p>const对象的<strong>值创建后值不能再改变</strong>，所以必须初始化</p><p>对于<strong>const指针</strong>，分为：</p><ul><li>底层const：<code>int* const p = &amp;a</code>无法改变p的指向</li><li>顶层const：<code>const int* p = &amp;a</code>无法通过p改变a的值</li></ul><p>对于<strong>const引用</strong>，其原来就不能改变引用的变量，所以只有底层const<code>const int&amp; a = 1</code></p><p>顶层const<strong>拷贝</strong>不受限制</p><p>底层const拷贝时，右值必须为非常量或者为底层const变量</p><p>对于<strong>const成员函数</strong>，无法改变成员变量的值</p><ol start="2"><li>Static</li></ol><ul><li><p>用于修饰变量：在函数内部，static 修饰的变量具有静态存储期，意味着它们的生命周期与程序的生命周期相同，而不是与函数的调用次数相关。在全局或命名空间作用域中，static 修饰的变量具有内部链接，只能在当前文件或当前命名空间中访问。</p></li><li><p>用于修饰函数：在函数内部，static 修饰的函数具有内部链接，只能在当前文件中调用，不能被其他文件调用。</p></li><li><p>用于修饰类成员变量：在类中，static 修饰的成员变量是类共享的，即所有类对象共享同一份内存。这些变量可以被类的任何成员函数访问，甚至在没有类对象的情况下也可以访问。需要注意的是，静态成员变量必须在类外进行定义和初始化。</p></li><li><p>用于修饰类成员函数：在类中，static 修饰的成员函数是类相关的，而不是对象相关的。这意味着它们不需要通过类对象来调用，可以直接通过类名来调用。</p></li></ul><ol start="2"><li>调用构造函数和析构函数，内存的影响</li><li>内存对齐</li></ol><p>分配内存时，按照一些规则对内存地址调整，不使用一些内存，通过空间换时间，优化访存效率</p><p>对于基础数据类型，按照4，8，16B等对齐</p><p>对于结构体和类，按照最宽基本数据类型为对齐单元</p><p>可以通过<code>sizeof()</code>查看</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）文件管理（数据库底层存储）</title>
      <link href="/2025/01/05/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%EF%BC%89/"/>
      <url>/2025/01/05/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM Tree"></a>LSM Tree</h4><p>在内存中维护一个Memtable并排序（AVL，红黑树等），当达到某一阈值后写入到磁盘，写入的结构称为SSTable</p><p>SSTable会定期进行压缩compaction，将重复的key以最新value压缩。由于数据量较大，所以通过数据大小对SStable分层</p><img src="/../../images/LSM_tree.png" alt="process_state" width=700px /><p><strong>读：</strong>从Memtable到各级SStable读取，由于SStable有序，可以通过范围判断是否在当前table，然后通过二分查找等方法查找</p><p><strong>写：</strong>直接增加到Memtable</p><p><strong>优化：</strong>布隆过滤器，通过哈希方法计算key是否存在，否表示肯定不存在，是表示可能存在</p><p><strong>优点：</strong>顺序写；写效率高</p><p><strong>缺点：</strong>读效率过低</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h4><p><strong>B树和B+树的区别</strong></p><ul><li>B树的每个节点都存储了key和data，而B+树的<strong>data存储在叶子节点上</strong>。</li><li>B+树非叶子节点仅存储key不存储data，这样<strong>一个节点就可以存储更多的key</strong>。可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以<strong>与磁盘交换的IO操作次数更少</strong>。</li><li>B+树所有叶子节点构成一个有序链表，按主键排序来遍历全部记录，能<strong>更好支持范围查找</strong>。<br>由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li><li>B+树所有的查询都要从根节点查找到叶子节点，<strong>查询性能更稳定</strong>；而B树，每个节点都可能查找到数据，需要在叶子节点和内部节点不停的往返移动，所以不稳定。</li></ul><h4 id="B-tree对比LSM-tree"><a href="#B-tree对比LSM-tree" class="headerlink" title="B tree对比LSM tree"></a>B tree对比LSM tree</h4><table><thead><tr><th>存储引擎</th><th>B-Tree</th><th>LSM-Tree</th><th>备注</th></tr></thead><tbody><tr><td>优势</td><td>读取更快</td><td>写入更快</td><td></td></tr><tr><td>写放大</td><td>1. 数据和 WAL 2. 更改数据时多次覆盖整个 Page</td><td>1. 数据和 WAL 2. Compaction</td><td>SSD 不能过多擦除。因此 SSD 内部的固件中也多用日志结构来减少随机小写。</td></tr><tr><td>写吞吐</td><td>相对较低： 1. 大量随机写。</td><td>相对较高： 1. 较低的写放大（取决于数据和配置） 2. 顺序写入。 3. 更为紧凑。</td><td></td></tr><tr><td>压缩率</td><td>1. 存在较多内部碎片。</td><td>1. 更加紧凑，没有内部碎片。 2. 压缩潜力更大（共享前缀）。</td><td>但紧缩不及时会造成 LSM-Tree 存在很多垃圾</td></tr><tr><td>后台流量</td><td>1. 更稳定可预测，不会受后台 compaction 突发流量影响。</td><td>1. 写吞吐过高，compaction 跟不上，会进一步加重读放大。 2. 由于外存总带宽有限，compaction 会影响读写吞吐。 3. 随着数据越来越多，compaction 对正常写影响越来越大。</td><td>RocksDB 写入太过快会引起 write stall，即限制写入，以期尽快 compaction 将数据下沉。</td></tr><tr><td>存储放大</td><td>1. 有些 Page 没有用满</td><td>1. 同一个 Key 存多遍</td><td></td></tr><tr><td>并发控制</td><td>1. 同一个 Key 只存在一个地方 2. 树结构容易加范围锁。</td><td>同一个 Key 会存多遍，一般使用 MVCC 进行控制。</td><td></td></tr></tbody></table><h4 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h4><p>优点：</p><ul><li>优化了select速度</li><li>减少磁盘IO</li></ul><p>缺点：</p><ul><li><p>对于非聚簇索引，需要额外的磁盘空间</p></li><li><p>增删改需要更新索引</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）文件管理（系统调用与文件存储）</title>
      <link href="/2025/01/05/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/01/05/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h4><h5 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h5><p>在文件系统和应用程序间有一层抽象层，称为虚拟文件系统（VFS）</p><ul><li>VFS作为抽象层向应用层提供了统一的文件接口（read，write等）</li><li>VFS实现了一些公共的功能，如Directory Cache和Page Cache等</li><li>规范了接口</li></ul><p>VFS向应用层提供统一接口，具体实现不同文件系统有不同实现，VFS将函数指针指向对应函数</p><img src="/../../images/fs_architecture.png" width=500px /><h5 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h5><p><strong>文件系统的注册</strong></p><p>在Linux中，具体文件系统通常是一个内核模块，在内核模块被加载时完成文件系统的注册</p><p><strong>磁盘挂载</strong></p><p>将dentry修改为挂载点，增加上级目录inode项</p><p><strong>打开文件</strong></p><p>用户层面：传入路径，打开模式；返回文件句柄fd</p><p>系统层面：PCB创建fd，指向打开文件表（open file table）中对应内容</p><p>具体实现：</p><ol><li>应用程序调用 <strong>open 系统调用</strong>，该调用需要提供文件名和打开模式等参数。</li><li>操作系统<strong>查找保存在内存的打开文件表（open file table）</strong>中是否有该文件，如果该文件表项已经存在（例如已经打开），则检查打开模式<strong>是否允许重复打开（例如 O_EXCL）</strong>，如果不允许则直接返回该文件表项，否则返回错误信息。</li><li>如果文件表项不存在，则<strong>分配一个新的文件表项（file）加入打开文件表</strong>，并将其与相应的 vnode 或 inode 相关联。</li><li>如果打开模式<strong>允许创建新文件（例如 O_CREAT），且文件不存在，则创建一个新的 vnode 或 inode</strong>，并将其与新的文件表项相关联。</li><li>操作系统将文件表项的状态设置为打开状态，并返回该文件表项的文件描述符（file descriptor）给应用程序。</li><li>应用程序可以使用返回的文件描述符对文件进行读写等操作。</li><li>当应用程序不再需要该文件时，可以使用 close 系统调用关闭文件，操作系统会释放相应的文件表项和 vnode 或 inode。</li></ol><p><strong>读取文件</strong></p><p>用户层面：传入fd，buffer，size；返回实际读取到的字节数，buffer得到数据</p><p>系统层面：先访问pagecache，如果包含则从pagecache中读取，否则通过inode访问数据块，拷贝到pagecache然后拷贝到用户态buffer</p><p>读文件的流程如下（考虑缓存）：</p><ol><li>应用程序发起读取文件的系统调用（read()）。</li><li>如果该文件已经被打开并且缓存在 Page cache 中，则直接从 Page cache 中读取文件数据，并返回给应用程序。如果 Page cache 中没有该文件的缓存，则进入下一步操作。</li><li>内核会在虚拟内存空间中分配一个缓冲区（buffer），用于存储文件数据。然后通过文件系统的 readpage() 回调函数，从磁盘上读取文件的一页数据，存储到缓冲区中。</li><li>如果读取成功，则将读取的数据存储到 Page cache 中，并返回读取的数据给应用程序。</li><li>如果读取失败，则返回错误码给应用程序。</li><li>应用程序继续读取下一页数据，直到读取完整个文件或者出现错误为止。</li></ol><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><h5 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h5><p>将近期访问文件的inode缓存道内存中，空间满后通过<strong>LRU或LFU</strong>替换</p><h5 id="预读算法"><a href="#预读算法" class="headerlink" title="预读算法"></a>预读算法</h5><p>会比请求的数据块多读一些数据。触发条件是：</p><ul><li>当有多个地址连续的读请求时</li><li>当访问到有预读标记的缓存时</li></ul><h5 id="快照与克隆技术"><a href="#快照与克隆技术" class="headerlink" title="快照与克隆技术"></a>快照与克隆技术</h5><p><strong>快照</strong>实现文件的可读备份，有两种方法，一种是写时拷贝（COW），在做完快照后第一次对文件写会拷贝文件内容</p><p>另一种是写时重定位（ROW），原始文件写数据时不在原有位置，而是分配一个新位置，更新逻辑地址和实际位置对应关系</p><p><strong>克隆</strong>实现文件的可写备份，多用ROW实现，和快照区别是可写，数据隔离</p><p><strong>Page Cache</strong></p><p>Page cache 是 Linux 系统中的一种缓存机制，用于缓存文件系统中的数据和元数据。Page cache 以物理页的形式保存在内存中，每个物理页通常大小为 4KB 或 8KB，对应一个虚拟页（VMA）。</p><p>Page cache 包含以下内容：</p><ol><li>文件数据：Page cache 用于缓存文件系统中的数据，例如读取的文件内容。文件数据通常保存在匿名页（anonymous page）中，即没有对应的文件，只保存数据。当读取文件时，内核会将文件数据从磁盘读入匿名页中，并将该匿名页添加到 Page cache 中。</li><li>文件元数据：Page cache 还用于缓存文件系统中的元数据，例如文件属性、索引节点等。文件元数据通常保存在映射页（mapped page）中，即与文件系统中的文件或目录关联。当访问文件元数据时，内核会将该映射页从磁盘读入 Page cache 中。</li><li>Page 缓存清单：Page cache 中保存了所有 Page 缓存页的清单，每个页都有一个 struct page 结构体来描述。该结构体包含了页框地址、引用计数、状态等信息，同时还保存了与该页相关联的 vnode 或 inode 等信息。</li></ol><p>Page cache 通常存储在操作系统内核的地址空间中，通过 page struct 结构体来表示。Page cache 通过页面映射（page mapping）和内存管理单元（MMU）机制，将虚拟页映射到物理页，实现了高效的文件系统访问。同时，Page cache 的引入也避免了频繁的磁盘访问，提高了文件系统的性能</p><p><strong>日志型存储</strong></p><p>日志型存储（Log-Structured Storage）是一种文件系统存储方式，其特点是将所有文件数据写入到一个连续的、循环的、预先分配好的日志区域（Log）中，而非传统的随机分散的数据块中。</p><p>日志区域中的每个写操作都会被记录到一个日志（Log）中，这个日志记录了文件系统的所有操作，包括创建、删除、修改文件等操作。当文件系统崩溃或重启时，文件系统会依据日志中记录的操作，恢复文件系统的状态。</p><p>日志型存储的优点是：</p><ol><li><strong>写性能较高</strong>：由于所有的写操作都是顺序写入到一个连续的日志区域中，因此写性能比传统的文件系统更高。</li><li><strong>可靠性高</strong>：由于所有的写操作都是顺序写入到一个连续的日志区域中，并且每个写操作都被记录到一个日志中，因此即使文件系统发生故障，也可以通过日志来恢复文件系统的状态，数据不容易丢失。</li><li><strong>压缩效果好</strong>：由于所有文件数据都是顺序写入到一个连续的日志区域中，因此可以采用更高效的压缩算法来减少磁盘空间的使用。</li></ol><p>但是，日志型存储也有其缺点，主要包括：</p><ol><li><strong>读性能相对较低</strong>：由于文件数据是顺序存储的，因此随机读取数据的性能相对较低。</li><li><strong>文件删除和空间回收不容易</strong>：由于文件数据是顺序存储的，因此删除一个文件时，需要从日志中找到该文件的所有数据块，并标记为已删除，这个过程比较繁琐。而空间回收也需要扫描整个日志，找到所有已删除的数据块，并将其标记为可用空间。</li></ol><p>日志型存储主要应用于需要较高写性能和可靠性的场景，例如数据库存储、分布式存储等。常见的日志型文件系统包括Log-structured File System（LFS）、WAFL、Ext3cow等。</p><p><strong>EXT文件系统</strong></p><p>ext3相比ext2增加日志技术</p><p>ext4相比ext3增加extents技术，对于大文件通过保存起始位置和块数，减少大文件需要保存的元数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）文件管理</title>
      <link href="/2025/01/05/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/05/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="磁盘的工作原理"><a href="#磁盘的工作原理" class="headerlink" title="磁盘的工作原理"></a>磁盘的工作原理</h4><h5 id="磁盘读写的过程"><a href="#磁盘读写的过程" class="headerlink" title="磁盘读写的过程"></a>磁盘读写的过程</h5><ol><li>磁盘移动，找到要读的<strong>柱面</strong>（cylinder，简称C）</li><li>从柱面选择具体读哪个<strong>磁道</strong>（magnetic head，简称H），选择对应的磁头上电（每次只能有一个磁头上电）</li><li>旋转磁盘，将对应磁道中要读写的那个<strong>扇区</strong>（sector，简称S）转到磁头下方</li><li>开始读写，将扇区中的内容读到内存缓存区中，或者将内存缓存区中的内容写到该扇区中</li></ol><img src="/../../images/physical_disk.png" width=400px /><h4 id="生磁盘的使用"><a href="#生磁盘的使用" class="headerlink" title="生磁盘的使用"></a>生磁盘的使用</h4><h5 id="第一层抽象：从扇区到磁盘块请求（抽象读写请求）"><a href="#第一层抽象：从扇区到磁盘块请求（抽象读写请求）" class="headerlink" title="第一层抽象：从扇区到磁盘块请求（抽象读写请求）"></a>第一层抽象：从扇区到磁盘块请求（抽象读写请求）</h5><p>正常寻址需要通过<strong>CHS</strong>三维向量，但是可以通过一位扇区编号编址</p><p>磁盘读写时间 &#x3D; 寻道时间（选择柱面）+旋转时间（选择+读取扇区）+传输时间（磁生电活电生磁）</p><p>其中寻道时间占主导，故每次只读&#x2F;写一个扇区是对于时间的浪费，故一次读&#x2F;写多个扇区，称为<strong>块</strong></p><h5 id="第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）"><a href="#第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）" class="headerlink" title="第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）"></a>第二层抽象：多个进程产生的磁盘请求队列（抽象读写方法）</h5><p><strong>电梯调度算法</strong>（CSCAN），磁头向一个方向运动，运动到提交访问的边界后复位，循环往复（复位防止内&#x2F;外部块容易回复请求）</p><img src="/../../images/CSCAN.png" width=400px /><h5 id="第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）"><a href="#第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）" class="headerlink" title="第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）"></a>第三层抽象：从磁盘请求到高速缓存（优化磁盘读写次数）</h5><p><strong>读缓冲</strong>：由于<strong>局部性原理</strong>，用户可能要在短时间内连续请求磁盘块中的相邻内容，所以操作系统一次读取一个&#x2F;多个磁盘块到<strong>磁盘高速缓存</strong></p><p>通过盘块号查看是否在磁盘高速缓存中，在则直接返回，不在则访问磁盘</p><img src="/../../images/disk_cache.png" width=400px /><p><strong>写缓冲</strong>：通过延迟写入节省IO次数</p><p><strong>如果需要立即写会防止写入前系统崩溃可以使用fsync系统调用，除了文件调用外如果目录也是新创建的，需要目录也调用（目录也是文件）</strong></p><h4 id="基于文件的磁盘使用"><a href="#基于文件的磁盘使用" class="headerlink" title="基于文件的磁盘使用"></a>基于文件的磁盘使用</h4><h5 id="第四层抽象：引出文件（用户的文件视图）"><a href="#第四层抽象：引出文件（用户的文件视图）" class="headerlink" title="第四层抽象：引出文件（用户的文件视图）"></a>第四层抽象：引出文件（用户的文件视图）</h5><p>存储结构</p><ol><li><p>顺序存储：不便于动态增长</p></li><li><p>链式存储：无法随机访问</p><p>隐式链接存储</p><p>缺点：稳定性较差，系统在运行过程中由于软件或者硬件错误<strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。</strong></p><p>显式链接存储</p><p>它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张，每个表项中存放链接指针，指向下一个数据块号。内存中的这样一个表格称为<strong>文件分配表（File Allocation Table，FAT）</strong>。</p><img src="/../../images/FAT.png" width=400px /></li><li><p>索引存储：通过索引块记录文件包含的所有块，可以随机访问</p><img src="/../../images/file_index.png" width=500px /></li></ol><p><strong>Unix系统中的文件存储（多级索引）</strong></p><img src="/../../images/inode_multi_index.png" width=500px /><p>它是根据文件的大小，存放的方式会有所变化：</p><ul><li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li><li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li><li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li><li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li></ul><p>那么，文件头（<em>Inode</em>）就需要包含 13 个指针：</p><ul><li>10 个指向数据块的指针；</li><li>第 11 个指向索引块的指针；</li><li>第 12 个指向二级索引块的指针；</li><li>第 13 个指向三级索引块的指针；</li></ul><p>所以，这种方式能很灵活地支持小文件和大文件的存放：</p><ul><li>对于小文件使用直接查找的方式可减少索引数据块的开销；</li><li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询</li></ul><h4 id="文件系统使用"><a href="#文件系统使用" class="headerlink" title="文件系统使用"></a>文件系统使用</h4><h5 id="cat的系统调用"><a href="#cat的系统调用" class="headerlink" title="cat的系统调用"></a>cat的系统调用</h5><p>每个文件在read时都会返回一个非负整型<strong>文件描述符（file descriptor）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">martin &gt; strace cat test  # strace is a tool to print system call</span><br><span class="line"># hello in test</span><br><span class="line">...</span><br><span class="line">openat(AT_FDCWD, &quot;test&quot;, O_RDONLY)      = 3   # open file, return file descriptor</span><br><span class="line">newfstatat(3, &quot;&quot;, &#123;st_mode=S_IFREG|0644, st_size=6, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0</span><br><span class="line">mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xffff9e49e000</span><br><span class="line">read(3, &quot;hello\n&quot;, 131072)              = 6 # read first block to a read buffer, return size of string</span><br><span class="line">write(1, &quot;hello\n&quot;, 6hello# write hello to stdout</span><br><span class="line">)                  = 6</span><br><span class="line">read(3, &quot;&quot;, 131072)                     = 0 # read next block</span><br><span class="line">munmap(0xffff9e49e000, 139264)          = 0</span><br><span class="line">close(3)                                = 0 # close test</span><br><span class="line">close(1)                                = 0# close stdout</span><br><span class="line">close(2)                                = 0# close stderr</span><br><span class="line">exit_group(0)                           = ?</span><br></pre></td></tr></table></figure><p>操作系统为<strong>每个进程维护一个打开文件表</strong>，文件表里的每一项代表文件描述符。</p><p>操作系统在打开文件表中维护着打开文件的状态和信息：</p><ul><li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li><li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li><li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li><li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求</li></ul><h5 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接"></a>硬链接与软链接</h5><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<strong>硬链接（Hard Link）</strong> 和<strong>软链接（Symbolic Link）</strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p><img src="/../../images/hard_link.png" width=500px /><p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p><img src="/../../images/symbolic_link.png" width=500px /><h4 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h4><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><img src="/../../images/block_group.png" width=500px /><p>最前面的第一个块是<strong>引导块</strong>，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p><ul><li><strong>超级块</strong>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li><li><strong>块组描述符</strong>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li><li><strong>数据位图和 inode 位图</strong>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li><li><strong>inode 列表</strong>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li><li><strong>数据块</strong>，包含文件的有用数据。<strong>基本文件类型inode指向的数据块存储的是文件内容，目录类型inode指向的数据块存储的是该目录下文件和目录的inode</strong>。</li></ul><h5 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h5><p><strong>一个inode唯一对应一个文件或目录</strong></p><p>inode包含所有关于文件的信息，包括</p><ul><li><p>i_number：inode的id</p></li><li><p>文件类型（常规文件，目录等）</p></li><li><p>分配给它的块数</p></li><li><p>保护信息（谁拥有该文件以及谁可以访问它）</p></li><li><p>时间信息（创建，修改，上次访问的时间）</p></li><li><p>所有对应数据块的位置信息（混合索引）</p></li></ul><h5 id="目录的读取"><a href="#目录的读取" class="headerlink" title="目录的读取"></a>目录的读取</h5><p>例如访问&#x2F;usr&#x2F;test.c</p><ol><li>找到根目录的inode，<strong>在类UNIX系统中根目录的i_number为2</strong></li><li><strong>读取i_number为2的inode</strong>，访问指向的数据块，<strong>获取下级目录的inode</strong></li><li><strong>根据inode访问对应数据块</strong></li></ol><img src="/../../images/dentry.png" width=500px /><h5 id="磁盘的写入"><a href="#磁盘的写入" class="headerlink" title="磁盘的写入"></a>磁盘的写入</h5><p>如果文件未被创建</p><ol><li>查询数据块位图查找空闲块，设置inode</li><li>读取inode位图，查找空闲位图块</li><li>写入inode位图</li><li>写入inode</li><li>创建当前目录inode和数据块，查找上级目录数据块更新当前目录inode</li></ol><p>如果已被创建</p><ol><li>读取数据位图，查询空闲块</li><li>写入数据位图</li><li>更新当前文件的inode</li></ol><p><strong>对象存储、块存储和文件存储</strong></p><p>对象存储、块存储和文件存储是三种不同的数据存储方式。它们各有特点和适用场景，下面分别介绍它们的定义和区别：</p><ol><li>对象存储</li></ol><p>对象存储是一种存储数据的方式，<strong>它将数据分为对象，每个对象有一个唯一的标识符（ID）</strong>。对象存储系统通常是由多个分布式存储节点构成，每个节点都能够存储和访问对象。对象存储通常用于存储大规模的非结构化数据，如图片、视频、音频、日志等。相比于传统的文件存储方式，对象存储更适合于分布式环境下的数据存储和管理，具有高可扩展性、高可靠性和高可用性等特点。</p><ol start="2"><li>块存储</li></ol><p>块存储是一种以块为单位的存储方式，将数据分为固定大小的块，并按块来读取和写入数据。块存储通常用于存储结构化数据，如数据库中的数据。块存储系统通常由存储设备（如硬盘、固态硬盘等）和控制器组成，存储设备负责存储数据块，控制器负责管理块的分配和释放。相比于对象存储和文件存储方式，块存储具有更快的数据读写速度和更高的并发性能，但它需要应用程序自己管理数据的组织方式和存储位置等。<strong>文件系统在客户端</strong></p><ol start="3"><li>文件存储</li></ol><p>文件存储是一种将数据组织成文件的存储方式，每个文件有一个唯一的文件名，并以文件为单位进行读写。文件存储通常用于存储应用程序的配置文件、日志文件、文本文件等，它具有简单易用、易于管理的特点。相比于对象存储和块存储，文件存储方式更适合于存储小型的结构化和非结构化数据，但它对文件数量的管理和文件系统的维护可能需要更多的人力和资源。<strong>文件系统在存储端，便于共享，如NAS</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）内存管理</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h2><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><p>在编译形成可执行程序时，用到的地址都是从0开始的相对地址，也被称为<strong>逻辑地址</strong>。但被加载到内存后可能使用任意一块空闲地址，所以需要将逻辑地址转化成内存中实际的物理地址，即<strong>重定位</strong>。</p><p>有以下几种解决方法：</p><ol><li><p>编译时重定位：需要在编译时确定哪块内存空间空闲，且在装入前不允许使用（用于执行固定任务的计算机系统，如嵌入式系统）</p></li><li><p>载入时重定位：在程序载入时，根据初始内存地址修改程序里的逻辑地址，但如果进程阻塞换出内存后换入时的地址不一定是之前的地址，造成错误</p></li><li><p><strong>运行时重定位（PC机使用）</strong>：在指令执行时才将逻辑地址转化为物理地址，取出指令—修改地址（<strong>存储管理部件MMU</strong>计算）—执行指令</p><p>基地址存在PCB中，在内存基地址修改时更新，在执行时加载到寄存器中使MMU修改地址</p><img src="/../../images/mem_base.png" width=700px /></li></ol><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>程序由若干段组成，每段都有各自的用途</p><ul><li>代码段：程序指令形成的段，只读</li><li>数据段：存放程序使用的数据，可读可写</li><li>栈：实现函数调用，通常只能向下（低地址）增长</li><li>函数库：include的函数库，可有可无</li></ul><img src="/../../images/memoryLayoutC.jpg" width=500px /><p>由于各个段有不同的语义及限制操作，所以需要进行区分。</p><p>因为程序已经分段，故不需要将其整体放入内存的连续空间，可一段段放入不同的内存空间，提高内存使用效率</p><p>在进行重定位时，访问<strong>段表（局部描述符表LDT，PCB中）</strong>中对应段的基地址给MMU运算得到物理地址</p><img src="/../../images/seg_table.png" width=700px /><p>分段的缺点是由于段较大，经过多次的申请和释放，很容易产生很多细小的无法分配给其他进程的<strong>内存碎片</strong>，故引入基于物理地址的分页机制（区别于基于逻辑地址分段机制）</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页机制首先将内存分为大小相等的页框（通常为4B），然后再把请求放入内存的数据切成大小相同的页，最后将所有页映射到页框上。<strong>以解决内存碎片问题造成的空间浪费。</strong></p><p><strong>页表存在内存中</strong></p><img src="/../../images/page_table.png" width=700px /><p>在32位机上最大的逻辑地址为2^32，每个页面4K，所以有2^20页，每个页表项需要4B存储，故每个进程需要4MB在存储页表（每个进程都有自己的页表），当进程数多时，需要很大的空间存储页表，但实际上页表只是做了索引保存基地址的作用，没有实际作用，这代价不可接受。</p><p>但是由于程序的<strong>局部性原则</strong>，不需要把程序的所有页加载到内存中，可以去除未被使用的逻辑页，<strong>缩小页表</strong>。</p><p>可是这又引发了其他问题，由于删除了未使用项导致页表无法随机访问，需要通过多次查找页表获取页号对应的页框号。<strong>每次访问页表就是访问内存，效率很低。</strong>所以引入了<strong>多级页表</strong>，且保证<strong>页表项连续</strong>，可以随机访问，减少搜索（访存）次数，另外<strong>只在内存中存需要一级页表对应的页表项</strong>，提升内存利用率。</p><img src="/../../images/multi_page.png" width=700px /><p>由于程序的<strong>局部性原则</strong>，访问的页集中，所以可以将近期使用的页信息放在<strong>快表（TLB，Cache中）</strong>，减少访存次数。</p><p>TLB内页表项无序。</p><img src="/../../images/TLB.png" width=700px /><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>从程序员角度，程序分为一个个逻辑段，但分段的缺点是由于段较大，在申请和释放时很容易产生内存碎片</p><p>从内存角度，程序分为一个个小的长度均匀的物理页存放到内存中，优点是提高了内存的利用率，但是有违程序员对于程序的理解</p><p>所以引入<strong>段页式内存管理</strong>方式，先将程序分段，再将程序分页，存储到物理内存上</p><img src="/../../images/virtual_add.png" width=500px /><p>当<strong>磁盘上的一个程序要放入内存</strong>时，会依次完成如下工作：</p><ol><li>在<strong>虚拟内存分割分区，放入各个“段”</strong>，不是真的放入，而是建立映射关系（fork出的子进程和父进程用不同的虚拟内存）</li><li><strong>建立段表</strong>记录<strong>逻辑地址和虚拟地址的映射</strong>关系</li><li>将<strong>虚拟内存分割成页，放入空闲物理内存</strong></li><li>建立页表记录<strong>逻辑地址和物理地址的映射</strong>关系（fork出的子进程拷贝父进程的映射关系，但如果子进程要修改数据区，则申请新内存页，建立映射关系，内核已将父进程的内存空间设为只读，防止了子进程的修改，所以子进程对于数据区的修改不会影响父进程）</li></ol><img src="/../../images/address_translate.png" width=700px /><p>虚拟地址对用户透明，用户无法获取物理地址</p><img src="/../../images/different_view_of_mem.png" width=700px /><h3 id="页的换入和换出"><a href="#页的换入和换出" class="headerlink" title="页的换入和换出"></a>页的换入和换出</h3><p>虚拟内存就是操作系统给进程提供的一个规整的、总长度总为4GB（32位操作系统）的地址空间，但实际的物理内存可能少于4GB，所以虚拟内存不可能全部映射到物理内存上，需要物理内存和磁盘存储的<strong>换入&#x2F;换出操作</strong>。</p><p>通过虚拟内存和页表<strong>确认页表项</strong>，看其有效位是否为1（0表示在物理内存中，1表示不在），若为0，则需从磁盘<strong>换入</strong>。换入的系统调用（缺页中断）如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 0: push variable to stack</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_no_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> error_code, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">  address &amp;= <span class="number">0xfffff00</span>; <span class="comment">// Step 1: get page numuber</span></span><br><span class="line">  page = get_free_page(); <span class="comment">// Step2: malloc free page on physical memory</span></span><br><span class="line">  bread_page(page,current-&gt;executable-&gt;i_dev, nr); <span class="comment">//Step3: copy block to physical memory</span></span><br><span class="line">  put_page(page, address); <span class="comment">//Step4: update page table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果物理内存满在<code>Step 2</code>直接分配内存会失败，需要选取页面<strong>换出</strong></p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ol><li>LRU（最近最少使用）</li></ol><p>基于页面栈（数据结构采用链表），搜索新页面是否在栈中，若不在则pop栈底元素，新元素入栈。如果在，则将栈顶元素修改为当前元素，其他元素下移</p><img src="/../../images/LRU.png" width=700px /><p><strong>操作系统不采用，因为每次页面访问都需要维护页面栈，也就是访存，另外还涉及到指针的修改</strong></p><ol start="2"><li>clock算法（SCR算法，second-chance-replacement）</li></ol><p><strong>clock算法是对于LRU的近似，LRU为最近最少使用，clock为最近的上次缺页以来不使用</strong></p><p>页面每次访问时R位置1，缺页时扫描当前线性表</p><ul><li>如果R&#x3D;1，置为0，不换出给它一次机会</li><li>如果R&#x3D;0，换出，并将换入页R置为1</li></ul><img src="/../../images/clock_algo.png" width=500px /><p><strong>存在的问题是实际发生缺页的概率并不大，可能找不出R&#x3D;0的页，所以引入改近clock算法</strong></p><ol start="3"><li>改进的clock算法</li></ol><p>需要一个指针定期扫描所有页并将对应R置0，换出页遇到R&#x3D;0换出</p><img src="/../../images/advanced_clock_algo.png" width=700px />]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）进程管理（如何实现多进程）</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>运行中的程序（区别于未运行的静态程序），需要有数据结构保存当前运行的信息（PCB），便于切换不同进程</p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><img src="/../../images/process_state.png" alt="process_state" width=700px /><h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><p>操作系统切换进程（宏观）</p><p>例子为进程运行到磁盘读写操作后与其他进程的切换</p><img src="/../../images/process.png" alt="process" width=500px/><p>操作系统切换进程的PCB（微观）</p><img src="/../../images/PCB_use.png" alt="PCB_use" width=500px/><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p>PCB的结构</p><ul><li><strong>Process scheduling state</strong> – The state of the process in terms of “ready”, “suspended”, etc., and other scheduling information as well, such as priority value, the amount of time elapsed since the process gained control of the CPU or since it was suspended. Also, in case of a suspended process, event identification data must be recorded for the event the process is waiting for;</li><li><strong>Process structuring information</strong> – the process’s children id’s, or the id’s of other processes related to the current one in some functional way, which may be represented as a queue, a ring or other data structures;</li><li><strong>Interprocess communication information</strong> – flags, signals and messages associated with the communication among independent processes;</li><li><strong>Process Privileges</strong> – allowed&#x2F;disallowed access to system resources;</li><li><strong>Process State</strong> – new, ready, running, waiting, dead;</li><li><strong>Process Number (PID)</strong> – unique identification number for each process (also known as Process ID);</li><li><strong>Program Counter (PC)</strong> – a pointer to the address of the next instruction to be executed for this process;</li><li><strong>CPU Registers</strong> – register set where process needs to be stored for execution for running state;</li><li><strong>CPU Scheduling Information</strong> – information scheduling CPU time;</li><li><strong>Memory Management Information</strong> – page table, memory limits, segment table;</li><li><strong>Accounting Information</strong> – amount of CPU used for process execution, time limits, execution ID etc.;</li><li><strong>I&#x2F;O Status Information</strong> – list of I&#x2F;O devices allocated to the process.</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>将资源和指令执行分开，进程为资源+指令执行序列。</p><p><strong>线程几乎不拥有资源（通过共享进程的资源），只实现指令的切换（切换PC指针，寄存器等）</strong>，保留了并发的优点，避免了进程切换的代价（保留现场，切换PCB）</p><p><strong>当需要并发而且共享相同资源（内存）时使用多线程编程</strong>，进程间资源相互独立</p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><strong>只有用户级线程没有用户级进程，因为进程拥有内存资源，需要到内核态执行</strong></p><p>如果对于多线程使用同一个栈，则在return访问栈时会跳转到其他线程，所以应对于不同的线程使用不同的栈</p><p>yield：当前线程会尽量让出CPU资源来给其他线程执行</p><img src="/../../images/user_thread_one_stack.png" alt="user_thread_one_stack" width=700px /><p>每个线程使用不同栈，通过不同的栈顶指针区分，yield更新当前线程TCB的栈顶指针，切换到下个线程的TCB，取栈顶指针</p><img src="/../../images/user_thread_multi_stack.png" alt="user_thread_multi_stack" width=700px /><img src="/../../images/user_multi_process.png" alt="user_multi_process" width=700px /><p>操作系统无法看到用户级线程，进而无法分配硬件多核处理，只有通过内核级线程调用多核</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>有几个内核级线程就要有几套栈（每套包括用户态执行函数调用的栈，内核态执行函数调用的栈）</p><img src="/../../images/kernal_thread_stack.png" alt="kernal_thread_stack" width=700px /><img src="/../../images/kernal_thread_stack_exp.png" alt="kernal_thread_stack_exp" width=700px /><p>内核级线程切换步骤</p><img src="/../../images/kernal_thread_switch.png" alt="kernal_thread_switch" width=700px /><h3 id="CPU调度策略"><a href="#CPU调度策略" class="headerlink" title="CPU调度策略"></a>CPU调度策略</h3><h4 id="任务调度策略的三个基本准则"><a href="#任务调度策略的三个基本准则" class="headerlink" title="任务调度策略的三个基本准则"></a>任务调度策略的三个基本准则</h4><ul><li>任务周转时间：从新建到完成的时间</li><li>任务响应时间：从交互操作到任务响应的时间（前台任务关心）</li><li>系统吞吐量：一段时间内系统能完成的任务数</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ol><li>先来先服务</li><li>短作业优先调度：可抢占，平均周转时间短（作业运行时间只能近似给出）</li><li>轮转调度：保证响应时间</li><li>多级队列调度：两个任务队列，一个是采用轮转调度的前台任务，一个是采用短作业优先的后台任务</li><li>多级反馈队列调度：动态调整任务类型（近期多IO可能为前台任务，无IO时间片结束未完成可能为后台大任务）</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="多处理器和多核"><a href="#多处理器和多核" class="headerlink" title="多处理器和多核"></a>多处理器和多核</h4><p>多处理器：多套CPU，Cache，MMU（内存映射表）资源</p><p>多核：多个CPU，共用Cache和MMU</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）绪论</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>操作系统启动完后运行shell（shell也是一段程序，即&#x2F;bin&#x2F;sh） </p><p>鼠标点击，键盘按下后：</p><ol><li>硬件输入到系统消息队列</li><li>应用程序从内核应用消息队列取消息（GetMessage），做相应处理（执行函数）</li></ol><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>用户态的程序只能使用内存中用户段，不能使用内核段。内核态可以访问任何内存数据。</p><p>中断是用户态进入内核态的唯一方法</p><p>系统调用的核心：</p><ol><li>用户程序中包含<code>int 0x80</code>指令（中断）的代码</li><li>操作系统写中断处理，获取想调程序的编号(系统调用号)</li><li>操作系统根据编号执行相应代码</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（五）传输层</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h3><p>可靠的、保序的传输：TCP</p><ul><li>多路复用，解复用</li><li>拥塞控制</li><li>流量控制（防止接收方缓存区满造成的分组丢失）</li><li>建立连接</li></ul><p>不可靠、不保序的传输：UDP</p><ul><li>多路复用，解复用</li><li>没有为尽力而为的IP服务添加更多的其他服务</li></ul><p>都不提供的服务：</p><ul><li>延时保证</li><li>带宽保证</li></ul><h3 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h3><h4 id="RDT协议（递进关系）"><a href="#RDT协议（递进关系）" class="headerlink" title="RDT协议（递进关系）"></a>RDT协议（递进关系）</h4><ol><li><p>rdt1.0：不提供反馈信息（假设所有数据包都正确从发送端传送到接收端）</p></li><li><p>rdt2.0：<strong>停止等待协议</strong>，引入差错检验，接收方反馈，重传机制。接收方在检验后向发送方返回ACK（正确）&#x2F;NCK（错误），这里的重传是对于NCK的重传，没有考虑对于丢失处理的超时重传（假设所有反馈消息都能正确送到发送端，没有消息分组的丢弃）</p></li><li><p>rdt2.1：ACK&#x2F;NCK对于接受到的消息编号，由于为停止等待协议，发送方若未收到消息的确认则不发下个消息，所以只需要一个位表示序号0&#x2F;1</p></li><li><p>rdt2.2：通过对于上个消息序号的确认替代对于本次消息的NCK（基于rdt2.1的小升级）</p></li><li><p>rdt3.0：引入超时重传机制，可能在接收端会出现冗余分组，但rdt2.2已可以应对（应对消息分组的丢失，但由于为停止等待，网络利用率很低）</p></li></ol><h5 id="回退N步（GBN）协议"><a href="#回退N步（GBN）协议" class="headerlink" title="回退N步（GBN）协议"></a>回退N步（GBN）协议</h5><p>基于发送方的<strong>滑动窗口</strong>实现，允许发送方发送多个分组而不需要等待确认，但它也受限于流水线中未取人的分组书不能超过最大允许数N（<strong>流量控制</strong>，防止因接收方缓存空间不足引发的包丢弃）。</p><p>接收方只按序接收分组（假设为k），一次交付给上层一个分组，对于所有大于k的分组丢弃，即只维护一个待接收分组序号的变量</p><p>发送方采取<strong>累计确认</strong>，即对于k的ACK确保小于等于k的分组已被接受</p><p>缺点：接收方丢弃正确但失序的分组，存在<strong>冗余重传</strong>的问题</p><h5 id="选择重传（SR）协议"><a href="#选择重传（SR）协议" class="headerlink" title="选择重传（SR）协议"></a>选择重传（SR）协议</h5><p>发送方只对于超时或者错误的分组重传，通过接收方维护一个滑动窗口实现</p><p>对于发送方的冗余分组，发送方必须给出该分组的ACK，否则发送方滑动窗口始终无法前进</p><p>对于SR协议，窗口长度必须小于等于序号空间大小的一半</p><h4 id="可靠数据传输的机制"><a href="#可靠数据传输的机制" class="headerlink" title="可靠数据传输的机制"></a>可靠数据传输的机制</h4><img src="/../../images/reliable_2.png" alt="socket" style="zoom:100%;" /><img src="/../../images/reliable_1.png" alt="socket" style="zoom:100%;" /><h3 id="面向连接的TCP协议"><a href="#面向连接的TCP协议" class="headerlink" title="面向连接的TCP协议"></a>面向连接的TCP协议</h3><p>序号：当前分组编号</p><p>确认号：希望收到的下个分组的序号</p><p>发送方采取<strong>累计确认</strong>，接收方对于失序分组丢弃或者缓存（TCP未规定）</p><p>对于发送多个分组，如果超时，发送方只发送最早的未确认分组</p><p><strong>快速重传</strong>：接收方收到三个对于同样序号k的ACK，则立即发送k分组，不再等到超时</p><p><strong>流量控制</strong>：接收方把缓存区余量发送给接收方，便于接收方控制发送速率（捎带）</p><p><strong>三次握手</strong>：</p><img src="/../../images/tcp_three_hands.png" alt="socket" style="zoom:50%;" /><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><p>两次握手的问题（无法防止历史连接）：</p><img src="/../../images/tcp_two_hands.png" alt="tcp_two_hands" style="zoom:50%;" /><p>如果为三次握手</p><img src="/../../images/three_hands_good.png" alt="three_hands_good" style="zoom:50%;" /><p>TCP连接释放四次握手（其实是没法做到完备的）</p><img src="/../../images/tcp_four_close.png" alt="tcp_four_close" style="zoom:50%;" /><p><strong>拥塞控制</strong>：调整发送速率处理网络内部拥塞的问题</p><p>对于超时的拥塞控制机制（严重）</p><img src="/../../images/tcp_timeout.png" alt="tcp_timeout" style="zoom:50%;" /><p>对于三个冗余ACK的拥塞控制机制（不严重）</p><img src="/../../images/tcp_three_ack.png" alt="tcp_three_ack" style="zoom:50%;" /><p>快速恢复算法过程中，为什么收到新的数据后，cwnd 设置回了 ssthresh ？</p><ol><li>在快速恢复的过程中，首先 ssthresh &#x3D; cwnd&#x2F;2，然后 cwnd &#x3D; ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包；</li><li>随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。</li></ol><p><strong>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</strong></p><p><strong>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（四）应用层（网络编程）</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><img src="/../../images/udpprocess.png" alt="udpprocess" style="zoom:50%;" /><p>UdpClient</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&quot;hostname&quot;</span></span><br><span class="line">severPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_DGRAM) <span class="comment"># ipv4,udp</span></span><br><span class="line">message = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">clientSocket.sendto(message.encode(),(serverName,severPort))</span><br><span class="line">modifiedMessage,serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode)</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p>Udpserver</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)  <span class="comment"># ipv4,udp</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMssage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMssage.encode(), clientAddress)</span><br></pre></td></tr></table></figure><h4 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h4><img src="/../../images/tcpprocess.png" alt="tcpprocess" style="zoom:50%;" /><p>TcpClient</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&quot;servername&quot;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_STREAM) <span class="comment">#ipv4,tcp</span></span><br><span class="line">clientSocket.connect((serverName,serverPort))</span><br><span class="line">sentence = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">clientSocket.send(sentence.encode()) <span class="comment"># tcp three-way handshake to welcomesocket</span></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p>TcpServer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">welcomeSocket = socket(AF_INET,SOCK_STREAM) <span class="comment"># create for client to handshake</span></span><br><span class="line">welcomeSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line">welcomeSocket.listen(<span class="number">1</span>) <span class="comment"># accept one connection</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket,addr = welcomeSocket.accept() <span class="comment"># create socket to connect to client</span></span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    modifiedMssage = sentence.decode().upper()</span><br><span class="line">    connectionSocket.send(modifiedMssage.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>TCP需要在传输前建立连接，传输后关闭连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（三）应用层</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><p>传输层向应用层提供的服务为socket API</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>简化本主机应用层向传输层发送的非有效信息，通过socket代表一组信息</p><p>TCP socket包含源IP，源端口，目标IP，目标端口，连接状态</p><p>UDP socket包含源IP，源端口</p><p>但是传输报文时必须提供对方IP，port。接收报文时传输层需要上传对方的IP，port</p><img src="/../../images/socket.png" alt="socket" style="zoom:30%;" /><h3 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h3><p>http为无状态协议，状态通过cookies实现</p><img src="/../../images/http.png" alt="http" style="zoom:50%;" /><img src="/../../images/cookies.png" alt="cookies" style="zoom:50%;" /><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>IP到域名的转换，运行在UDP上</p><img src="/../../images/dns.png" alt="http" style="zoom:50%;" /><h3 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h3><p>FTP：文件传输协议</p><p>SMTP：简单邮件传输协议（发送）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（二）英特网</title>
      <link href="/2025/01/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%8B%B1%E7%89%B9%E7%BD%91/"/>
      <url>/2025/01/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%8B%B1%E7%89%B9%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>网络：由节点和边组成的结构</p><p>计算机网络：由主机节点（主机）和数据交换结点（数据的转发，如路由器交换机）构成的网络，边称为数据链路。</p><p>还可分为网络边缘（主机），网络核心（数据交换），接入（连接网络边缘和网络核心）</p><p>P2P（peer）：分布式处理，客户端也可以是服务端</p><p>吞吐量：在源主机和目标主机之间的有效传输速率</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>电路交换：独享资源，保证性能（计算机之间的通信有突发性，使用该方法则浪费的片较多）</p><p>分组交换：不独占资源，数据分组，存储转发（存在排队延迟和丢失，维护队列，超过长度则丢弃分组）</p><p>网络资源（如带宽）分成片：时分，频分，波分，码分</p><h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><p>节点处理延时：检查bit级差错，检查分组首部和决定将分组导向何处</p><p>排队延时：在输出链路上等待传输的时间</p><p>传输延时：将分组发送到链路上的时间</p><p>传播延时：在链路上的传输时间</p><h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><p>传输队列满，分组丢弃</p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>服务（service）：低层实体向上层实体提供它们之间的通信的能力</p><p>原语（primitive）：上层使用下层服务的形式</p><p>面向连接的服务：建立连接，通信，拆除连接（特点：保序）</p><p>无连接的服务：两个对等层实体在通信前不需要建立连接，不预留资源，不需要通信双方都是活跃（特点：不可靠，可能重复，可能失序）</p><h3 id="计算机网络层次结构"><a href="#计算机网络层次结构" class="headerlink" title="计算机网络层次结构"></a>计算机网络层次结构</h3><p>物理层：将帧转换为物理信号，在物理介质上传输（位）</p><p>数据链路层：使数据在相邻节点传输（帧）</p><p>网络层：使数据在端（主机）到端（主机）进行传输（分组packet，如果为无连接，称为数据报）</p><p>传输层：使数据在进程到进程进行传输，将网络层不可靠服务处理为可靠服务（报文段）</p><p>应用层：网络应用（报文）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）绪论</title>
      <link href="/2025/01/05/%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/01/05/%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>传输层：进程到进程</p><p>网络层：端到端（end to end），网络设备到网络设备</p><p>数据链路层：点到点（point to point）</p><p>物理层：数字信号与物理信号的转换</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft</title>
      <link href="/2025/01/05/Chapter4%20RAFT/"/>
      <url>/2025/01/05/Chapter4%20RAFT/</url>
      
        <content type="html"><![CDATA[<p>每个node维护一个election timeout（每次150ms-300ms随机）。作为follower，如果到了timeout则转为candidate</p><p>转完后参加vote：</p><ol><li>term+1</li><li>投给自己，并行发RequestVote RPC给所有的其他server</li><li>收server结果，如果获得超过半数的投票，则成为leader</li><li>如果没选出leader则进入election timeout，当选了则立刻发送一条AppendEntries消息给其他所有的服务器，没当选则等待leader的heartbeat</li></ol><p>在3前如果收到了其他candidate的RequestVote则重制timeout</p><p>term</p><p>拒绝过期的term</p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文导读 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMwareFT</title>
      <link href="/2025/01/05/Chapter3%20VMwareFT/"/>
      <url>/2025/01/05/Chapter3%20VMwareFT/</url>
      
        <content type="html"><![CDATA[<h4 id="状态转移和复制状态机"><a href="#状态转移和复制状态机" class="headerlink" title="状态转移和复制状态机"></a>状态转移和复制状态机</h4><p>状态转移（State Transfer）：Primary将自己的完整状态（例如内存中的内容），拷贝发给Backup</p><p>复制状态机（Replicated State Machine）：将来自客户端的操作或其他外部事件，从Primary传到Backup。由于<strong>外部操作比服务的状态要小得多</strong>，所以大多采用该方法，缺点是同步会比较复杂</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>主虚拟机(Primary VM)简称为主机，Backup VM 简称为备机</strong>。</p><p>VMware FT 需要两台物理服务器，主机与备机保持同步，虚拟机的虚拟磁盘在共享存储上。</p><p>所有的输入(如网络、鼠标、键盘等)都会输入到主机，然后通过 Logging channel 转发到备机，对于非确定性的操作，还将发送额外的信息，确保备机以确定性的方式执行这些操作。</p><p>两台虚拟机都会执行输入操作，但<strong>只有主机的输出会返回客户端，备机的输出会被管理程序丢弃</strong>。</p><img src="/../../images/VMware_ft_architecture.png" width=400px /><h4 id="非确定性事件"><a href="#非确定性事件" class="headerlink" title="非确定性事件"></a>非确定性事件</h4><p>非确定性事件：Primary和Backup执行会有不同的结果</p><table><thead><tr><th>事件</th><th>具体情况</th><th>解决方案</th></tr></thead><tbody><tr><td>客户端输入</td><td></td><td>通过log 确保网络数据包的内容，中断时间相同</td></tr><tr><td>怪异指令</td><td>随机数生成，时间获取等</td><td>Primary直接将结果传给Backup</td></tr><tr><td>多CPU的并发</td><td>不同的核做了不同的处理</td><td>论文没提到</td></tr></tbody></table><p>对于不确定性输入，必须记录足够的信息来重放，<em>但是论文中没有描述具体的日志格式</em>，可能有三种记录：</p><ul><li>事件发生时的指令序号；</li><li>日志类型。可能是普通的网络数据输入，也可能是怪异的指令；</li><li>数据</li></ul><img src="/../../images/VMware_logging.png" width=400px /><h4 id="输出控制"><a href="#输出控制" class="headerlink" title="输出控制"></a>输出控制</h4><p>VMware FT 通过确定性重放来产生相关的日志条目，但不将日志写入磁盘，而是通过 logging channel 发送给备机。备机实时重放日志项。</p><p>为了容错，必须在 loggin channel 上实现严格的容错协议，有以下要求：</p><p><strong>输出要求</strong>：如果备机在主机故障后接管，备机将以和主机已经向外界发送的输出完全一致的方式继续运行。</p><p>最简单的方式是对每一个输出操作创建一个特殊的日志项。</p><p>但有一种情况，假设虚拟机运行的是数据库，主机备机的数据都是 10。现在客户端发送自增请求，主机做了 <code>+1</code> 并回复给客户端 11，之后马上宕机了，更糟糕的是主机发送给备机的 <code>+1</code> 操作也丢包了。这时候备机还是 10，并接管了主机的工作，客户端再次请求 <code>+1</code>，又会收到 11 的回复。客户端会得到一个怪异的结果（自增两次还是 11）。</p><p>所以要求：</p><p><strong>输出规则：主机直到备机接收并确认了和输出相关的日志的时候，才发送输出给外界。</strong></p><p>这样做的目的是，只要备机收到了所有的日志条目，即使主机宕机了，备机仍能够重放到客户端最后看到的状态。</p><p>向外界的输出会被延迟，直到主机收到来自备机的确认。<strong>在Backup接管后需要把log buffer内的指令全部运行完才响应客户端的新请求。</strong></p><p><strong>几乎每一个复制系统都有这个问题：在某个时间点，主机必须停下来等待备机，这肯定会限制性能。</strong></p><blockquote><p>注意：因为没有两阶段提交事务，不能保证所有的输出只被生成一次。<strong>备机无法判断主机是在宕机之前还是之后发送了最后的输出，备机可能会重新执行一次输出操作</strong>。不过，VMware 通过其网络基础设施来检测重复数据包，并防止输出重传到客户端。</p></blockquote><h4 id="发现与处理故障"><a href="#发现与处理故障" class="headerlink" title="发现与处理故障"></a>发现与处理故障</h4><p>主机和备机必须快速知道另一方故障，通过 <strong>udp 心跳包</strong>和<strong>监控 logging channel 上的流量</strong>相结合来检测，如果心跳超时或 logging channel 流量停止则表明故障。</p><p>如果备机故障，主机就会停止向 logging channel 发送日志，继续正常运行。</p><blockquote><p>在这之后备机怎么追上主机呢？VMware有一个工具叫 VMotion，它能够在最小程度上中断虚拟机的执行，克隆一个虚拟机。</p></blockquote><p>如果主机故障，备机必须先重放，直到消耗完最后一个日志项。然后备机接替主机，开始向客户端生产输出。</p><p>为了确保一次只有一个虚拟机成为主机，避免出现脑裂，VMware 在共享存储上执行一个原子的 <code>test-and-set</code> 锁指令。该操作每次只能对其中一台机器返回成功，这在主机和备机因为网络分区都想接替工作时很有用。但如果共享存储因为网络问题不能访问，那么无论如何都不能正常工作。</p><p>当其中一台虚拟机发生故障时，VMware FT 会在另一台物理机上自动启动新的备份虚拟机来恢复冗余。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&mid=2247484239&idx=1&sn=27c7430f51e88628874ef1514cb6c152&chksm=9709808aa07e099c3d49637b05d62bf951ea48fa8e0c74b0d02f4af32e75569ea1bc535403ac&cur_album_id=1751707148520112128&scene=189#wechat_redirect">【MIT 6.824】学习笔记4: 主从复制(Primary&#x2F;Backup Replication)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文导读 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GFS</title>
      <link href="/2025/01/05/Chapter2%20GFS/"/>
      <url>/2025/01/05/Chapter2%20GFS/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>GFS是一个可以支持上千个机器和硬盘，上百用户同时访问的文件系统</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><table><thead><tr><th>问题或现象</th><th>解决办法</th></tr></thead><tbody><tr><td>机器错误</td><td>持续监控，错误发现，错误处理，自动恢复</td></tr><tr><td>文件过大</td><td>设计IO操作和block大小</td></tr><tr><td>大部分文件写为append而不是overwrite</td><td>只优化append保证性能和原子性</td></tr><tr><td>引入GFS特有文件读写方式</td><td>复用部分文件系统API</td></tr></tbody></table><h4 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h4><h5 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h5><ul><li>系统通过廉价机器组成</li><li>日常处理GB级的文件</li><li>写大部分为append</li><li>多个用户看到的同一个文件必须相同</li><li>保证高频使用的准确性</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>GFS<strong>不使用类似于POSIX的标准API</strong></p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>chunk：</strong>文件被分成<strong>固定大小</strong>的chunks。Chunkserver在本地磁盘保存chunks，通过chunk handle读写字节范围的chunk data</p><p><strong>master：</strong>master节点维护所有文件系统的<strong>元数据</strong>，包括namespace，可用的控制信息，文件到chunks的map-ping，当前所有chunks的存储位置。另外还控制系统级别的事件，比如chunk租约管理，孤立chunks的垃圾回收，chunkserver间的chunk迁移。master还会周期性地与chunkserver通信heartbeat信息，给它指令和收集信息</p><p><strong>client：</strong>GFS client节点链接所有应用实现文件系统API，代表应用程序<strong>与master和chunkserver通信</strong>。client只和masrer交换元数据，所有data通过直接与chunkserver通信拿到。client和chunkserver都不缓存文件data</p><img src="/../../images/gfs_architecture.png" width=700px /><h4 id="通信步骤（介绍GFS读方法）"><a href="#通信步骤（介绍GFS读方法）" class="headerlink" title="通信步骤（介绍GFS读方法）"></a>通信步骤（介绍GFS读方法）</h4><p>client不从master节点读写data，而是询问master哪个chunkserver可以访问，然后在一段时间内<strong>缓存</strong>该信息，之后直接与chunkserver通信</p><p>通信步骤如下：</p><ol><li>client将应用程序给的（file name，byte offset）转化为chunk index（offset&#x2F;chunk_size）</li><li>client将（file name，chunk index）传给master</li><li>master返回（chunk handle，chunk对应的所有备份文件的localtions）</li><li>client缓存这些信息，通过（file name，chunk index）和chunk handle的map记录</li><li>client优先向离自己最近的含有需要chunk的chunkserver请求（chunk handle，byte range），通常是请求所有的包含需要chunk的服务器</li><li>chunkserver返回client（chunk data）</li></ol><p>除非client的缓存信息过期或者文件被其他client打开，client不会访问master</p><p>由于读最近的server，所以<strong>data未必是最新的</strong></p><h4 id="Chunk大小"><a href="#Chunk大小" class="headerlink" title="Chunk大小"></a>Chunk大小</h4><p>chunk大小为64MB，选取这么大的优点是</p><ul><li>减少client和master的通信次数</li><li>减少client和master的TCP通信的overhead</li><li>减少master存储的元数据的大小</li></ul><p>缺点是</p><ul><li>如果原始data很小而且client一直访问它，会造成同一个chunk的高频访问</li></ul><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>master保存了三种主要的元数据</p><ul><li>file和chunk的namespace（NV）</li><li>file到chunks的映射（NV）</li><li>每个chunk副本的位置（V）</li></ul><p>所有元数据都存在master的内存中，前两个也存在持久化的log中，而且有远程的备份。对于第三个，master不使用持久化存储，因为master可以在启动后询问所有chunkserver它保存的chunk</p><h5 id="在内存中的数据结构"><a href="#在内存中的数据结构" class="headerlink" title="在内存中的数据结构"></a>在内存中的数据结构</h5><p>对于内存中元数据的周期性扫描可以实现</p><ul><li>chunk垃圾回收</li><li>在chunkserver出错时重新复制</li><li>为了平衡chunkservers中硬盘使用负载而需要的chunk迁移</li></ul><h5 id="chunk位置"><a href="#chunk位置" class="headerlink" title="chunk位置"></a>chunk位置</h5><p>master<strong>从不持久化记录</strong>哪几个chunkserver有特定chunk的副本，而是在启动时询问chunkserver这些信息</p><p>不进行持久化保存<strong>减少了master和chunkserver间的一些同步问题</strong>，比如chunkserver的退出和加入，名字的变化，失败和重启等等</p><h5 id="操作日志"><a href="#操作日志" class="headerlink" title="操作日志"></a>操作日志</h5><p>操作日志记录了每次重要的元数据变化，它不仅是元数据的持久化记录还规定了同步操作的顺序。只有在本地和远程的操作日志都更新后才进行具体操作。</p><p>使用checkpoint可以减少日志的大小，有问题时只需要从最近的checkpoint恢复即可</p><p>master 会在本地磁盘存储 log，而不是存到数据库，原因是：数据库的本质是某种 B 树或者 hash table，而相比之下追加 log 会更加高效；而且，通过在 log 中创建一些 checkpoint 点，重建状态也会更快</p><h4 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h4><h5 id="通过GFS保证"><a href="#通过GFS保证" class="headerlink" title="通过GFS保证"></a>通过GFS保证</h5><p><strong>file namespace</strong>的变化是原子的。通过master里的namespace锁保证</p><p>如果文件状态是consistent，则所有client看到的同个文件多个副本的data都是相同的，文件状态如下图</p><img src="/../../images/gfs_file_region.png" width=500px /><p>concurrent success表示所有client能看到相同的data但是不代表所有修改都被写入</p><p>应用程序可以区分undefined状态</p><p>GFS通过对于某个chunk及其所有副本以<strong>相同顺序写入</strong>来保证data是准确的，通过<strong>chunk version</strong>来标识写入的情况。过时的副本将不会参加接下来的变化或者被master将位置传给client，它将在之后以高优先级被回收</p><p>由于client缓存chunk位置，所以它<strong>可能会读到过时的chunk</strong>。这种情况无法避免，只能<strong>通过缓存时间失效并重新向master访问减少</strong></p><p>GFS通过<strong>定期向chunkserver握手</strong>，通过<strong>checksumming</strong>来检查问题。一旦有问题，data将尽早通过其他副本恢复。只有当所有副本都有问题时该data才会出错，应用程序会收到明确的错误信息而不是错误的data</p><h5 id="对应用程序的影响"><a href="#对应用程序的影响" class="headerlink" title="对应用程序的影响"></a>对应用程序的影响</h5><p>writer的所有record包含checksum等额外信息，来确保有效性</p><p>reader能够通过checksum来删除额外信息，找到data</p><h5 id="租约机制和修改顺序"><a href="#租约机制和修改顺序" class="headerlink" title="租约机制和修改顺序"></a>租约机制和修改顺序</h5><p>master会将chunk的lease（租约）授权给其中一个副本，称为primary，它可以规定修改的顺序，所有副本必须遵循primary的修改顺序</p><p>lease的timeout默认为60秒。然而只要chunk正在被改变，primary可以通过heartbeat message向master请求延长timeout。另外master也可以提前重新分配primary。</p><p>即使master断开了与primary的通信，只需要等待timeout后重新分配primary即可</p><h4 id="GFS写方法"><a href="#GFS写方法" class="headerlink" title="GFS写方法"></a>GFS写方法</h4><img src="/../../images/gfs_write.png" width=500px /><ol><li>client向master询问要写部分对应的chunk和chunkserver的信息，并知道其中哪个是primary</li><li>master返回chunk handle，chunkserver，primary chunkserver。client将信息缓存在本地。只有缓存信息过期才会去询问master</li><li>client将信息传给所有拥有副本的chunkserver</li><li>client发写指令给primary</li><li>primary以自己规定的顺序写，secondary和primary写的顺序保持一致</li><li>secondary写完后将信息同步给primary</li><li>primary告知client已写完或某步失败</li></ol><p>对于第一步，master可能不知道谁是primary，它会把version和所有拥有副本的chunkserver比较，过段时间后（使前一个lease过期，防止同时出现两个primary），取最新的version作为primary。master维护的version可能也不是最新的，如果落后也会更新到最新版本</p><h4 id="GFS的局限"><a href="#GFS的局限" class="headerlink" title="GFS的局限"></a>GFS的局限</h4><p>GFS 是<strong>宽松的一致性模型</strong>(relaxed consistency model)，可以理解是弱一致性的，它并<strong>不保证一个 chunk 的所有副本是相同的</strong></p><p><strong>GFS 最严重的局限性就在于它只有一个 master 节点</strong>(这篇文章讨论了这个问题：<a href="https://queue.acm.org/detail.cfm?id=1594206)%EF%BC%8C">https://queue.acm.org/detail.cfm?id=1594206)，</a> 单个 master 会带来以下问题：</p><ul><li>随着 GFS 的应用越来越多，文件也越来越多，最后 master 会耗尽内存来存储 metadata；你可以增加内存，但单台计算机的内存始终有上限；</li><li>master 节点要承载数千个 client 的请求，master 节点的 CPU 每秒只能处理数百个请求，尤其是还要将部分数据写入磁盘——client 的数量会超过单个 master 的能力；</li><li>弱一致性会导致应用程序很难处理 GFS 奇怪的语义；</li><li>最后一个问题，master 的故障切换不是自动的，需要人工干预来处理已经永久故障的 master 节点，并更换新的服务器，这需要几十分钟甚至更长的时间来处理。对于某些应用程序来说，这个时间太长了。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 论文导读 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“开卷”何必“有益”</title>
      <link href="/2025/01/03/%E5%BC%80%E5%8D%B7%E4%BD%95%E5%BF%85%E6%9C%89%E7%9B%8A/"/>
      <url>/2025/01/03/%E5%BC%80%E5%8D%B7%E4%BD%95%E5%BF%85%E6%9C%89%E7%9B%8A/</url>
      
        <content type="html"><![CDATA[<p>记得小学阅读课上，我在读一本悬疑小说并写到了读后感作业中，结果第二天就被老师批评，并以“开卷有益”这个成语来教导我说，你这种书以后少读读。当时，我就觉得老师这种说法一定是错的，但限于那时的表达能力和逻辑能力并不能给出完整的反驳，现写下此文以表述自己的想法。<br>“以后少读读”这句话一直在我脑海中，我不理解曾几何时，书之间也有了贵贱之分，难道读四大名著的就是好学生，读《福尔摩斯》的就是差学生吗？“开卷有益”指的是读书总有好处，并非告诉我们先对于书是否有益有了定性之后再去读。老师说的这些话显然是没有道理的。<br>那她又是出于什么原因这样说呢？说到底，四个字，功利主义。什么书对于学习有帮助那就是有益的，没帮助就是浪费时间。我们中的很多人从小被灌输这样一个观念：只有努力学习才能上好大学，只有上好大学才能找到好工作，才能有幸福的生活。曾经我也认为这句话是对的，为了以后能开心地生活现在必须努力学习。但真的是这样吗？从学校到工作到生话并非完全是后者依赖前者的先序关系，其中某一环节的丢失并不一定能影响到之后的生活。这种观点只是指出人生中几个重要结点，并对每一个结点提出要求。上了好大学能就能仕途一帆风顺，有了好工作真能天天开开心心享受生活？不尽然。<br>    前段时间，“鸡娃”一度成为社会热点问题，家长给孩子报了各种补课班，兴趣班，以求孩子能领先他人一步。我想，他们也许都是上文观点的拥趸，生怕自己孩子因为没补课而落后其他同学。其实，我小时候也是个“鸡娃”，从幼儿园开始补课直到高中毕业，周末只是换了个地方上课。现在看来，报那么多班其实未必有用，现在的我也只是刚从普通大学毕业，过着平淡的生话。每个人学习能力不同，那假设补课班是有用的，能让所有上课的孩子成绩提升，考上好大学，但那之后呢，补课班除了能培养出优秀的做题家外并不会给孩子带来什么。<br>    好大学并不是人生的终点，拥有幸福快乐的人生也不是名校生的特权，否则怎么会有某大学投毒案，某大学弑母案呢？这一切的一切都是功利主义在作祟，他们认为人生只需要为那几个重要结点去准备就行了，达到目的则视为成功，在他们的眼中，世界是线性的，必须要完成一个个小目标，追求利益最大化，否则就是失败。但他们不知道的是人生并不是一蹴而就的，阶段性的成功并不意味着什么。事物之间也在不断变化发展，幸福的人生并不是公式化的结果，在这之中更重要的是我们对为人处世的态度，以及对于个人，社会，以及世界的看法，这会贯穿人的一生，而非学校，工作等短暂的光环。<br>冯友兰先生将人生分为四种境界：自然镜界，功利境界，道德境界和天地境界。你我皆为凡人，虽难以达到“敬天爱人，天人合一”，但也不应在功利境界一直徘徊，为了眼前的利益患得患失。“开卷”何必“有益”，看自己想看的书，做自己想做的事，何必要按照公式走完自己的人生呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（三）指针</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-C-基础——指针"><a href="#第二章-C-基础——指针" class="headerlink" title="第二章 C++基础——指针"></a>第二章 C++基础——指针</h2><p>指针是一个变量，其存储的是值的地址，而不是值本身</p><p>使用常规变量时，值是指定的量，而地址是派生量，而指针相反</p><p><strong>OOP</strong>强调的是在运行阶段（而不是编译阶段）进行决策，提供了灵活性，对于内存管理也更加高效</p><h3 id="初始化指针"><a href="#初始化指针" class="headerlink" title="初始化指针"></a>初始化指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr_a;</span><br><span class="line"><span class="type">double</span>* ptr_b;</span><br></pre></td></tr></table></figure><p>初始化时必须指定所指元素类型，因为对所有指针来说其都是代表一个初始地址，但从该初始地址读多少字节则由指针类型判断</p><p>指针也是作为变量存储，只不过其内存空间存的是地址。指针p1,p2有各自的地址&amp;p1,&amp;p2。长度为4B（32位）或8B（64位）。p1,p2表示存储的所指向元素的地址。*p1表示指向元素的值。<br><img src="/../../images/1.png" alt="image.png" style="zoom:30%;" /></p><h3 id="指针注意事项"><a href="#指针注意事项" class="headerlink" title="指针注意事项"></a>指针注意事项</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存（指向不确定）。另外，<strong>一定要在对指针提取（*）之前，将指针初始化为一个确定的、适当的地址。</strong></p><p>一个未指向任何对象的指针，其地址值为0。有时称之为<code>null指针</code>。任何指针都可以被初始化或令其值为0。</p><p>指针不是整型，虽然计算机通常把地址当作整数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pt;</span><br><span class="line">pt = <span class="number">0xB80000000</span>; <span class="comment">//invalid, type mismatch</span></span><br><span class="line">pt = (<span class="type">int</span>*)<span class="number">0xB80000000</span>; <span class="comment">//valid, type match</span></span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>可以修改指针的值，但数组名是常量不能修改</p><p>指针变量加1后，其增加的值等于指向的类型占用的字节数</p><p>将一个指针减去另一个指针，获得两个指针的差（必须类型相同，差为地址实际差&#x2F;变量类型长度），仅在都指向同一数组时有意义</p><p>对数组应用sizeof得到的是数组的长度，而对指针应用sizeof得到的是指针的长度</p><h4 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h4><p>  tell和&amp;tell数值相同，但tell指向数组第一个元素，tell+1将地址值加2。&amp;tell指向整个数组，&amp;tell+1将地址值加2*10&#x3D;20</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> tell[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt; tell &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; &amp;tell &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>  数组指针指向整个数组，初始化为</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">short</span> (*pas)[<span class="number">10</span>] = &amp;tell;</span><br></pre></td></tr></table></figure><p>  指针数组为多个指针变量组成的数组，初始化为</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> *pas[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="自由存储空间"><a href="#自由存储空间" class="headerlink" title="自由存储空间"></a>自由存储空间</h3><h4 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeName * pointer_name = new typeName</span></span><br><span class="line"><span class="type">int</span>* pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```typeName*```指声明什么类型的指针，左右两侧的类型必须相同，否则因为读取的块大小不同而访问错误</span><br><span class="line"></span><br><span class="line">**变量存储在栈（stack）的内存区域中，new从堆（heap）或自由存储（free store）的内存区域分配内存**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用delete释放内存</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">int* ps = new int;</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure><p>这将删除<em>ps</em>所指向的内存，但不会删除<em>ps</em>本身，ps还可指向其他内存空间</p><p>需要注意的是：</p><ul><li>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存</li><li>不要使用<code>delete</code>释放同一个内存两次</li><li>对空指针(<em>null pointer</em>)使用<code>delete</code>是安全的</li></ul><h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] psome;</span><br></pre></td></tr></table></figure><p>数组直接通过<code>psome[num]</code>访问</p><p>需要注意的是：</p><ul><li>如果使用<code>new [] </code>为数组分配内存，则需要通过<code>delete []</code>来释放</li><li>如果使用<code>new</code>为一个实体分配内存，则应使用<code>delete</code>来释放</li></ul><h3 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h3><p>对于复杂表达式应从右往左读</p><p><code>int *&amp;r = p</code></p><p>表示r首先是对p的引用，其次r是一个int*型的引用</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p> 定义时必须初始化</p><p>不能改变绑定的指向（内部通过顶层const实现，type * const p）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//(pointer to b) equal to (pointer to a)</span></span><br></pre></td></tr></table></figure><p>引用间不能赋值</p><p>没有引用的引用，没有指针的引用，可以有引用的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;* p; <span class="comment">//illegal</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp; p)</span></span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（二）基本数据类型</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><h4 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h4><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li>当一个算术表达式中既有无符号数又有<code>int</code>值时，int会被转换为无符号数</li><li>当从无符号数中减去一个值时，不管这个值是不是无符号数，都必须保证结果不为负（否则为取模后值）</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量声明于定义的关系"><a href="#变量声明于定义的关系" class="headerlink" title="变量声明于定义的关系"></a>变量声明于定义的关系</h4><p>变量<strong>声明（declaration）</strong>定义了变量的类型和名字，<strong>定义（definition）</strong>在声明外还申请存储空间</p><p>如果只想声明，可在变量名前添加关键字<code>extern</code></p><p>变量只能被定义一次，但是可以多次声明</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（四）const限定符</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>const对象一经创建后其值不能再改变，所以const对象必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，const对象仅在文件内有效。若需在不同文件使用同一const对象，则const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>用于声明引用的const都是底层const，引用本身已默认为顶层const（无法改变指向）</p><p>const型变量只能由const型引用（底层const）</p><p>不能把普通引用绑定到字面值上，需用底层const</p><p>非const型变量可以由const型引用，但不可通过引用修改被引用变量值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">1</span>; <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><h3 id="指针和常量"><a href="#指针和常量" class="headerlink" title="指针和常量"></a>指针和常量</h3><p>若变量为const，则它的指针或引用必为const</p><p>要想存放常量对象的地址，只能使用指向常量的指针（底层const）</p><p>指向常量的指针（pointer to const）不能通过指针改变常量值 —— 底层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i; <span class="comment">// eqal to (int const *p =&amp;i;)</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><p>常量指针（const pointer）必须初始化，而且初始化完成后，其指向的地址不能再改变 —— 顶层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;i;</span><br><span class="line">p = &amp;j;<span class="comment">//invalid</span></span><br></pre></td></tr></table></figure><p>指向常量的常量指针（const pointer to const），包含上述两种特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = &amp;i;</span><br></pre></td></tr></table></figure><p>类和const</p><p>函数后加const表示不修改任何成员变量（通过const *this实现 ）</p><p>如果类包含const变量，必须通过初始化列表初始化</p><h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><p>当执行对象的拷贝操作时，顶层const不受影响</p><p>底层const要求拷入和拷出的对象必须具有相同的底层const资格，或者两个对象能相互转换。非常量可以转化为常量（等号右侧表达式），反之不行</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（六）异常处理</title>
      <link href="/2025/01/03/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2025/01/03/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当执行throw时，throw后的语句都不执行，控制权转移到与之对应的catch模块</p><p>退出catch后，catch模块中的局部变量将会销毁</p><p>当异常处理完毕后，异常对象将被销毁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="built_in">catch</span> (exception_a)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="built_in">catch</span> (exception_b)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕捉catch（对于每个catch执行下述步骤）"><a href="#捕捉catch（对于每个catch执行下述步骤）" class="headerlink" title="捕捉catch（对于每个catch执行下述步骤）"></a>捕捉catch（对于每个catch执行下述步骤）</h3><ol><li>判断是否是精确匹配</li><li>派生类向基类转换（仅引用和指针类型）</li><li>（…）匹配所有</li></ol><p>其中一个被捕捉，跳过下面的catch</p><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>一条catch语句通过重新抛出的稻作将异常传递给另一个catch语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>new申请内存失败返回bad_alloc异常，不是返回0</p><p>处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（五）static关键字</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h3><p>static变量只能在当前文件访问，其他文件不能通过extern访问</p><h3 id="static局部变量"><a href="#static局部变量" class="headerlink" title="static局部变量"></a>static局部变量</h3><p>定义时创建，程序结束时销毁，修改了生命周期，作用域不变</p><h3 id="static类"><a href="#static类" class="headerlink" title="static类"></a>static类</h3><p>static对象的构造在main函数前执行，析构在main函数结束后</p><h3 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h3><p>存在于所有对象且保持一致，可在其他文件访问</p><p>不能在初始化列表初始化</p><p>需在类外定义，因为class内语句都是声明</p><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><p>可通过类名::函数调用，只能使用static成员变量，否则报错，没有this指针，不能访问非static成员 变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发面试题整理</title>
      <link href="/2025/01/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2025/01/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题汇总"><a href="#面试题汇总" class="headerlink" title="面试题汇总"></a>面试题汇总</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><strong>C 和 CPP 区别是什么</strong></p><table><thead><tr><th></th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>编程范式</td><td>面向过程</td><td>面向对象</td></tr><tr><td>函数重载</td><td>无</td><td>有</td></tr><tr><td>引用</td><td>无</td><td>有</td></tr></tbody></table><p><strong>C++编译过程</strong></p><p>预处理：展开include和define</p><p>编译：转化为汇编代码</p><p>汇编：转化为二进制机器码</p><p>链接：将目标和其需要的库链接成可执行文件</p><p><strong>指针和引用的区别</strong></p><table><thead><tr><th></th><th>指针</th><th>引用</th></tr></thead><tbody><tr><td>内存空间</td><td>占用</td><td>不占用</td></tr><tr><td>是否可为空</td><td>可以</td><td>不可以，必须只指向存在的变量</td></tr><tr><td>修改指向</td><td>可以</td><td>不可以</td></tr></tbody></table><p>其实<strong>引用在编译时作为const指针处理</strong></p><p><strong>C++ 内存分布</strong></p><img src="/../../images/memoryLayoutC.jpg" width=500px /><p><strong>sizeof数组是多少，指针是多少</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; endl;           <span class="comment">// 0x16fb9b28c</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;            <span class="comment">// 0x16fb9b28c</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;    <span class="comment">// 12 = 3 * 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a[<span class="number">1</span>]) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(&amp;a) &lt;&lt; endl;   <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">test</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组名和指针的区别</strong></p><p>对于数组名和指针是两个概念，但是对于<code>a[3]</code>来说a和&amp;a的地址是一样的，数组名a代表的是整个数组，当dereference如<code>a[1]</code>时，数组名转化为指向首元素的指针，得出的值为<code>*(a+1*sizeof(int))</code>，另外在做右值时a也会转化为指向首元素的指针（<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer">参考</a>）</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p><strong>继承方法</strong></p><p><strong>C++ 重载和重写的区别</strong></p><p>重载（Overloading）：重载是指在同一个作用域内，对一个函数或者运算符进行多次定义，每个定义有不同的参数列表或参数类型。通过重载，我们可以在同一个作用域内使用相同的函数名或运算符符号来执行不同的操作。</p><p>重写（Overriding）：重写是指在派生类中重新定义基类中已经存在的虚函数。重写后的函数与基类中的函数具有相同的函数名和参数列表，但是在派生类中的实现可以不同于基类中的实现。重写允许派生类覆盖基类的实现，以实现多态性。</p><p><strong>多态的概念</strong></p><p>不同的对象对于同一消息作出不同的响应。子类在继承父类后可以设计自己的版本，在运行时动态选择调用哪个版本实现</p><p><strong>静态绑定和动态绑定</strong></p><p>在面向对象编程中，静态绑定和动态绑定是两种不同的函数调用机制。</p><p><strong>静态绑定（Static Binding）</strong>，也称为早期绑定或编译期绑定，是指<strong>在程序编译时就将函数调用与函数实现绑定起来，而不考虑对象的实际类型</strong>。这种绑定是通过函数的名称和参数列表来实现的。在静态绑定中，编译器会<strong>在编译期间确定调用哪个函数</strong>，而不是在运行时确定。静态绑定通常适用于非虚函数的调用，因为非虚函数的调用是在编译期间就可以确定的。</p><p><strong>动态绑定（Dynamic Binding）</strong>，也称为晚期绑定或运行时绑定，是指<strong>在程序运行时根据对象的实际类型来决定调用哪个函数</strong>。这种绑定是通过虚函数来实现的。在动态绑定中，编译器会在运行时确定调用哪个函数，而不是在编译期间确定。动态绑定适用于需要实现多态性的情况，可以<strong>让基类指针或引用调用派生类中的函数实现，实现运行时多态性</strong>。</p><p><strong>虚函数</strong></p><p><strong>作用</strong></p><ul><li><p>实现动态多态性（Runtime Polymorphism）：通过使用虚函数，可以在运行时动态地确定调用的是基类函数还是派生类函数，实现多态性。例如，如果我们有一个指向基类对象的指针，我们可以使用虚函数来调用派生类中的适当函数。</p></li><li><p>支持运行时类型识别（RTTI）：通过使用虚函数和类型信息（type information），可以在运行时确定对象的实际类型，从而实现更加灵活的代码设计。</p></li><li><p>简化代码维护：使用虚函数可以将代码的实现细节从类的使用者中分离出来，使得修改基类的实现对派生类的影响最小。</p></li></ul><p><strong>实现</strong></p><p>类保存指向保存了所有虚函数指针的表（vtable）的指针（vptr），通过基类指针调用虚函数时访问vtable选择特定的函数指针调用</p><p><strong>类中有一个虚函数大小是多少</strong></p><p>为一个指针的大小</p><p><strong>C++ 的友元</strong></p><p>可以访问一个类的非公有成员的函数或类。作用是提高代码封装性，简化了一些实现</p><ul><li>友元函数：该函数可以访问该类的私有成员和保护成员</li><li>友元类：该类可以访问该类的私有成员和保护成员</li><li>友元成员函数：该成员函数的私有成员和保护成员</li></ul><p><strong>空类包括什么成员</strong></p><p>不包含任何成员，只是sizeof时为1，应为C++中每个对象大小必须大于0</p><p><strong>悬空指针所指向的内存被释放了，那么这个指针还存在吗</strong></p><p>存在，只是释放了指向的内容</p><p><strong>浅拷贝和深拷贝有什么区别</strong> </p><p>浅拷贝为字节流的拷贝，对于指针来说，通过浅拷贝会使新对象和旧对象指向同一块内存（类默认的拷贝构造和拷贝赋值）</p><p>深拷贝在复制时为指针分配新的内存，新对象和旧对象有各自独立的空间</p><p><strong>一个类的大小由什么决定</strong></p><p>成员变量的个数，是否继承，是否有虚函数等，有虚函数的话，那么类就会多一个虚表指针，类的大小就会多8字节</p><p><strong>一个子类继承空基类，对子类的大小会有影响吗 (空白基优化)</strong></p><p>不会，基类大小的1优化成0</p><h5 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h5><p><strong>左值和右值引用</strong></p><p>左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong></p><p>使用<code>std::move()</code>可以将左值转化为右值，其在调用右值的拷贝时为浅拷贝，性能较深拷贝强。但作为右值被使用后，这个变量不应该再使用</p><p><strong>悬空指针和野指针的区别</strong></p><p>悬空指针为指针最初指向的内容已经被释放的指针</p><p>野指针是没初始化的指针</p><p><strong>智能指针，循环引用会怎么样</strong></p><p>内存泄漏</p><p>可以这样避免</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;B&gt; p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  weak_ptr&lt;A&gt; p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sharedptr 和weakptr使用场景</strong></p><ul><li><code>unique_ptr</code><br>只允许基础指针的一个所有者</li><li><code>shared_ptr</code><br>采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 <code>shared_ptr</code> 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块</li><li><code>weak_ptr</code><br>结合 <code>shared_ptr</code> 使用的特例智能指针。 <code>weak_ptr</code> 提供对一个或多个 <code>shared_ptr</code> 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 <code>shared_ptr</code> 实例间的循环引用。</li></ul><p><strong>在A函数里用指针申请好空间后，这块空间需要返回给B函数，然后B函数使用后不再使用这块内存，虽然我们可以手动释放，但往往可能忘记释放，请问用什么方式解决？（智能指针解决）</strong></p><p>A为shared pointer，B为A的weak pointer</p><p><strong>智能指针的局限</strong></p><p>智能指针<strong>不能用于指向栈上的对象或静态变量</strong>，因为这些对象的生命周期是<strong>由编译器控制的</strong>，不需要手动管理内存。<br>智能指针可能会<strong>对性能产生一定的开销</strong>，因为它们需要维护引用计数、析构器等信息</p><h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><p><strong>map和set插入删除有啥区别</strong></p><p><strong>说一下迭代器失效的情况，以及解决方法</strong></p><p>在C++ STL中，迭代器是一种指向容器中元素的对象，它提供了访问容器元素的能力，从而使得程序员可以对容器中的元素进行遍历、修改等操作。然而，在某些情况下，迭代器可能会失效，即不能继续使用。以下是一些常见的导致迭代器失效的情况：</p><ol><li>容器大小发生改变</li></ol><p>在使用迭代器遍历容器的过程中，如果容器的大小发生改变（如插入或删除元素），则迭代器可能会失效。此时，继续使用失效的迭代器会导致程序崩溃或产生不可预期的结果。</p><ol start="2"><li>插入元素导致内存重新分配</li></ol><p>对于一些容器（如vector、deque），在容器中插入元素时，可能会导致容器重新分配内存。如果此时使用了失效的迭代器，则可能会指向一个已被释放的内存地址，进而导致程序崩溃或产生不可预期的结果。</p><ol start="3"><li>删除元素导致迭代器失效</li></ol><p>在使用迭代器遍历容器的过程中，如果删除了容器中的元素，则可能导致迭代器失效。例如，对于vector容器，当使用erase()方法删除元素时，该元素之后的所有迭代器都会失效，因为它们指向的元素已经被删除。</p><p>为了避免迭代器失效，可以采取以下方法：</p><ol><li>使用迭代器前先进行检查</li></ol><p>在使用迭代器前，可以先检查容器中的元素是否发生了改变，从而避免使用失效的迭代器。例如，可以在循环遍历容器的时候，在每次循环前检查容器大小是否发生改变。</p><ol start="2"><li>使用智能指针或引用</li></ol><p>智能指针或引用是一种安全的访问容器中元素的方式，因为它们不会失效。在使用迭代器时，可以将它们转换为智能指针或引用，从而避免迭代器失效。</p><ol start="3"><li>使用成员函数返回值</li></ol><p>对于某些容器（如vector、deque），它们的成员函数返回值本身就是迭代器，而且使用这些函数返回的迭代器不会失效。例如，使用vector的begin()和end()方法返回的迭代器可以安全地用于遍历容器，即使在容器中插入或删除元素时也不会失效。</p><p><strong>函数返回引用类型和普通类型有什么区别</strong></p><p>函数返回引用类型和普通类型的最大区别在于，返回引用类型的函数可以返回一个左值，而返回普通类型的函数只能返回一个右值。</p><p>当一个函数返回引用类型时，返回值实际上是对一个对象的引用。如果这个对象是一个变量，那么这个函数返回的就是这个变量的引用，也就是一个左值。在这种情况下，返回值可以被用作左值进行赋值或修改。</p><p><strong>如果设计一个string类，头文件应该怎样设计？写头文件就行了。列举出需要哪些函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_STRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_STRING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_string</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="built_in">my_string</span>();</span><br><span class="line">  <span class="built_in">my_string</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">  <span class="built_in">my_string</span>(<span class="type">const</span> my_string&amp; other);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">my_string</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值运算符</span></span><br><span class="line">  my_string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> my_string&amp; other);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下标运算符</span></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串拼接运算符</span></span><br><span class="line">  my_string <span class="keyword">operator</span>+(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串比较运算符</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="built_in">operator</span>&lt;=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> my_string&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串长度函数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串查找函数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> my_string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串截取函数</span></span><br><span class="line">  <span class="function">my_string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* data_; <span class="comment">// 存储字符串的动态数组</span></span><br><span class="line">  <span class="type">size_t</span> size_; <span class="comment">// 字符串的长度</span></span><br><span class="line">  <span class="type">size_t</span> capacity_; <span class="comment">// 存储字符串的动态数组的容量</span></span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> npos = <span class="number">-1</span>; <span class="comment">// 无效位置的标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_STRING_H</span></span></span><br></pre></td></tr></table></figure><p>可以增加右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">my_string::<span class="built_in">my_string</span>(my_string&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">size_</span>(other.size_), <span class="built_in">capacity_</span>(other.capacity_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">    <span class="comment">// 将原对象置为空</span></span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">    other.capacity_ = <span class="number">0</span>;</span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_string&amp; my_string::<span class="keyword">operator</span>=(my_string&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="comment">// 释放当前对象的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原对象的资源转移给当前对象</span></span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原对象置为空</span></span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.capacity_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector是什么？vector的底层实现？vector的扩容机制？</strong> </p><p><strong>deque是什么？deque的底层实现？怎么实现O(1)头插？</strong> </p><p><strong>map有几类？底层实现是什么？红黑树是什么？平衡树怎么实现平衡？</strong> </p><p><strong>set和map的区别？</strong></p><p><strong>set和map的理解及使用场景</strong></p><p><strong>map和unordered_map的结构及使用场景</strong></p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p><strong>内核态和用户态区别</strong></p><p>操作系统中内核态和用户态是两种运行模式，区别如下：</p><ol><li><strong>权限不同</strong>：内核态具有更高的权限，可以执行所有的指令，包括访问系统资源、执行特权指令等，而用户态则只能执行受限的指令，不能直接访问系统资源。</li><li><strong>执行环境不同</strong>：内核态运行在操作系统内核的上下文中，而用户态则运行在用户程序的上下文中。</li><li><strong>系统调用</strong>：用户态程序如果需要访问系统资源或执行特权指令，需要通过系统调用的方式切换到内核态，由内核代表用户程序执行相应的操作。</li><li><strong>中断处理</strong>：当硬件设备发生中断时，操作系统会切换到内核态进行中断处理，以保证系统正常运行。</li></ol><p><strong>线程间的同步方式</strong></p><ol><li><strong>互斥锁（Mutex）</strong>：使用互斥锁可以保证同一时间只有一个线程可以访问共享资源。当一个线程获得互斥锁后，其他线程需要等待该线程释放锁后才能再次尝试获取锁。</li><li><strong>信号量（Semaphore）</strong>：信号量是一个计数器，用于控制同时访问某个共享资源的线程数量。当某个线程需要访问共享资源时，它必须先获取信号量。如果当前信号量计数为0，则线程需要等待，直到有其他线程释放信号量。</li><li><strong>条件变量（Condition Variable）</strong>：条件变量用于线程间的通信和同步，当一个线程需要等待某个条件满足时，可以使用条件变量来阻塞自己，等待其他线程发出通知。当条件满足时，其他线程可以发出信号通知等待的线程继续执行。</li><li><strong>屏障（Barrier）</strong>：屏障用于控制多个线程在某个点上同步。当所有线程都到达这个点时，才能继续执行后面的代码。这种同步方式通常用于多个线程执行完某个任务后需要进行汇总的场景。</li><li><strong>读写锁（Read-Write Lock）</strong>：读写锁用于在多线程环境下对共享资源进行读写操作的同步。读写锁分为读锁和写锁两种，多个线程可以同时获得读锁，但只能有一个线程获得写锁。这样可以在保证数据一致性的前提下提高并发性能。</li></ol><p><strong>进程间的通信方式</strong></p><ol><li><strong>管道（Pipe）</strong>：管道是一种半双工的IPC机制，可以在两个进程之间传递数据。管道分为无名管道和命名管道两种，<strong>无名管道只能在具有亲缘关系的进程之间使用，而命名管道可以在不同进程之间使用</strong>。<strong>缺点：在没有读数据前不可以写数据</strong></li><li><strong>消息队列（Message Queue）</strong>：消息队列是一种基于队列的IPC机制，多个进程可以通过发送和接收消息来进行通信。消息队列具有一定的<strong>缓存能力</strong>，可以在进程之间传递不同大小的数据块。<strong>缺点：每个消息大小固定，队列大小受限，并且需要把消息从用户态拷贝到内核态</strong></li><li><strong>共享内存（Shared Memory）</strong>：共享内存是一种快速且高效的IPC机制，多个进程可以访问同一块物理内存，从而实现数据共享。共享内存需要使用信号量等同步机制来保证数据的一致性。</li><li><strong>信号（Signal）</strong>：信号是一种异步通信机制，可以用于向进程发送通知。当一个进程接收到信号时，会执行相应的信号处理函数。常见的<strong>信号包括中断信号和软件信号等</strong>。</li><li><strong>套接字（Socket）</strong>：套接字是一种通用的IPC机制，可以在不同的进程之间传递数据。套接字通常用于网络编程中，可以实现不同计算机之间的进程通信。</li></ol><p><strong>线程安全要加锁，什么情况可以不加锁?</strong></p><p>线程安全是指在多线程环境下，对共享数据的访问操作不会出现冲突或竞争，从而保证程序的正确性和可靠性。为了实现线程安全，通常需要对共享数据的访问加锁。</p><p>然而，并非所有情况都需要对共享数据加锁，以下是一些情况：</p><p>1**.只读访问**：如果一个共享数据只会被读取而不会被修改，那么在多个线程同时访问时就不需要加锁。因为只读操作不会改变数据的值，所以多个线程同时读取同一个数据也不会出现冲突。</p><p>2.<strong>线程本地存储</strong>：有些数据只需要在一个线程内部使用，不需要在多个线程之间共享，那么就不需要对这些数据加锁。例如，每个线程都有一个独立的栈空间，线程内部的栈空间就是线程本地存储，不需要对其加锁。</p><p>3.<strong>不变对象</strong>：如果一个对象在创建后就不再被修改，那么多个线程同时访问它也不需要加锁。因为对象不会被修改，所以多个线程同时访问同一个对象也不会出现冲突。</p><p>需要注意的是，虽然上述情况下不需要加锁，但仍然需要保证数据的可见性。为了保证数据的可见性，可以使用volatile关键字或者synchronized块来同步内存中的数据</p><p><strong>死锁（怎么预防）</strong></p><p>破坏“请求与保持”：一次性申请进程所需的所有资源</p><p>破坏“循环等待”：资源按顺序申请（其实达不到，没法预测程序走的分支）</p><p><strong>死锁避免（拒绝某些资源请求）</strong></p><p>每次申请资源都要判断是否出现死锁的危险，如果有危险就拒绝这次请求</p><p>通过<strong>银行家算法</strong>计算安全序列，充分性算法，<strong>完全避免死锁</strong></p><p>算法优先分配给能满足进程所需最大资源量的进程，一次分配所有所需要的所有资源</p><p><strong>死锁检测&#x2F;恢复（排查因资源导致的阻塞进程）</strong></p><p>检测发生死锁的进程（资源未被使用，进程长时间未调度等），恢复进程并重新分配资源（<strong>改进的银行家算法</strong>）</p><p>改进的银行家算法分配每次进程请求的资源，而不是分配所需的所有资源，因为有事进程对于资源使用后就会释放，这样系统有更多余量</p><p><strong>虚拟内存和物理内存的关系</strong></p><p>虚拟内存将<strong>硬盘上的一部分空间映射到了物理内存中</strong>，通过<strong>地址映射</strong>实现虚拟内存和物理内存的交互。当应用程序需要访问某个地址时，操作系统<strong>先检查该地址是否在物理内存</strong>中，如果不在物理内存中，则从虚拟内存中将该地址所对应的数据读取到物理内存中。当物理内存中的空间不足时，操作系统会将一些较少使用的数据换出到硬盘上，以释放物理内存空间供其他程序使用。</p><p><strong>在4G物理内存机器上申请8G内存</strong></p><p>在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</p><p>在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题（申请只是分配虚拟内存，只有访问时才会调用缺页中断分配物理内存），因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：</p><ul><li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li><li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li></ul><p><strong>函数调用对内存的使用</strong></p><ol><li>所需参数压栈</li><li>返回地址压栈</li><li>被调用函数局部变量压栈</li><li>被调用函数局部变量出栈</li><li>返回地址出栈</li><li>所需参数出栈</li></ol><p>实际1，2不同的编译器和语言有差异，另外参数也可以通过寄存器传</p><p><strong>从磁盘预读的数据可能最后没有用到，有什么改善方法（预读污染）；批量读数据时可能会把热点数据挤出，有什么改善方法（缓存污染）</strong></p><p>传统的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效导致缓存命中率下降；</li><li>缓存污染导致缓存命中率下降；</li></ul><p>为了避免「预读失效」造成的影响，Linux 和 MySQL 对传统的 LRU 链表做了改进：</p><ul><li>Linux 操作系统实现两个了 LRU 链表：<strong>活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）</strong>。</li><li>MySQL Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：<strong>young 区域 和 old 区域</strong>。</li></ul><p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么<strong>还存在缓存污染的问题</strong>。</p><p>为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：</p><ul><li><p>Linux 操作系统：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</p></li><li><p>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行</p><p>停留在 old 区域的时间判断</p><ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p><strong>五大 IO 模型</strong></p><ol><li>阻塞 I&#x2F;O (Blocking I&#x2F;O)</li></ol><p>在阻塞 I&#x2F;O 中，当用户线程发起一个 I&#x2F;O 操作时，线程会一直阻塞等待，直到内核完成 I&#x2F;O 操作并将结果返回给用户线程。这种模型非常简单易懂，但是效率很低，因为当一个线程阻塞等待 I&#x2F;O 完成时，CPU 时间无法充分利用，这会导致程序的性能受到严重影响。</p><ol start="2"><li>非阻塞 I&#x2F;O (Non-blocking I&#x2F;O)</li></ol><p>在非阻塞 I&#x2F;O 中，用户线程发起一个 I&#x2F;O 操作后并不会阻塞，而是立即返回，然后线程不断地轮询该操作是否完成。这种模型比阻塞 I&#x2F;O 的效率高，但是也会导致 CPU 占用率过高，因为线程需要不断地轮询操作状态，浪费了大量的 CPU 资源。</p><ol start="3"><li>I&#x2F;O 多路复用 (I&#x2F;O Multiplexing)</li></ol><p>I&#x2F;O 多路复用可以监视多个文件描述符（sockets、标准输入输出、套接字等等）的可读可写等状态，当任何一个文件描述符就绪（可读或可写）时，就能够通知相应的线程进行读写操作。这种模型使用 select、poll、epoll 等多路复用技术，可以有效地避免线程阻塞等待 I&#x2F;O 完成的问题，提高程序的并发处理能力。</p><ol start="4"><li>信号驱动 I&#x2F;O (Signal-driven I&#x2F;O)</li></ol><p>信号驱动 I&#x2F;O 使用信号机制通知用户线程 I&#x2F;O 操作已经完成。在这种模型中，当用户线程发起 I&#x2F;O 操作后，内核会立即返回并允许线程继续执行其他任务。当 I&#x2F;O 操作完成后，内核会向用户线程发送一个信号来通知操作已经完成，然后线程可以调用相应的系统调用来读取数据。信号驱动 I&#x2F;O 可以避免线程阻塞等待 I&#x2F;O 完成的问题，但是也会导致一些其他问题，例如信号可能会被其他程序捕获，使得程序难以控制。</p><ol start="5"><li>异步 I&#x2F;O (Asynchronous I&#x2F;O)</li></ol><p>异步 I&#x2F;O 中，用户线程发起 I&#x2F;O 操作后，内核会立即返回并允许线程继续执行其他任务。当 I&#x2F;O 操作完成后，内核会向用户线程发送一个通知来告诉它操作已经完成，然后线程可以调用相应的系统调用来读取数据。异步 I&#x2F;O 模型可以避免线程阻塞等待 I&#x2F;O 完成的问题，并且可以自动处理 I&#x2F;O 缓冲区的数据传输</p><table><thead><tr><th>IO 模型</th><th>第一阶段</th><th>第二阶段</th></tr></thead><tbody><tr><td>阻塞式IO</td><td>阻塞</td><td>阻塞</td></tr><tr><td>非阻塞式IO</td><td>非阻塞</td><td>阻塞</td></tr><tr><td>IO多路复用</td><td>阻塞（Select）</td><td>阻塞</td></tr><tr><td>信号驱动式IO</td><td>异步</td><td>阻塞</td></tr><tr><td>异步IO</td><td>异步</td><td>异步</td></tr></tbody></table><img src="/../../images/io_module.png" width=700px /><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p><strong>TCP 三次握手</strong></p><p>步骤为：</p><ol><li>client传给server自己的SYN c</li><li>server传给client自己的SYN s，对于server SYN的确认ACK c+1表示下个要接收的数据包序号</li><li>client传给server对于server SYN的确认ACK s+1</li></ol><p>为什么不是2次？</p><p><strong>防止历史连接的建立，造成资源浪费，而且无法可靠同步双方序号</strong></p><p>如果有一个历史连接到达server，对于两次连接server会立即分配资源，把ack c+1传给client，但是client比对下不是自己需要建立的连接，会拒绝请求，把RST发给server。相当于server白申请资源</p><p><strong>TCP与UDP区别</strong></p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>建立连接</td><td>有</td><td>无</td></tr><tr><td>流量控制</td><td>有</td><td>无</td></tr><tr><td>拥塞控制</td><td>有</td><td>无</td></tr><tr><td>有序</td><td>有</td><td>无</td></tr></tbody></table><p><strong>Tcp和Udp使用场景</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信</li></ul><p><strong>流量控制和拥塞控制</strong></p><p><strong>Get和Post</strong></p><table><thead><tr><th></th><th>Get</th><th>Post</th></tr></thead><tbody><tr><td>可被缓存</td><td>可以，浏览器或者server可以换讯</td><td>不可以</td></tr><tr><td>参数传递方式</td><td>url里</td><td>body里</td></tr><tr><td>应用场景</td><td>数据的请求，查询，搜索</td><td>提交数据，上传文件</td></tr><tr><td>请求大小</td><td>几KB到几百KB</td><td>理论上没限制</td></tr></tbody></table><p><strong>HTTP和HTTPS</strong></p><table><thead><tr><th></th><th>Http</th><th>Https</th></tr></thead><tbody><tr><td>安全性</td><td>明文传输</td><td>采用SSL&#x2F;TLS协议对数据加密</td></tr><tr><td>传输方式</td><td>TCP</td><td>SSL&#x2F;TLS</td></tr><tr><td>默认段口号</td><td>80</td><td>443</td></tr></tbody></table><p><strong>url解析</strong></p><ol><li>访问缓存，包括浏览器，操作系统缓存，hosts，本地域名服务器</li><li>通过本地域名服务器访问根DNS服务器获得对应顶级DNS服务器的地址</li><li>通过本地域名服务器访问顶级DNS服务器获得对应权威DNS服务器的地址</li><li>通过本地域名服务器访问权威DNS服务器获得ip</li><li>本地域名服务器将ip返回给主机</li></ol><p><strong>http1.1和http2</strong></p><p>HTTP&#x2F;1.1和HTTP&#x2F;2是两个不同的HTTP协议版本，下面是它们之间的一些主要差别：</p><ol><li><strong>多路复用</strong>：HTTP&#x2F;1.1协议使用串行化的方式在一个TCP连接上依次传输多个HTTP请求和响应，这样会产生一些性能瓶颈。而HTTP&#x2F;2协议则使用多路复用的方式，通过<strong>在同一个TCP连接上并行传输多个HTTP请求和响应</strong>，提高了性能和效率。</li><li><strong>头部压缩</strong>：HTTP&#x2F;1.1协议的请求和响应头部信息没有压缩，这样会占用较多的带宽和网络资源。而HTTP&#x2F;2协议引入了头部压缩机制，可以有效地减少网络传输的数据量，提高性能和效率。</li><li><strong>服务器推送</strong>：HTTP&#x2F;1.1协议需要客户端发起每个请求，服务器无法主动推送内容给客户端。而HTTP&#x2F;2协议允许服务器<strong>在客户端请求之前主动推送内容给客户端</strong>，可以减少客户端请求的次数和提高性能。</li><li><strong>流量控制</strong>：HTTP&#x2F;2协议引入了流量控制机制，可以对每个流进行流量控制，避免网络拥塞和资源竞争。而HTTP&#x2F;1.1协议没有流量控制机制，容易导致网络拥塞和性能瓶颈。</li><li><strong>请求优先级</strong>：HTTP&#x2F;2协议允许客户端设置请求的优先级，可以确保高优先级的请求优先得到响应，提高性能和效率。而HTTP&#x2F;1.1协议没有请求优先级机制，容易导致低优先级的请求得不到及时响应。</li></ol><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><strong>什么情况下建立索引</strong></p><ol><li>频繁使用的列：对于经常用于 WHERE 子句或 JOIN 子句中的列，可以考虑创建索引，以便更快地查询这些数据。</li><li>唯一性约束：对于需要唯一性约束的列，例如主键或唯一索引，需要创建索引来确保数据的唯一性。</li><li>外键约束：对于外键约束，也需要在相关的列上创建索引以提高查询性能。</li><li>多表连接：当进行多表连接时，可以在涉及到的列上创建索引，以提高查询性能。</li><li>经常使用的排序列：对于经常用于排序操作的列，可以创建索引，以提高排序的性能</li></ol><p><strong>MySQL 存储引擎有哪些</strong></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><strong>protobuf，它和 JSON 的区别是什么，为什么使用它</strong></p><ol><li>性能：由于 Protobuf 的大小和速度优势，它非常适合在网络上发送大量数据的情况。例如，如果您正在构建一个需要大量数据传输的分布式系统，那么 Protobuf 可能比 JSON 更好。</li><li>类型定义：Protobuf 的类型定义可以强制执行消息格式的正确性，这可以帮助您在发送和接收消息时避免错误。</li><li>兼容性：Protobuf 具有跨平台兼容性，并且提供了各种语言的支持库。因此，如果您正在构建一个需要跨多种编程语言进行通信的系统，那么 Protobuf 可能比 JSON 更好。</li><li>可扩展性：由于 Protobuf 可以定义任意数量的字段和消息类型，因此它非常适合在以后需要添加或更改消息格式的情况下使用。与 JSON 相比，Protobuf 更易于维护和扩展。</li></ol><p><strong>RPC 协议和 HTTP 协议的区别和特点</strong></p><p>RPC（Remote Procedure Call，远程过程调用）协议和 HTTP（Hypertext Transfer Protocol，超文本传输协议）协议是两种不同的网络通信协议，它们的区别和特点如下：</p><ol><li>通信方式</li></ol><p>RPC 协议和 HTTP 协议的通信方式不同。<strong>RPC 协议是基于函数调用的方式进行通信的</strong>，<strong>客户端通过调用远程服务端暴露的 API 接口</strong>，实现远程过程调用。<strong>HTTP 协议则是基于请求-响应的方式进行通信的</strong>，客户端通过向服务器发送 HTTP 请求，并接收服务器返回的 HTTP 响应来进行通信。</p><ol start="2"><li>传输协议</li></ol><p>RPC 协议和 HTTP 协议使用的传输协议也不同。<strong>RPC 协议通常使用二进制协议</strong>进行传输，如 Protobuf、Thrift 等，以提高传输效率和可靠性。而 <strong>HTTP 协议则通常使用文本协议进行传输</strong>，如 JSON、XML 等。在一些特殊情况下，也可以使用二进制协议，如 HTTP&#x2F;2 协议中的二进制帧。</p><ol start="3"><li>请求方式</li></ol><p>RPC 协议和 HTTP 协议的请求方式也不同。<strong>RPC 协议通常使用不同的 RPC 方法来表示不同的请求类型</strong>，如 gRPC 中使用的 RPC 方法名。而 <strong>HTTP 协议则使用不同的 HTTP 方法来表示不同的请求类型</strong>，如 GET、POST、PUT、DELETE 等。</p><ol start="4"><li>性能和效率</li></ol><p>RPC 协议和 HTTP 协议在性能和效率上也有一定的区别。由于 RPC 协议使用二进制协议进行传输，相对于 HTTP 协议使用文本协议进行传输，它<strong>在传输效率和带宽利用率上具有优势</strong>。同时，RPC 协议也<strong>更加灵活和高效</strong>，可以根据不同的应用场景进行优化。然而，HTTP 协议作为一种通用协议，在跨平台、跨语言、跨网络等方面具有优势。</p><ol start="5"><li>应用场景</li></ol><p>RPC 协议和 HTTP 协议适用于不同的应用场景。<strong>RPC 协议通常用于高性能、大规模分布式系统的通信</strong>，如微服务架构、数据中心内部通信等。而 <strong>HTTP 协议则更适用于 Web 应用和客户端-服务器模式的通信</strong>，如浏览器和服务器之间的通信、RESTful API 等。</p><p>总之，RPC 协议和 HTTP 协议都有各自的优点和局限性，在实际应用中需要根据具体的应用场景和需求来选择适合的协议。</p><p><strong>浏览器较少支持grpc对http2原语的较低级别的访问，需要通过grpc-web做代理</strong></p><p><strong>GRPC通信流程</strong></p><p>gRPC 通信流程一般包括以下几个步骤：</p><ol><li>编写 <code>.proto</code> 文件定义服务接口：首先需要使用 Protocol Buffers 定义接口和消息格式，将接口定义保存在 <code>.proto</code> 文件中。</li><li>生成客户端和服务端代码：使用 Protocol Buffers 编译器 <code>protoc</code> 将 <code>.proto</code> 文件编译为客户端和服务端所需要的代码。</li><li>启动服务端：服务端通过监听指定的端口，等待客户端的连接请求。</li><li>客户端发起调用请求：客户端使用生成的 SDK 中提供的 stub 函数调用服务端提供的方法，并将请求参数传递给服务端。</li><li>服务端处理请求并返回响应：服务端接收到客户端的请求后，根据请求参数执行对应的逻辑，并将处理结果封装为响应对象返回给客户端。</li><li>客户端接收响应并处理：客户端接收到服务端的响应后，根据响应参数执行对应的逻辑，完成一次 RPC 调用。</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p><strong>单例模式</strong></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>B树</p><p>DFS</p><p>BFS</p><p>每个stl的初始化方法</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p><strong>线性一致，强一致，最终一致</strong></p><p><strong>强一致性</strong>要求分布式系统中的每个节点都保持同步，任何时刻都能够读取到最新的数据，并且每个节点读取到的数据都是相同的。换句话说，强一致性下，分布式系统中的所有节点都能够看到同样的数据，而且所有节点的数据都是最新的。这种一致性模型是最常见的一种，也是很多应用程序最基本的需求。</p><p><strong>线性一致性</strong>是强一致性的一种特殊形式。它要求系统中的所有节点必须按照相同的顺序读取写入操作，而且这个顺序必须是全局有序的，也就是说，所有操作的顺序都是唯一确定的。这种模型通常用于需要有序的多节点事务，如交易系统等</p><p>假设有一个分布式系统，里面有三个节点：节点A、节点B、节点C。现在有一个操作需要在这三个节点上执行，并且需要保证强一致或线性一致。</p><p>在强一致性模型下，这个操作必须在所有节点上同时执行，并且执行结果必须相同。例如，如果这个操作是将某个数据从0改成1，那么在所有节点上执行结束之后，这个数据必须在所有节点上都是1，否则操作失败。</p><p>在线性一致性模型下，这个操作可以在任意一个节点上执行，只要这个节点的执行结果被所有节点看到的时间都是一样的。例如，如果这个操作是将某个数据从0改成1，那么执行这个操作的节点可以是任意一个节点，只要在所有节点看到的时间上，这个数据从0改成1的时刻是一样的。这样可以保证所有节点最终看到的数据都是1，因此也保证了一致性。</p><p>总之，强一致性要求所有节点同时执行，而线性一致性只要求所有节点看到的结果是一样的，但是并不要求同时执行。</p><p><strong>最终一致性</strong>（eventual consistency）是分布式系统中一种弱一致性模型，它的基本思想是在分布式系统中的数据更新不需要实时同步，而是通过异步的方式在不同的节点之间复制和传播数据，最终达到一致的状态。</p><p>在最终一致性模型中，数据的更新是通过消息传递的方式在不同的节点之间进行的，不同节点之间的消息传递可能存在延迟，也可能存在网络分区（network partition）等问题，这些都可能导致节点之间的数据不一致。但是，最终一致性模型保证在一定时间内，所有节点最终会达到一致的状态。</p><p>举个例子，假设有一个分布式缓存系统，其中有两个节点A和B，它们都缓存了某个数据。当客户端请求获取数据时，它可以从节点A或节点B中获取数据，因为它们都缓存了这个数据。如果在某个时刻，节点A更新了这个数据，那么节点B上缓存的数据就过期了，但是由于节点之间可能存在延迟等问题，客户端有可能在一段时间内还是从节点B获取到了旧数据。但是，随着时间的推移，节点B最终会从节点A获取到最新的数据，然后更新自己的缓存，最终达到一致的状态。</p><p><strong>分布式准则</strong></p><p><strong>数据可靠性（Reliability）</strong></p><ul><li>复制技术（Replication）：将数据复制到多个不同节点</li><li>纠删码技术（Erasure Code）：通过校验数据来保证数据可靠性的技术</li></ul><p><strong>数据一致性（Consistency）</strong></p><p><strong>设备故障和容错（Fault Tolerance）</strong></p><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><p><strong>数据库索引失效</strong></p><p> 6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h3 id="工作项目"><a href="#工作项目" class="headerlink" title="工作项目"></a>工作项目</h3><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><p><strong>流程</strong></p><ol><li>指定发布版本运行回归</li><li>评估指标结果，对于基础指标如是否到达，是否碰撞需一一排查；其他指标优先级不高只做报警处理（因为随机性较大），若所有场景的某一指标都有异常变化则需要排查（震荡幅度，运行时间等）</li><li>记录反馈回归结果，与其他模块测试沟通，通过则发灰度版本；否则联系负责人修复</li></ol><p><strong>场景库</strong></p><p>覆盖基础场景和corner case。按场景细分为不同型号车辆，车道环境，障碍物，自车朝向；根据项目细分为绕障，借道等</p><p>来源手动构造，每周接管，数据挖掘抽取</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p><strong>流程</strong></p><ol><li>通过单帧或多帧运行场景，期间监控相关进程的资源占用</li><li>和历史值对比，查看是否合理，反馈问题或者调整阈值</li></ol><p><strong>监控项</strong></p><p>cpu_times：单位时间内CPU 在执行程序时所花费的时间，包括user，kernal，none</p><p>IO rchar&#x2F;wchar：io吞吐量</p><p>Physical&#x2F;Virtual Memory_peak：物理&#x2F;虚拟内存峰值</p><p>GPU_memory_used，GPU_util：显存占用，gpu使用率</p><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p><strong>流程</strong></p><ol><li>更新的优化点和风险点的理解与讨论</li><li>测试用例集的构建</li><li>评估指标的设计</li><li>具体算法问题追踪</li><li>上线流程的把握</li><li>上线后的更新点持续跟踪</li></ol><h3 id="RAFT项目"><a href="#RAFT项目" class="headerlink" title="RAFT项目"></a>RAFT项目</h3><h4 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h4><p><strong>raft通信流程</strong></p><p><strong>leader election</strong></p><h4 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h4><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h4 id="与Paxos对比"><a href="#与Paxos对比" class="headerlink" title="与Paxos对比"></a>与Paxos对比</h4>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（二）引用</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-面向对象编程（二）"><a href="#第五章-面向对象编程（二）" class="headerlink" title="第五章 面向对象编程（二）"></a>第五章 面向对象编程（二）</h2><h3 id="引用的其他用法"><a href="#引用的其他用法" class="headerlink" title="引用的其他用法"></a>引用的其他用法</h3><p>引用作为成员变量</p><p>函数返回引用，可以将返回值做左值</p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>通过类的其他对象初始化当前对象（有默认拷贝构造方法，成员对成员的拷贝，可能发生对象的嵌套拷贝）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//During call by value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">roster</span><span class="params">(Person)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function">Person <span class="title">child</span><span class="params">(<span class="string">&quot;Ruby&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">roster</span>(child); <span class="comment">// call copy ctors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// During initialization, call copy ctor</span></span><br><span class="line"><span class="function">Person <span class="title">baby_a</span><span class="params">(<span class="string">&quot;Fred&quot;</span>)</span></span>;</span><br><span class="line">Person baby_b = baby_a;</span><br><span class="line"><span class="function">Person <span class="title">baby_c</span><span class="params">(baby_a)</span></span>; <span class="comment">// same as above</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//During function return</span></span><br><span class="line"><span class="function">Person <span class="title">captain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">player</span><span class="params">(<span class="string">&quot;George&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T::T(const T&amp;)</p><p>建议每个类提供默认构造函数，拷贝构造函数，虚函数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>private针对类而非对象，可访问另一对象中的private成员</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>定义：存在于某作用域的一块内存空间，在函数本体内声明的任何变量，其使用的内存都取自于栈。在作用域结束后自动清理</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>定义：操作系统提供的一块全局内存空间，程序可动态分配从中获得若干区块。其生命在做犹豫结束后仍然存在，直到整个程序结束</p><p>包含：</p><ul><li>static local objects</li><li>global objects</li><li>heap objects（new）</li></ul><h4 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h4><p>new先分配内存后调用构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Complex* pc = new Complex(1,2);</span></span><br><span class="line"><span class="comment">//for complier, it transform to follow be like</span></span><br><span class="line">Complex *pc;</span><br><span class="line"><span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Complex));<span class="comment">//call malloc to allocate memory</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex *&gt;(mem); <span class="comment">//cast</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//call ctor</span></span><br></pre></td></tr></table></figure><p>delete先调用析构函数后释放内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//delete pc</span></span><br><span class="line"><span class="comment">//for complier, it transform to follow be like</span></span><br><span class="line">Complex::~<span class="built_in">Complex</span>(pc); <span class="comment">//call dtor</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>; <span class="comment">//call free(pc) to release memory</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（三）模版</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>模版函数（template function）为声明不是定义，在使用时根据输入类型定义</p><p>使用模版时，不会使用隐式类型转换</p><p>类模版里的每个函数都是函数模版，需要在声明前加上<code>template</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  BTnode&lt;elemType&gt; *_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（二）字符串、向量和数组</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="标准库类型String"><a href="#标准库类型String" class="headerlink" title="标准库类型String"></a>标准库类型String</h3><p>读写string对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;   <span class="comment">//from empty to empty</span></span><br><span class="line"><span class="built_in">getline</span>(cin,s); <span class="comment">//one line, stop by ENTER</span></span><br></pre></td></tr></table></figure><p>当把string对象和字符（串）字面值混在一条语句时，必须确保加法运算符（+）两侧的运算对象至少一个是string</p><h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h3><p>vector是模板而非类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line">vector&lt;T&gt; v3 = v1; <span class="comment">//same to above</span></span><br><span class="line">vector&lt;T&gt; v4&#123;a,b,c,...&#125;;</span><br><span class="line">vector&lt;T&gt; v5 = &#123;a,b,c,...&#125;; <span class="comment">//same to above</span></span><br></pre></td></tr></table></figure><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>理解复杂的数组声明（P102-103）</p><p>从变量名开始由内往外看，即变量名-数组-变量类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">//含有10个整型指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*parrary)[<span class="number">10</span>] = &amp;arr; <span class="comment">//指向一个含有10个整数的数组的指针</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrREF)[<span class="number">10</span>] = arr; <span class="comment">//引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//引用一个含有10个整型指针的数组</span></span><br></pre></td></tr></table></figure><p>指向一个数组的指针+1后指向数组尾部的下一个地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">int</span>(*a)[<span class="number">2</span>] = &amp;arr;</span><br><span class="line"><span class="type">int</span> *b = arr;</span><br><span class="line">cout &lt;&lt; arr &lt;&lt; endl; <span class="comment">//0x61fe08</span></span><br><span class="line">cout &lt;&lt; arr + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe0c</span></span><br><span class="line">cout &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe10 = 0x61fe08 + (4*2)D</span></span><br><span class="line">cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//0x61fe0c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（五）自增的问题</title>
      <link href="/2025/01/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/01/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>后置递增运算符的优先级高于解引用运算符，因此<code>*p++</code>等同于<code>*（p++）</code></p><p>将p+1后返回p的初始值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（四）inline函数</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="inline-函数"><a href="#inline-函数" class="headerlink" title="inline 函数"></a>inline 函数</h3><p>将函数声明为inline可以避免函数调用的开销，空间换时间</p><p>调用函数步骤：</p><ol><li>返回地址压栈</li><li>函数参数压栈</li><li>计算返回值</li><li>函数部分所有元素出栈，返回值</li></ol><img src="/../../images/assembly code.png" width=500px /><p>普通函数与inline函数的汇编代码对比</p><img src="/../../images/inline.png" width=500px /><p><strong>inline函数不是定义是声明，应该写在头文件里，保证编译器将其作为inline函数展开</strong></p><p>宏定义与inline函数的区别</p><table><thead><tr><th></th><th>宏定义</th><th>inline函数</th></tr></thead><tbody><tr><td>类型检查</td><td>无</td><td>有</td></tr><tr><td>实现方式</td><td>预处理时展开</td><td>由编译器实现展开，是否将函数作为inline依赖于编译器的判断</td></tr><tr><td>其他</td><td>容易引发运算符优先级的问题，不可调试</td><td>可以调试</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL基础</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/</url>
      
        <content type="html"><![CDATA[<h3 id="六大部件"><a href="#六大部件" class="headerlink" title="六大部件"></a>六大部件</h3><img src="/../../images/stl_items.png" alt="stl_items.png" style="zoom:60%;" /><p>分配器：为容器分配内存</p><p>迭代器：算法只能通过迭代器访问容器</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><img src="/../../images/stl.png" alt="stl.png" style="zoom:60%;" /><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h4><p>_M_instance：指向数组首元素的指针（int a[10]的a）</p><img src="/../../images/array_overview.png" alt="array_overview.png" style="zoom:60%;" /><p><strong>iterator为指针，traits通过指针特化处理</strong></p><img src="/../../images/array.png" alt="array.png" style="zoom:60%;" /><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h4><p>start（4B）：指向第一个元素的指针</p><p>finish（4B）：指向最后一个元素的下一个指针</p><p>end_of_storage（4B）：容器申请的内存空间的最后一个元素的下一个地址</p><p>若内存空间不够则申请当前空间两倍的空间</p><img src="/../../images/vector_overview.png" alt="vector_overview.png" style="zoom:60%;" /><p><strong>iterator为指针，traits通过指针特化处理</strong></p><img src="/../../images/vector_iterator.png" alt="vector_iterator.png" style="zoom:60%;" /><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>node（4B）：指向头节点的指针</p><img src="/../../images/list_overview.png" alt="list_overview.png" style="zoom:60%;" /><p><strong>iterator里的node为指向当前节点的指针</strong></p><img src="/../../images/list_iterator.png" alt="list_iterator.png" style="zoom:60%;" /><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward List"></a>Forward List</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><img src="/../../images/forward_list.png" alt="forward_list.png" style="zoom:60%;" /><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>queue在内存中每个buffer块离散存储，通过map表记录各buffer块的地址</p><p>start（16B）：指向首元素的iterator</p><p>finish（16B）：指向尾巴元素下一个块的iterator</p><p>map（4B）：指向map首元素的指针</p><p>map_size：map占用内存的大小</p><img src="/../../images/deque_overview.png" alt="deque_overview.png" style="zoom:60%;" /><p>cur：指向当前元素的指针</p><p>first：指向当前buffer块首元素的指针</p><p>last：指向当前buffer块尾元素下一个块的指针</p><p>node：指向map对应元素的指针</p><img src="/../../images/deque_iterator.png" alt="deque_iterator.png" style="zoom:60%;" /><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>不允许遍历也不提供iterator</p><p>可选择list或deque作为底层存储</p><p>不可选择vector作为底层存储</p><img src="/../../images/queue.png" alt="queue.png" style="zoom:60%;" /><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>不允许遍历也不提供iterator</p><p>可选择list或deque或vector作为底层存储</p><img src="/../../images/stack.png" alt="stack.png" style="zoom:60%;" /><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>t：红黑树</p><img src="/../../images/set.png" alt="set.png" style="zoom:60%;" /><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="键值对集合"><a href="#键值对集合" class="headerlink" title="键值对集合"></a>键值对集合</h4><p>t：红黑树</p><img src="/../../images/map.png" alt="map.png" style="zoom:60%;" /><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的</p><h3 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h3><h3 id="Iterator-Traits"><a href="#Iterator-Traits" class="headerlink" title="Iterator Traits"></a>Iterator Traits</h3><p>由于算法需要得到iterator的某些属性，对于非指针iterator的结构包含属性，但对于指针类型无法获取。通过iterator traits对于iterator处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象（一）运算符重载</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><p>只能重载存在的运算法</p><p>重载运算符必须保留相同操作数数量和优先级</p><h3 id="成员或全局函数"><a href="#成员或全局函数" class="headerlink" title="成员或全局函数"></a>成员或全局函数</h3><p>单目运算符应该做成成员函数</p><p><code>= （） []</code>只能做成成员函数</p><p>所有其他二元运算符做成非成员函数</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>成员函数左操作数（reciver）必须是隶属于同一个class的对象</p><p>加const可以防止返回结果做左值</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（一）CPP编译过程、宏以及头文件</title>
      <link href="/2025/01/03/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/"/>
      <url>/2025/01/03/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<ol><li><p><code>endl</code>将与设备关联的<strong>缓冲区（buffer）</strong>中的内容刷到设备中。在调试时应保证”一直”刷新流。否则若程序崩溃，输出可能还是缓冲区，导致对于程序崩溃位置的错误推断</p></li><li><p>读取数量不定的输入数据可用<code>while (std::in &gt;&gt; value)</code></p><p>当遇到<strong>文件结束符（end-of-file）</strong>，或遇到一个无效输入时，<em>istream</em>对象状态变为无效，使条件为假</p><p>EOF：在Windows中为<code>Ctrl+Z</code>，UNIX为<code>Ctrl+D</code></p></li></ol><h3 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++编译过程"></a>C++编译过程</h3><ol><li><p>预处理（Preprocessing）</p><p>将所有的#include<strong>头文件以及宏定义替换成其真正的内容</strong>，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是<strong>预处理器cpp来完成的</strong>。（include只做文本插入，在include的位置将头文件展开）</p></li><li><p>编译（Compilation）</p><p>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定<strong>汇编代码（assembly code）</strong>的过程。</p><p>一个cpp文件是一个编译单元。</p></li><li><p>汇编（Assemble）</p><p>汇编过程将上一步的汇编代码转换成<strong>机器码（machine code）</strong>，这一步产生的文件叫做目标文件，是二进制格式。</p><p><strong>这一步会为每一个源文件产生一个目标文件</strong>。</p></li><li><p>链接（Linking）</p><p>链接过程将<strong>多个目标文以及所需的库文件（.so等）链接</strong>成最终的<strong>可执行文件（executable file）</strong></p></li></ol><p><img src="/../../images/compiler.png" alt="compiler"></p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>预处理阶段将宏所写内容替换</p><p>宏没有类型检查</p><p>在宏外加括号防止运算符优先级错误</p><p>在宏后不需要加分号（非C++语句）</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>把函数原型放到头文件中，在需要调用这个函数的源代码文件中include到这个头文件，能让编译器在编译时知道函数的原型，以确保函数类型的统一</p><p>头文件里存放声明（extren变量，函数原型，类或结构体的定义），cpp文件里存放定义</p><img src="/../../images/header and cpp.png" width=500px/><p>头文件的标准格式</p><p>用宏定义防止：</p><ol><li>两个头文件相互include时的循环include</li><li>cpp在include不同头文件时可能产生的重复定义（class不能重复定义）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> _MY_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _MY_H_</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标签测试文章</title>
      <link href="/2025/01/02/index/"/>
      <url>/2025/01/02/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> Another Tag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/02/hello-world/"/>
      <url>/2025/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
